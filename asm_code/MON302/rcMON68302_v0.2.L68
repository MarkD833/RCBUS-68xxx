000080F0 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 25/08/2025 14:58:58

00000000                             1  *******************************************************************************
00000000                             2  * rcMon-68302 v0.2
00000000                             3  *******************************************************************************
00000000                             4  * Written to support my own RCBus 68302 board. Supports simple S-Record loading as
00000000                             5  * well as memory display & modification. No breakpoints, single stepping or
00000000                             6  * disassembly stuff.
00000000                             7  *******************************************************************************
00000000                             8  * Assumes that the RCBus ROM/RAM board is fitted with:
00000000                             9  *   ROM : 128K organised as 64K  x 16bits (2x W27C512 EEPROM)
00000000                            10  *   RAM : 1M   organised as 512K x 16bits (2x AS6C4008)
00000000                            11  *
00000000                            12  * The RCBus ROM/RAM board hardware address decoding is used such that:
00000000                            13  *   ROM starts at 0x000000 up to 0x01FFFF (128K)
00000000                            14  *   RAM starts at 0x100000 up to 0x1FFFFF (1M)
00000000                            15  *
00000000                            16  * Use EASyBIN to split the S-Record into ODD and EVEN bytes.
00000000                            17  * The *_0.BIN file goes in the U ROM socket - holding D08..D15
00000000                            18  * The *_1.BIN file goes in the L ROM socket - holding D00..D07
00000000                            19  *
00000000                            20  *******************************************************************************
00000000                            21  * Exception Handling
00000000                            22  *******************************************************************************
00000000                            23  * ROM starts at $0000 and holds the exception vector table. The table entries
00000000                            24  * each jump to a small routine in ROM that gets the handler address from the
00000000                            25  * start of RAM (or wherever VEC_BASE is defined) and re-directs execution to
00000000                            26  * that address.
00000000                            27  * Initially the RAM addresses all point back to handlers in ROM but can be
00000000                            28  * overwritten to point to a user supplied handler in RAM. 
00000000                            29  *
00000000                            30  * BUS ERROR & ADDRESS ERROR handlers always use the ROM vector table addresses.
00000000                            31  * Some Easy68k TRAP #15 text I/O routines are implemented as follows:
00000000                            32  *   Currently only tasks 0,1,5,6,13 & 14 are supported.
00000000                            33  *
00000000                            34  *******************************************************************************
00000000                            35  * Memory Map
00000000                            36  * 0x000000 .. 0x0003FF Exception vector table
00000000                            37  * 0x000400 .. 0x005FFF CP/M-68K v1.3
00000000                            38  * 0x006000 .. 0x006FFF CP/M-68K BIOS
00000000                            39  * 0x007000 .. 0x008FFF This monitor
00000000                            40  * 0x009000 ..          EhBASIC
00000000                            41  * 0x020000 .. 0x03FFFF 1Mb RAM
00000000                            42  *
00000000                            43  * 0xFD0000 .. 0xFDFFFF 64K RCBus MREQ 
00000000                            44  * 0xFE0000 .. 0xFEFFFF 64K RCBus IORQ
00000000                            45  * 0xFFF000 .. 0xFFFFFF MC68302 Internal Peripherals
00000000                            46  *******************************************************************************
00000000                            47  
00000000                            48      INCLUDE "..\asm-inc\memory.inc"
00000000                            49  
00000000  =00000000                 50  ROM_BASE        EQU     $00000
00000000  =00020000                 51  ROM_SIZE        EQU     $20000
00000000                            52  
00000000  =00100000                 53  RAM_BASE        EQU     $100000
00000000  =00100000                 54  RAM_SIZE        EQU     $100000
00000000                            55  
00000000  =00100000                 56  VEC_BASE        EQU     RAM_BASE
00000000  =00000400                 57  VEC_SIZE        EQU     $400         * table takes up 1024 bytes
00000000                            58  
00000000  =00FC0000                 59  RCB_BASE            EQU     $FC0000     * I/O space base address = 00FC_0000
00000000  =00020000                 60  RCB_SIZE            EQU     $020000     * 128K window
00000000  =00FC0000                 61  MEM_BASE            EQU     RCB_BASE
00000000  =00FD0000                 62  IO_BASE             EQU     RCB_BASE+$10000
00000000                            63  
00000000  =00007000                 64  MON_BASE        EQU     $7000
00000000                            65  
00000000  =00009000                 66  EHBASIC_BASE    EQU     $9000
00000000                            67  
00000000  =00000400                 68  CPM_BASE        EQU     $0400       * CP/M-68K entry point
00000000                            69  
00000000  =001FD800                 70  CCP_BSS_BASE    EQU     $1FD800
00000000  =00001000                 71  CCP_PRIV        EQU     4096
00000000                            72  
00000000  =00000800                 73  MON_PRIV        EQU     2048
00000000                            74  
00000000  =00001000                 75  BIOS_PRIV       EQU     4096
00000000                            76  
00000000  =001FF800                 77  STACK_START     EQU     RAM_BASE+RAM_SIZE-MON_PRIV
00000000                            78  
00000000                            79  -------------------- end include --------------------
00000000                            80      INCLUDE "..\asm-inc\mc68302.inc"
00000000                            81  
00000000  =00FFF000                 82  M302_BASE_ADDR  EQU     $FFF000
00000000                            83  
00000000  =000000F2                 84  M302_BAR        EQU     $0000F2 * base address register   (16-bit)
00000000  =000000F4                 85  M302_SCR        EQU     $0000F4 * system control register (32-bit)
00000000  =000000FA                 86  M302_CKCR       EQU     $0000FA * clock control register  (16-bit)
00000000                            87  
00000000  =00FFF400                 88  M302_SCC1PB     EQU     M302_BASE_ADDR+$400     * SCC1 PARAMETER BASE ADDRESS
00000000  =00FFF500                 89  M302_SCC2PB     EQU     M302_BASE_ADDR+$500     * SCC2 PARAMETER BASE ADDRESS
00000000  =00FFF600                 90  M302_SCC3PB     EQU     M302_BASE_ADDR+$600     * SCC3 PARAMETER BASE ADDRESS
00000000                            91  
00000000  =00FFF812                 92  M302_GIMR       EQU     M302_BASE_ADDR+$812
00000000  =00FFF814                 93  M302_IPR        EQU     M302_BASE_ADDR+$814
00000000  =00FFF816                 94  M302_IMR        EQU     M302_BASE_ADDR+$816
00000000  =00FFF818                 95  M302_ISR        EQU     M302_BASE_ADDR+$818
00000000                            96  
00000000  =00FFF81E                 97  M302_PACNT      EQU     M302_BASE_ADDR+$81E     * Port A
00000000  =00FFF820                 98  M302_PADDR      EQU     M302_BASE_ADDR+$820
00000000  =00FFF822                 99  M302_PADAT      EQU     M302_BASE_ADDR+$822
00000000  =00FFF824                100  M302_PBCNT      EQU     M302_BASE_ADDR+$824     * Port B
00000000  =00FFF826                101  M302_PBDDR      EQU     M302_BASE_ADDR+$826
00000000  =00FFF828                102  M302_PBDAT      EQU     M302_BASE_ADDR+$828
00000000                           103  
00000000  =00FFF830                104  M302_BR0        EQU     M302_BASE_ADDR+$830     * CHIP SELECTS
00000000  =00FFF832                105  M302_OR0        EQU     M302_BASE_ADDR+$832
00000000  =00FFF834                106  M302_BR1        EQU     M302_BASE_ADDR+$834
00000000  =00FFF836                107  M302_OR1        EQU     M302_BASE_ADDR+$836
00000000  =00FFF838                108  M302_BR2        EQU     M302_BASE_ADDR+$838
00000000  =00FFF83A                109  M302_OR2        EQU     M302_BASE_ADDR+$83A
00000000  =00FFF83C                110  M302_BR3        EQU     M302_BASE_ADDR+$83C
00000000  =00FFF83E                111  M302_OR3        EQU     M302_BASE_ADDR+$83E
00000000                           112  
00000000  =00FFF840                113  M302_TMR1       EQU     M302_BASE_ADDR+$840     * TIMER 1
00000000  =00FFF842                114  M302_TRR1       EQU     M302_BASE_ADDR+$842
00000000  =00FFF844                115  M302_TCR1       EQU     M302_BASE_ADDR+$844
00000000  =00FFF846                116  M302_TCN1       EQU     M302_BASE_ADDR+$846
00000000  =00FFF849                117  M302_TER1       EQU     M302_BASE_ADDR+$849
00000000                           118  
00000000  =00FFF84A                119  M302_WRR        EQU     M302_BASE_ADDR+$84A     * WATCHDOG
00000000  =00FFF84C                120  M302_WCN        EQU     M302_BASE_ADDR+$84C
00000000                           121  
00000000  =00FFF850                122  M302_TMR2       EQU     M302_BASE_ADDR+$850     * TIMER 2
00000000  =00FFF852                123  M302_TRR2       EQU     M302_BASE_ADDR+$852
00000000  =00FFF854                124  M302_TCR2       EQU     M302_BASE_ADDR+$854
00000000  =00FFF856                125  M302_TCN2       EQU     M302_BASE_ADDR+$856
00000000  =00FFF859                126  M302_TER2       EQU     M302_BASE_ADDR+$859
00000000                           127  
00000000  =00FFF860                128  M302_CR         EQU     M302_BASE_ADDR+$860     * COMMAND REGISTER 1
00000000                           129  
00000000  =00FFF882                130  M302_SCON1      EQU     M302_BASE_ADDR+$882     * SCC1
00000000  =00FFF884                131  M302_SCM1       EQU     M302_BASE_ADDR+$884
00000000  =00FFF886                132  M302_DSR1       EQU     M302_BASE_ADDR+$886
00000000  =00FFF888                133  M302_SCCE1      EQU     M302_BASE_ADDR+$888
00000000  =00FFF88A                134  M302_SCCM1      EQU     M302_BASE_ADDR+$88A
00000000  =00FFF88C                135  M302_SCCS1      EQU     M302_BASE_ADDR+$88C
00000000                           136  
00000000  =00FFF892                137  M302_SCON2      EQU     M302_BASE_ADDR+$892     * SCC2
00000000  =00FFF894                138  M302_SCM2       EQU     M302_BASE_ADDR+$894
00000000  =00FFF896                139  M302_DSR2       EQU     M302_BASE_ADDR+$896
00000000  =00FFF898                140  M302_SCCE2      EQU     M302_BASE_ADDR+$898
00000000  =00FFF89A                141  M302_SCCM2      EQU     M302_BASE_ADDR+$89A
00000000  =00FFF89C                142  M302_SCCS2      EQU     M302_BASE_ADDR+$89C
00000000                           143  
00000000  =00FFF8A2                144  M302_SCON3      EQU     M302_BASE_ADDR+$8A2     * SCC3
00000000  =00FFF8A4                145  M302_SCM3       EQU     M302_BASE_ADDR+$8A4
00000000  =00FFF8A6                146  M302_DSR3       EQU     M302_BASE_ADDR+$8A6
00000000  =00FFF8A8                147  M302_SCCE3      EQU     M302_BASE_ADDR+$8A8
00000000  =00FFF8AA                148  M302_SCCM3      EQU     M302_BASE_ADDR+$8AA
00000000  =00FFF8AC                149  M302_SCCS3      EQU     M302_BASE_ADDR+$8AC
00000000                           150  
00000000  =00FFF8B0                151  M302_SPMODE     EQU     M302_BASE_ADDR+$8B0
00000000  =00FFF8B2                152  M302_SIMASK     EQU     M302_BASE_ADDR+$8B2
00000000  =00FFF8B4                153  M302_SIMODE     EQU     M302_BASE_ADDR+$8B4
00000000                           154  
00000000  =00000000                155  M302_RXBD0      EQU     $00                     * Rx buffer descriptor #0
00000000  =00000008                156  M302_RXBD1      EQU     $08                     * Rx buffer descriptor #1
00000000  =00000010                157  M302_RXBD2      EQU     $10                     * Rx buffer descriptor #2
00000000  =00000018                158  M302_RXBD3      EQU     $18                     * Rx buffer descriptor #3
00000000  =00000020                159  M302_RXBD4      EQU     $20                     * Rx buffer descriptor #4
00000000  =00000028                160  M302_RXBD5      EQU     $28                     * Rx buffer descriptor #5
00000000  =00000030                161  M302_RXBD6      EQU     $30                     * Rx buffer descriptor #6
00000000  =00000038                162  M302_RXBD7      EQU     $38                     * Rx buffer descriptor #7
00000000  =00000040                163  M302_TXBD0      EQU     $40                     * Tx buffer descriptor #0
00000000  =00000048                164  M302_TXBD1      EQU     $48                     * Tx buffer descriptor #1
00000000  =00000050                165  M302_TXBD2      EQU     $50                     * Tx buffer descriptor #2
00000000  =00000058                166  M302_TXBD3      EQU     $58                     * Tx buffer descriptor #3
00000000  =00000060                167  M302_TXBD4      EQU     $60                     * Tx buffer descriptor #4
00000000  =00000068                168  M302_TXBD5      EQU     $68                     * Tx buffer descriptor #5
00000000  =00000070                169  M302_TXBD6      EQU     $70                     * Tx buffer descriptor #6
00000000  =00000078                170  M302_TXBD7      EQU     $78                     * Tx buffer descriptor #7
00000000  =00000080                171  M302_RFCR       EQU     $80                     * Rx function code
00000000  =00000081                172  M302_TFCR       EQU     $81                     * Tx function code
00000000  =00000082                173  M302_MRBLR      EQU     $82                     * Maximum Rx buffer length
00000000  =00000087                174  M302_RXIBN      EQU     $87                     * Rx Internal Buffer Number
00000000  =00000093                175  M302_TXIBN      EQU     $93                     * Rx Internal Buffer Number
00000000  =0000009C                176  M302_MAXIDL     EQU     $9C                     * Max IDLE characters
00000000  =000000A0                177  M302_BRKCR      EQU     $A0                     * Break count register
00000000  =000000A2                178  M302_PAREC      EQU     $A2                     * Rx parity error count
00000000  =000000A4                179  M302_FRMEC      EQU     $A4                     * Rx framing error count
00000000  =000000A6                180  M302_NOSEC      EQU     $A6                     * Rx noise count
00000000  =000000A8                181  M302_BRKEC      EQU     $A8                     * Rx break condition noise count
00000000  =000000AA                182  M302_UADDR1     EQU     $AA                     * UART Address char #1
00000000  =000000AC                183  M302_UADDR2     EQU     $AC                     * UART Address char #2
00000000  =000000B0                184  M302_CCHAR1     EQU     $B0                     * Control char #1
00000000  =000000B2                185  M302_CCHAR2     EQU     $B2                     * Control char #2
00000000  =000000B4                186  M302_CCHAR3     EQU     $B4                     * Control char #3
00000000  =000000B6                187  M302_CCHAR4     EQU     $B6                     * Control char #4
00000000  =000000B8                188  M302_CCHAR5     EQU     $B8                     * Control char #5
00000000  =000000BA                189  M302_CCHAR6     EQU     $BA                     * Control char #6
00000000  =000000BC                190  M302_CCHAR7     EQU     $BC                     * Control char #7
00000000  =000000BE                191  M302_CCHAR8     EQU     $BE                     * Control char #8
00000000                           192  
00000000                           193  -------------------- end include --------------------
00000000                           194  
00000000                           195  *------------------------------------------------------------------------------
00000000                           196  * Macro to "jump" to exception handler pointed to in the RAM vector table
00000000                           197  * Parameter \1 is the vector number 
00000000                           198  * Put the handler address held in RAM onto the stack and RET to it
00000000                           199  *------------------------------------------------------------------------------
00000000                           200  ramVecJump  MACRO
00000000                           201      move.l  VEC_BASE+(\1<<2),-(SP)
00000000                           202      rts
00000000                           203      ENDM
00000000                           204  
00000000                           205  *------------------------------------------------------------------------------
00000000                           206  * ASCII control characters
00000000                           207  *------------------------------------------------------------------------------
00000000  =0000000A                208  ASCII_LF    equ $0A
00000000  =0000000D                209  ASCII_CR    equ $0D
00000000                           210  
00000000                           211  *------------------------------------------------------------------------------
00000000                           212  * SYSCLK is the frequency of the external crystal oscillator in Hz
00000000                           213  * Make sure that this is correct as it's used to calculate the baud rate.
00000000                           214  *------------------------------------------------------------------------------
00000000  =00708000                215  SYSCLK      EQU 7372800
00000000                           216  
00000000                           217  *------------------------------------------------------------------------------
00000000                           218  * SCC1 baud rate value - make sure SYSCLK is set correctly!
00000000                           219  *------------------------------------------------------------------------------
00000000  =0000000B                220  SER1_BAUD       EQU ((SYSCLK>>4)/38400)-1
00000000  =00000080                221  SER1_BUFSIZE    EQU 128
00000000                           222  
00000000                           223  *------------------------------------------------------------------------------
00000000                           224  * Helpers for the 68302 chip select base and option registers
00000000                           225  * CS0 selects the ROM
00000000                           226  * CS1 selects the RAM
00000000                           227  * CS2 selects RCBus MEM (A16=0) or IO (A16=1)
00000000                           228  *------------------------------------------------------------------------------
00000000  =00000000                229  CS0_BR      EQU ROM_BASE>>11
00000000  =00001FC0                230  CS0_OR      EQU (~(ROM_SIZE-1)>>11)&$1FFC
00000000  =00000200                231  CS1_BR      EQU RAM_BASE>>11
00000000  =00001E00                232  CS1_OR      EQU (~((RAM_SIZE-1)>>11))&$1FFC
00000000  =00001F80                233  CS2_BR      EQU RCB_BASE>>11
00000000  =00001FC0                234  CS2_OR      EQU (~((RCB_SIZE-1)>>11))&$1FFC
00000000                           235  
00000000                           236  *------------------------------------------------------------------------------
00000000                           237  * 68000 Exception Vector Table - THIS ONE IS IN ROM
00000000                           238  * All exceptions get the handler addresses from the RAM vector table except for
00000000                           239  * Bus Error, Address Error & TRAP #15 which always call handlers in the ROM. 
00000000                           240  *------------------------------------------------------------------------------
00000000                           241  
00000000                           242      ORG     $0000
00000000                           243  
00000000= 001FF800                 244      DC.l    STACK_START    * Supervisor stack pointer
00000004= 000080F0                 245      DC.l    START          * Initial PC    
00000008                           246  
00000008= 000076F0                 247      DC.L    handleBusErr   *02 Bus Error     (** ROM handler **)
0000000C= 0000770C                 248      DC.L    handleAddrErr  *03 Address Error (** ROM handler **)
00000010= 00007010                 249      DC.L    jmpIllInst     *04 Illegal Instruction
00000014= 00007018                 250      DC.L    jmpZeroDiv     *05 Zero Divide
00000018= 00007020                 251      DC.L    jmpChkInst     *06 CHK Instruction
0000001C= 00007028                 252      DC.L    jmpTrapV       *07 TRAPV Instruction
00000020= 00007030                 253      DC.L    jmpPriv        *08 Privilege Violation
00000024= 00007038                 254      DC.L    jmpTrace       *09 Trace
00000028= 00007040                 255      DC.L    jmpLineA       *0A Line 1010 Emulator
0000002C= 00007048                 256      DC.L    jmpLineF       *0B Line 1111 Emulator
00000030= 00007050                 257      DC.L    jmpRes1        *0C (Unassigned, Reserved)
00000034= 00007058                 258      DC.L    jmpRes2        *0D (Unassigned, Reserved)
00000038= 00007060                 259      DC.L    jmpRes3        *0E (Unassigned, Reserved)
0000003C= 00007068                 260      DC.L    jmpUnInit      *0F Uninitialized Interrupt Vector
00000040= 00007070                 261      DC.L    jmpRes4        *10 (Unassigned, Reserved)
00000044= 00007078                 262      DC.L    jmpRes5        *11 (Unassigned, Reserved)
00000048= 00007080                 263      DC.L    jmpRes6        *12 (Unassigned, Reserved)
0000004C= 00007088                 264      DC.L    jmpRes7        *13 (Unassigned, Reserved)
00000050= 00007090                 265      DC.L    jmpRes8        *14 (Unassigned, Reserved)
00000054= 00007098                 266      DC.L    jmpRes9        *15 (Unassigned, Reserved)
00000058= 000070A0                 267      DC.L    jmpRes10       *16 (Unassigned, Reserved)
0000005C= 000070A8                 268      DC.L    jmpRes11       *17 (Unassigned, Reserved)
00000060= 000070B0                 269      DC.L    jmpSpur        *18 Spurious Interrupt
00000064= 000070B8                 270      DC.L    jmpAV1         *19 Level 1 Interrupt Autovector
00000068= 000070C0                 271      DC.L    jmpAV2         *1A Level 2 Interrupt Autovector
0000006C= 000070C8                 272      DC.L    jmpAV3         *1B Level 3 Interrupt Autovector
00000070= 000070D0                 273      DC.L    jmpAV4         *1C Level 4 Interrupt Autovector
00000074= 000070D8                 274      DC.L    jmpAV5         *1D Level 5 Interrupt Autovector
00000078= 000070E0                 275      DC.L    jmpAV6         *1E Level 6 Interrupt Autovector
0000007C= 000070E8                 276      DC.L    jmpAV7         *1F Level 7 Interrupt Autovector
00000080= 000070F0                 277      DC.L    jmpTrap0       *20 TRAP #0  Instruction Vector
00000084= 000070F8                 278      DC.L    jmpTrap1       *21 TRAP #1  Instruction Vector
00000088= 00007100                 279      DC.L    jmpTrap2       *22 TRAP #2  Instruction Vector
0000008C= 00007108                 280      DC.L    jmpTrap3       *23 TRAP #3  Instruction Vector
00000090= 00007110                 281      DC.L    jmpTrap4       *24 TRAP #4  Instruction Vector
00000094= 00007118                 282      DC.L    jmpTrap5       *25 TRAP #5  Instruction Vector
00000098= 00007120                 283      DC.L    jmpTrap6       *26 TRAP #6  Instruction Vector
0000009C= 00007128                 284      DC.L    jmpTrap7       *27 TRAP #7  Instruction Vector
000000A0= 00007130                 285      DC.L    jmpTrap8       *28 TRAP #8  Instruction Vector
000000A4= 00007138                 286      DC.L    jmpTrap9       *29 TRAP #9  Instruction Vector
000000A8= 00007140                 287      DC.L    jmpTrap10      *2A TRAP #10 Instruction Vector
000000AC= 00007148                 288      DC.L    jmpTrap11      *2B TRAP #11 Instruction Vector
000000B0= 00007150                 289      DC.L    jmpTrap12      *2C TRAP #12 Instruction Vector
000000B4= 00007158                 290      DC.L    jmpTrap13      *2D TRAP #13 Instruction Vector
000000B8= 00007160                 291      DC.L    jmpTrap14      *2E TRAP #14 Instruction Vector
000000BC= 000086A4                 292      DC.L    easy68kTrap15  *2E TRAP #15 Instruction Vector (** ROM handler **)
000000C0                           293          
000000C0                           294  *------------------------------------------------------------------------------
000000C0                           295  * Exception Vectors 30 to 3F are not used on my system so just point them
000000C0                           296  * all to the default handler.
000000C0                           297  
000000C0= 00007170 00007170 ...    298      DCB.L   16,jmpUnused
00000100                           299  
00000100                           300  *------------------------------------------------------------------------------
00000100                           301  * The MC68302 GIMR should have the V7-V5 bits set to 010 so that the MC68302
00000100                           302  * internal peripherals will use exception vectors 40 to 5F.
00000100                           303  
00000100= 000071F0                 304      DC.L    jmp302ev00
00000104= 000071F8                 305      DC.L    jmp302ev01
00000108= 00007200                 306      DC.L    jmp302ev02
0000010C= 00007208                 307      DC.L    jmp302ev03
00000110= 00007210                 308      DC.L    jmp302ev04
00000114= 00007218                 309      DC.L    jmp302ev05
00000118= 00007220                 310      DC.L    jmp302ev06
0000011C= 00007228                 311      DC.L    jmp302ev07
00000120= 00007230                 312      DC.L    jmp302ev08
00000124= 00007238                 313      DC.L    jmp302ev09
00000128= 00007240                 314      DC.L    jmp302ev0A
0000012C= 00007248                 315      DC.L    jmp302ev0B
00000130= 00007250                 316      DC.L    jmp302ev0C
00000134= 00007258                 317      DC.L    jmp302ev0D
00000138= 00007260                 318      DC.L    jmp302ev0E
0000013C= 00007268                 319      DC.L    jmp302ev0F
00000140= 00007270                 320      DC.L    jmp302ev10
00000144= 00007278                 321      DC.L    jmp302ev11
00000148= 00007280                 322      DC.L    jmp302ev12
0000014C= 00007288                 323      DC.L    jmp302ev13
00000150= 00007290                 324      DC.L    jmp302ev14
00000154= 00007298                 325      DC.L    jmp302ev15
00000158= 000072A0                 326      DC.L    jmp302ev16
0000015C= 000072A8                 327      DC.L    jmp302ev17
00000160= 000072B0                 328      DC.L    jmp302ev18
00000164= 000072B8                 329      DC.L    jmp302ev19
00000168= 000072C0                 330      DC.L    jmp302ev1A
0000016C= 000072C8                 331      DC.L    jmp302ev1B
00000170= 000072D0                 332      DC.L    jmp302ev1C
00000174= 000072D8                 333      DC.L    jmp302ev1D
00000178= 000072E0                 334      DC.L    jmp302ev1E
0000017C= 000072E8                 335      DC.L    jmp302ev1F
00000180                           336  
00000180                           337  *------------------------------------------------------------------------------
00000180                           338  * The remaining exception vectors are not used on my system so just point them
00000180                           339  * all to the default handler.
00000180                           340  
00000180= 00007170 00007170 ...    341      DCB.L   160,jmpUnused
00000400                           342  
00000400                           343  *------------------------------------------------------------------------------
00000400                           344  * Start the monitor program after the CP/M BIOS code.
00000400                           345  *------------------------------------------------------------------------------
00007000                           346      ORG     MON_BASE
00007000                           347  
00007000                           348  *------------------------------------------------------------------------------
00007000                           349  * The hard coded ROM exception vector table entries point to these individual
00007000                           350  * handlers that then jump to (actually RETurn to) the address specified in the
00007000                           351  * RAM exception vector table.
00007000                           352  *------------------------------------------------------------------------------
00007000                           353      ORG     (*+1)&-2    * make sure the table is word aligned
00007000                           354  
00007000                           355m jmpBusErr:  ramVecJump  $02
00007008                           356m jmpAddrErr: ramVecJump  $03
00007010                           357m jmpIllInst: ramVecJump  $04
00007018                           358m jmpZeroDiv: ramVecJump  $05
00007020                           359m jmpChkInst: ramVecJump  $06
00007028                           360m jmpTrapV:   ramVecJump  $07
00007030                           361m jmpPriv:    ramVecJump  $08
00007038                           362m jmpTrace:   ramVecJump  $09
00007040                           363m jmpLineA:   ramVecJump  $0A
00007048                           364m jmpLineF:   ramVecJump  $0B
00007050                           365m jmpRes1:    ramVecJump  $0C
00007058                           366m jmpRes2:    ramVecJump  $0D
00007060                           367m jmpRes3:    ramVecJump  $0E
00007068                           368m jmpUnInit:  ramVecJump  $0F
00007070                           369m jmpRes4:    ramVecJump  $10
00007078                           370m jmpRes5:    ramVecJump  $11
00007080                           371m jmpRes6:    ramVecJump  $12
00007088                           372m jmpRes7:    ramVecJump  $13
00007090                           373m jmpRes8:    ramVecJump  $14
00007098                           374m jmpRes9:    ramVecJump  $15
000070A0                           375m jmpRes10:   ramVecJump  $16
000070A8                           376m jmpRes11:   ramVecJump  $17
000070B0                           377m jmpSpur:    ramVecJump  $18
000070B8                           378m jmpAV1:     ramVecJump  $19
000070C0                           379m jmpAV2:     ramVecJump  $1A
000070C8                           380m jmpAV3:     ramVecJump  $1B
000070D0                           381m jmpAV4:     ramVecJump  $1C
000070D8                           382m jmpAV5:     ramVecJump  $1D
000070E0                           383m jmpAV6:     ramVecJump  $1E
000070E8                           384m jmpAV7:     ramVecJump  $1F
000070F0                           385m jmpTrap0:   ramVecJump  $20
000070F8                           386m jmpTrap1:   ramVecJump  $21
00007100                           387m jmpTrap2:   ramVecJump  $22
00007108                           388m jmpTrap3:   ramVecJump  $23
00007110                           389m jmpTrap4:   ramVecJump  $24
00007118                           390m jmpTrap5:   ramVecJump  $25
00007120                           391m jmpTrap6:   ramVecJump  $26
00007128                           392m jmpTrap7:   ramVecJump  $27
00007130                           393m jmpTrap8:   ramVecJump  $28
00007138                           394m jmpTrap9:   ramVecJump  $29
00007140                           395m jmpTrap10:  ramVecJump  $2A
00007148                           396m jmpTrap11:  ramVecJump  $2B
00007150                           397m jmpTrap12:  ramVecJump  $2C
00007158                           398m jmpTrap13:  ramVecJump  $2D
00007160                           399m jmpTrap14:  ramVecJump  $2E
00007168                           400m jmpTrap15:  ramVecJump  $2F
00007170                           401  
00007170                           402m jmpUnused:  ramVecJump  $30
00007178                           403m             ramVecJump  $31
00007180                           404m             ramVecJump  $32
00007188                           405m             ramVecJump  $33
00007190                           406m             ramVecJump  $34
00007198                           407m             ramVecJump  $35
000071A0                           408m             ramVecJump  $36
000071A8                           409m             ramVecJump  $37
000071B0                           410m             ramVecJump  $38
000071B8                           411m             ramVecJump  $39
000071C0                           412m             ramVecJump  $3A
000071C8                           413m             ramVecJump  $3B
000071D0                           414m             ramVecJump  $3C
000071D8                           415m             ramVecJump  $3D
000071E0                           416m             ramVecJump  $3E
000071E8                           417m             ramVecJump  $3F
000071F0                           418  
000071F0                           419m jmp302ev00: ramVecJump  $40
000071F8                           420m jmp302ev01: ramVecJump  $41
00007200                           421m jmp302ev02: ramVecJump  $42
00007208                           422m jmp302ev03: ramVecJump  $43
00007210                           423m jmp302ev04: ramVecJump  $44
00007218                           424m jmp302ev05: ramVecJump  $45
00007220                           425m jmp302ev06: ramVecJump  $46
00007228                           426m jmp302ev07: ramVecJump  $47
00007230                           427m jmp302ev08: ramVecJump  $48
00007238                           428m jmp302ev09: ramVecJump  $49
00007240                           429m jmp302ev0A: ramVecJump  $4A
00007248                           430m jmp302ev0B: ramVecJump  $4B
00007250                           431m jmp302ev0C: ramVecJump  $4C
00007258                           432m jmp302ev0D: ramVecJump  $4D
00007260                           433m jmp302ev0E: ramVecJump  $4E
00007268                           434m jmp302ev0F: ramVecJump  $4F
00007270                           435m jmp302ev10: ramVecJump  $50
00007278                           436m jmp302ev11: ramVecJump  $51
00007280                           437m jmp302ev12: ramVecJump  $52
00007288                           438m jmp302ev13: ramVecJump  $53
00007290                           439m jmp302ev14: ramVecJump  $54
00007298                           440m jmp302ev15: ramVecJump  $55
000072A0                           441m jmp302ev16: ramVecJump  $56
000072A8                           442m jmp302ev17: ramVecJump  $57
000072B0                           443m jmp302ev18: ramVecJump  $58
000072B8                           444m jmp302ev19: ramVecJump  $59
000072C0                           445m jmp302ev1A: ramVecJump  $5A
000072C8                           446m jmp302ev1B: ramVecJump  $5B
000072D0                           447m jmp302ev1C: ramVecJump  $5C
000072D8                           448m jmp302ev1D: ramVecJump  $5D
000072E0                           449m jmp302ev1E: ramVecJump  $5E
000072E8                           450m jmp302ev1F: ramVecJump  $5F
000072F0                           451  
000072F0                           452  * we don't need to specify any more RAM vector table entries as we don't use
000072F0                           453  * them and the ROM table will redirect them all to "jmpUnused".
000072F0                           454  
000072F0                           455  *------------------------------------------------------------------------------
000072F0                           456  * This is the initial exception vector table that gets copied into RAM. It just
000072F0                           457  * holds the addresses of basic exception handlers in ROM. The ramVecJump macro
000072F0                           458  * indexes into this table to get the addresses of the actual exception handlers. 
000072F0                           459  *
000072F0                           460  * NOTE: Bus Error, Address Error & TRAP #15 are all hard coded to be handled by
000072F0                           461  * routines in ROM and the entries in this table are not used.
000072F0                           462  *------------------------------------------------------------------------------
000072F0                           463      ORG     (*+1)&-2       * make sure the table is word aligned
000072F0                           464  
000072F0                           465  rom2ramIVT:
000072F0= 001FF800                 466      DC.L    STACK_START    *00 Supervisor stack pointer
000072F4= 000080F0                 467      DC.L    START          *01 Initial PC    
000072F8                           468  
000072F8= 000076F0                 469      DC.L    handleBusErr   *02 Bus Error
000072FC= 0000770C                 470      DC.L    handleAddrErr  *03 Address Error
00007300= 00007728                 471      DC.L    handleIllInst  *04 Illegal Instruction
00007304= 00007734                 472      DC.L    handleZeroDiv  *05 Zero Divide
00007308= 00007740                 473      DC.L    handleChkInst  *06 CHK Instruction
0000730C= 0000774C                 474      DC.L    handleTrapV    *07 TRAPV Instruction
00007310= 00007758                 475      DC.L    handlePriv     *08 Privilege Violation
00007314= 00007764                 476      DC.L    handleTrace    *09 Trace
00007318= 00007770                 477      DC.L    handleLineA    *0A Line 1010 Emulator
0000731C= 0000777C                 478      DC.L    handleLineF    *0B Line 1111 Emulator
00007320= 00007788                 479      DC.L    handleRes1     *0C (Unassigned, Reserved)
00007324= 00007788                 480      DC.L    handleRes2     *0D (Unassigned, Reserved)
00007328= 00007788                 481      DC.L    handleRes3     *0E (Unassigned, Reserved)
0000732C= 00007794                 482      DC.L    handleUnInit   *0F Uninitialized Interrupt Vector
00007330= 00007788                 483      DC.L    handleRes4     *10 (Unassigned, Reserved)
00007334= 00007788                 484      DC.L    handleRes5     *11 (Unassigned, Reserved)
00007338= 00007788                 485      DC.L    handleRes6     *12 (Unassigned, Reserved)
0000733C= 00007788                 486      DC.L    handleRes7     *13 (Unassigned, Reserved)
00007340= 00007788                 487      DC.L    handleRes8     *14 (Unassigned, Reserved)
00007344= 00007788                 488      DC.L    handleRes9     *15 (Unassigned, Reserved)
00007348= 00007788                 489      DC.L    handleRes10    *16 (Unassigned, Reserved)
0000734C= 00007788                 490      DC.L    handleRes11    *17 (Unassigned, Reserved)
00007350= 000077A0                 491      DC.L    handleSpur     *18 Spurious Interrupt
00007354= 000077AC                 492      DC.L    handleAV1      *19 Level 1 Interrupt Autovector
00007358= 000077B8                 493      DC.L    handleAV2      *1A Level 2 Interrupt Autovector
0000735C= 000077C4                 494      DC.L    handleAV3      *1B Level 3 Interrupt Autovector
00007360= 000077D0                 495      DC.L    handleAV4      *1C Level 4 Interrupt Autovector
00007364= 000077DC                 496      DC.L    handleAV5      *1D Level 5 Interrupt Autovector
00007368= 000077E8                 497      DC.L    handleAV6      *1E Level 6 Interrupt Autovector
0000736C= 000077F4                 498      DC.L    handleAV7      *1F Level 7 Interrupt Autovector
00007370= 00007800                 499      DC.L    handleTrap0    *20 TRAP #0  Instruction Vector
00007374= 0000780C                 500      DC.L    handleTrap1    *21 TRAP #1  Instruction Vector
00007378= 00007818                 501      DC.L    handleTrap2    *22 TRAP #2  Instruction Vector
0000737C= 00007824                 502      DC.L    handleTrap3    *23 TRAP #3  Instruction Vector
00007380= 00007830                 503      DC.L    handleTrap4    *24 TRAP #4  Instruction Vector
00007384= 0000783C                 504      DC.L    handleTrap5    *25 TRAP #5  Instruction Vector
00007388= 00007848                 505      DC.L    handleTrap6    *26 TRAP #6  Instruction Vector
0000738C= 00007854                 506      DC.L    handleTrap7    *27 TRAP #7  Instruction Vector
00007390= 00007860                 507      DC.L    handleTrap8    *28 TRAP #8  Instruction Vector
00007394= 0000786C                 508      DC.L    handleTrap9    *29 TRAP #9  Instruction Vector
00007398= 00007878                 509      DC.L    handleTrap10   *2A TRAP #10 Instruction Vector
0000739C= 00007884                 510      DC.L    handleTrap11   *2B TRAP #11 Instruction Vector
000073A0= 00007890                 511      DC.L    handleTrap12   *2C TRAP #12 Instruction Vector
000073A4= 0000789C                 512      DC.L    handleTrap13   *2D TRAP #13 Instruction Vector
000073A8= 000078A8                 513      DC.L    handleTrap14   *2E TRAP #14 Instruction Vector
000073AC= 000078B4                 514      DC.L    handleTrap15   *2F TRAP #15 Instruction Vector
000073B0                           515  
000073B0= 000078C0 000078C0 ...    516      DCB.L   208,handleUnused
000076F0                           517  
000076F0                           518  *------------------------------------------------------------------------------
000076F0                           519  * Below are the actual exception handlers that are accessed from the vector
000076F0                           520  * table in RAM. The user can overwrite any of the RAM vector table addresses
000076F0                           521  * with the address of their own exception handler. These handlers simply output
000076F0                           522  * a message to the serial port and enter an endless loop.
000076F0                           523  *------------------------------------------------------------------------------
000076F0                           524  
000076F0                           525  *------------------------------------------------------------------------------
000076F0                           526  * BUS ERROR handler
000076F0                           527  * Print a message showing the PC and address being accessed
000076F0                           528  *------------------------------------------------------------------------------
000076F0                           529  handleBusErr:
000076F0  41FA 0402                530      lea     bemsg1(PC), a0  * first message
000076F4  6100 10F2                531      bsr.w   putString
000076F8  202F 000A                532      move.l  10(a7),d0       * get the program counter 
000076FC  6100 10A6                533      bsr.w   writeAddr32
00007700                           534      
00007700  41FA 0431                535      lea     bemsg2(PC), a0  * second message
00007704  6100 10E2                536      bsr.w   putString
00007708  6000 01C2                537      bra.w   handleCleanUp
0000770C                           538      
0000770C                           539  *------------------------------------------------------------------------------
0000770C                           540  * ADDRESS ERROR handler
0000770C                           541  * Print a message showing the PC and address being accessed
0000770C                           542  *------------------------------------------------------------------------------
0000770C                           543  handleAddrErr:
0000770C  41FA 01CC                544      lea     aemsg1(PC), a0  * first message
00007710  6100 10D6                545      bsr.w   putString
00007714  202F 000A                546      move.l  10(a7),d0       * get the program counter 
00007718  6100 108A                547      bsr.w   writeAddr32
0000771C                           548      
0000771C  41FA 0200                549      lea     aemsg2(PC), a0  * second message
00007720  6100 10C6                550      bsr.w   putString
00007724  6000 01A6                551      bra.w   handleCleanUp
00007728                           552      
00007728                           553  *------------------------------------------------------------------------------
00007728                           554  * ILLEGAL INSTRUCTION handler
00007728                           555  *------------------------------------------------------------------------------
00007728                           556  handleIllInst:
00007728  41FA 0468                557      lea     iimsg(PC), a0   * display message
0000772C  6100 10BA                558      bsr.w   putString
00007730  6000 019A                559      bra.w   handleCleanUp
00007734                           560      
00007734                           561  *------------------------------------------------------------------------------
00007734                           562  * DIVISION BY ZERO handler
00007734                           563  *------------------------------------------------------------------------------
00007734                           564  handleZeroDiv:
00007734  41FA 0985                565      lea     zdmsg(PC), a0   * display message
00007738  6100 10AE                566      bsr.w   putString
0000773C  6000 018E                567      bra.w   handleCleanUp
00007740                           568      
00007740                           569  *------------------------------------------------------------------------------
00007740                           570  * CHK handler
00007740                           571  *------------------------------------------------------------------------------
00007740                           572  handleChkInst:
00007740  41FA 0423                573      lea     cimsg(PC), a0   * display message
00007744  6100 10A2                574      bsr.w   putString
00007748  6000 0182                575      bra.w   handleCleanUp
0000774C                           576      
0000774C                           577  *------------------------------------------------------------------------------
0000774C                           578  * TRAPV handler
0000774C                           579  *------------------------------------------------------------------------------
0000774C                           580  handleTrapV:
0000774C  41FA 08CF                581      lea     tvmsg(PC), a0   * display message
00007750  6100 1096                582      bsr.w   putString
00007754  6000 0176                583      bra.w   handleCleanUp
00007758                           584      
00007758                           585  *------------------------------------------------------------------------------
00007758                           586  * PRIVILEGE VIOLATION handler
00007758                           587  *------------------------------------------------------------------------------
00007758                           588  handlePriv:
00007758  41FA 04D3                589      lea     pvmsg(PC), a0   * display message
0000775C  6100 108A                590      bsr.w   putString
00007760  6000 016A                591      bra.w   handleCleanUp
00007764                           592      
00007764                           593  *------------------------------------------------------------------------------
00007764                           594  * TRACE handler
00007764                           595  *------------------------------------------------------------------------------
00007764                           596  handleTrace:
00007764  41FA 0572                597      lea     trmsg(PC), a0   * display message
00007768  6100 107E                598      bsr.w   putString
0000776C  6000 015E                599      bra.w   handleCleanUp
00007770                           600      
00007770                           601  *------------------------------------------------------------------------------
00007770                           602  * Unimplementd Instruction - Line A handler
00007770                           603  *------------------------------------------------------------------------------
00007770                           604  handleLineA:
00007770  41FA 045B                605      lea     lamsg(PC), a0   * display message
00007774  6100 1072                606      bsr.w   putString
00007778  6000 0152                607      bra.w   handleCleanUp
0000777C                           608      
0000777C                           609  *------------------------------------------------------------------------------
0000777C                           610  * Unimplementd Instruction - Line F handler
0000777C                           611  *------------------------------------------------------------------------------
0000777C                           612  handleLineF:
0000777C  41FA 047F                613      lea     lfmsg(PC), a0   * display message
00007780  6100 1066                614      bsr.w   putString
00007784  6000 0146                615      bra.w   handleCleanUp
00007788                           616      
00007788                           617  *------------------------------------------------------------------------------
00007788                           618  * Reserved Instruction handler
00007788                           619  *------------------------------------------------------------------------------
00007788                           620  handleRes1:
00007788                           621  handleRes2:
00007788                           622  handleRes3:
00007788                           623  handleRes4:
00007788                           624  handleRes5:
00007788                           625  handleRes6:
00007788                           626  handleRes7:
00007788                           627  handleRes8:
00007788                           628  handleRes9:
00007788                           629  handleRes10:
00007788                           630  handleRes11:
00007788  41FA 04E0                631      lea     rimsg(PC), a0   * display message
0000778C  6100 105A                632      bsr.w   putString
00007790  6000 013A                633      bra.w   handleCleanUp
00007794                           634      
00007794                           635  *------------------------------------------------------------------------------
00007794                           636  * Uninitialised Interrupt handler
00007794                           637  *------------------------------------------------------------------------------
00007794                           638  handleUnInit:
00007794  41FA 08B6                639      lea     uimsg(PC), a0   * display message
00007798  6100 104E                640      bsr.w   putString
0000779C  6000 012E                641      bra.w   handleCleanUp
000077A0                           642      
000077A0                           643  *------------------------------------------------------------------------------
000077A0                           644  * Spurious Interrupt handler
000077A0                           645  *------------------------------------------------------------------------------
000077A0                           646  handleSpur:
000077A0  41FA 04FA                647      lea     simsg(PC), a0   * display message
000077A4  6100 1042                648      bsr.w   putString
000077A8  6000 0122                649      bra.w   handleCleanUp
000077AC                           650      
000077AC                           651  *------------------------------------------------------------------------------
000077AC                           652  * Autovector Level 1 Exception handler
000077AC                           653  *------------------------------------------------------------------------------
000077AC                           654  handleAV1:
000077AC  41FA 01A2                655      lea     av1msg(PC), a0  * display message
000077B0  6100 1036                656      bsr.w   putString
000077B4  6000 0116                657      bra.w   handleCleanUp
000077B8                           658  
000077B8                           659  *------------------------------------------------------------------------------
000077B8                           660  * Autovector Level 2 Exception handler
000077B8                           661  *------------------------------------------------------------------------------
000077B8                           662  handleAV2:
000077B8  41FA 01D2                663      lea     av2msg(PC), a0  * display message
000077BC  6100 102A                664      bsr.w   putString
000077C0  6000 010A                665      bra.w   handleCleanUp
000077C4                           666  
000077C4                           667  *------------------------------------------------------------------------------
000077C4                           668  * Autovector Level 3 Exception handler
000077C4                           669  *------------------------------------------------------------------------------
000077C4                           670  handleAV3:
000077C4  41FA 0202                671      lea     av3msg(PC), a0  * display message
000077C8  6100 101E                672      bsr.w   putString
000077CC  6000 00FE                673      bra.w   handleCleanUp
000077D0                           674  
000077D0                           675  *------------------------------------------------------------------------------
000077D0                           676  * Autovector Level 4 Exception handler
000077D0                           677  *------------------------------------------------------------------------------
000077D0                           678  handleAV4:
000077D0  41FA 0232                679      lea     av4msg(PC), a0  * display message
000077D4  6100 1012                680      bsr.w   putString
000077D8  6000 00F2                681      bra.w   handleCleanUp
000077DC                           682  
000077DC                           683  *------------------------------------------------------------------------------
000077DC                           684  * Autovector Level 5 Exception handler
000077DC                           685  *------------------------------------------------------------------------------
000077DC                           686  handleAV5:
000077DC  41FA 0262                687      lea     av5msg(PC), a0  * display message
000077E0  6100 1006                688      bsr.w   putString
000077E4  6000 00E6                689      bra.w   handleCleanUp
000077E8                           690  
000077E8                           691  *------------------------------------------------------------------------------
000077E8                           692  * Autovector Level 6 Exception handler
000077E8                           693  *------------------------------------------------------------------------------
000077E8                           694  handleAV6:
000077E8  41FA 0292                695      lea     av6msg(PC), a0  * display message
000077EC  6100 0FFA                696      bsr.w   putString
000077F0  6000 00DA                697      bra.w   handleCleanUp
000077F4                           698  
000077F4                           699  *------------------------------------------------------------------------------
000077F4                           700  * Autovector Level 7 Exception handler
000077F4                           701  *------------------------------------------------------------------------------
000077F4                           702  handleAV7:
000077F4  41FA 02C2                703      lea     av7msg(PC), a0  * display message
000077F8  6100 0FEE                704      bsr.w   putString
000077FC  6000 00CE                705      bra.w   handleCleanUp
00007800                           706      
00007800                           707  *------------------------------------------------------------------------------
00007800                           708  * TRAP #0 Exception handler
00007800                           709  *------------------------------------------------------------------------------
00007800                           710  handleTrap0:
00007800  41FA 0505                711      lea     tr0msg(PC), a0  * display message
00007804  6100 0FE2                712      bsr.w   putString
00007808  6000 00C2                713      bra.w   handleCleanUp
0000780C                           714  
0000780C                           715  *------------------------------------------------------------------------------
0000780C                           716  * TRAP #1 Exception handler
0000780C                           717  *------------------------------------------------------------------------------
0000780C                           718  handleTrap1:
0000780C  41FA 052A                719      lea     tr1msg(PC), a0  * display message
00007810  6100 0FD6                720      bsr.w   putString
00007814  6000 00B6                721      bra.w   handleCleanUp
00007818                           722  
00007818                           723  *------------------------------------------------------------------------------
00007818                           724  * TRAP #2 Exception handler
00007818                           725  *------------------------------------------------------------------------------
00007818                           726  handleTrap2:
00007818  41FA 054F                727      lea     tr2msg(PC), a0  * display message
0000781C  6100 0FCA                728      bsr.w   putString
00007820  6000 00AA                729      bra.w   handleCleanUp
00007824                           730  
00007824                           731  *------------------------------------------------------------------------------
00007824                           732  * TRAP #3 Exception handler
00007824                           733  *------------------------------------------------------------------------------
00007824                           734  handleTrap3:
00007824  41FA 0574                735      lea     tr3msg(PC), a0  * display message
00007828  6100 0FBE                736      bsr.w   putString
0000782C  6000 009E                737      bra.w   handleCleanUp
00007830                           738  
00007830                           739  *------------------------------------------------------------------------------
00007830                           740  * TRAP #4 Exception handler
00007830                           741  *------------------------------------------------------------------------------
00007830                           742  handleTrap4:
00007830  41FA 0599                743      lea     tr4msg(PC), a0  * display message
00007834  6100 0FB2                744      bsr.w   putString
00007838  6000 0092                745      bra.w   handleCleanUp
0000783C                           746  
0000783C                           747  *------------------------------------------------------------------------------
0000783C                           748  * TRAP #5 Exception handler
0000783C                           749  *------------------------------------------------------------------------------
0000783C                           750  handleTrap5:
0000783C  41FA 05BE                751      lea     tr5msg(PC), a0  * display message
00007840  6100 0FA6                752      bsr.w   putString
00007844  6000 0086                753      bra.w   handleCleanUp
00007848                           754  
00007848                           755  *------------------------------------------------------------------------------
00007848                           756  * TRAP #6 Exception handler
00007848                           757  *------------------------------------------------------------------------------
00007848                           758  handleTrap6:
00007848  41FA 05E3                759      lea     tr6msg(PC), a0  * display message
0000784C  6100 0F9A                760      bsr.w   putString
00007850  6000 007A                761      bra.w   handleCleanUp
00007854                           762  
00007854                           763  *------------------------------------------------------------------------------
00007854                           764  * TRAP #7 Exception handler
00007854                           765  *------------------------------------------------------------------------------
00007854                           766  handleTrap7:
00007854  41FA 0608                767      lea     tr7msg(PC), a0  * display message
00007858  6100 0F8E                768      bsr.w   putString
0000785C  6000 006E                769      bra.w   handleCleanUp
00007860                           770  
00007860                           771  *------------------------------------------------------------------------------
00007860                           772  * TRAP #8 Exception handler
00007860                           773  *------------------------------------------------------------------------------
00007860                           774  handleTrap8:
00007860  41FA 062D                775      lea     tr8msg(PC), a0  * display message
00007864  6100 0F82                776      bsr.w   putString
00007868  6000 0062                777      bra.w   handleCleanUp
0000786C                           778  
0000786C                           779  *------------------------------------------------------------------------------
0000786C                           780  * TRAP #9 Exception handler
0000786C                           781  *------------------------------------------------------------------------------
0000786C                           782  handleTrap9:
0000786C  41FA 0652                783      lea     tr9msg(PC), a0  * display message
00007870  6100 0F76                784      bsr.w   putString
00007874  6000 0056                785      bra.w   handleCleanUp
00007878                           786  
00007878                           787  *------------------------------------------------------------------------------
00007878                           788  * TRAP #10 Exception handler
00007878                           789  *------------------------------------------------------------------------------
00007878                           790  handleTrap10:
00007878  41FA 0677                791      lea     tr10msg(PC), a0 * display message
0000787C  6100 0F6A                792      bsr.w   putString
00007880  6000 004A                793      bra.w   handleCleanUp
00007884                           794  
00007884                           795  *------------------------------------------------------------------------------
00007884                           796  * TRAP #11 Exception handler
00007884                           797  *------------------------------------------------------------------------------
00007884                           798  handleTrap11:
00007884  41FA 069D                799      lea     tr11msg(PC), a0 * display message
00007888  6100 0F5E                800      bsr.w   putString
0000788C  6000 003E                801      bra.w   handleCleanUp
00007890                           802  
00007890                           803  *------------------------------------------------------------------------------
00007890                           804  * TRAP #12 Exception handler
00007890                           805  *------------------------------------------------------------------------------
00007890                           806  handleTrap12:
00007890  41FA 06C3                807      lea     tr12msg(PC), a0 * display message
00007894  6100 0F52                808      bsr.w   putString
00007898  6000 0032                809      bra.w   handleCleanUp
0000789C                           810      
0000789C                           811  *------------------------------------------------------------------------------
0000789C                           812  * TRAP #13 Exception handler
0000789C                           813  *------------------------------------------------------------------------------
0000789C                           814  handleTrap13:
0000789C  41FA 06E9                815      lea     tr13msg(PC), a0 * display message
000078A0  6100 0F46                816      bsr.w   putString
000078A4  6000 0026                817      bra.w   handleCleanUp
000078A8                           818      
000078A8                           819  *------------------------------------------------------------------------------
000078A8                           820  * TRAP #14 Exception handler
000078A8                           821  *------------------------------------------------------------------------------
000078A8                           822  handleTrap14:
000078A8  41FA 070F                823      lea     tr14msg(PC), a0 * display message
000078AC  6100 0F3A                824      bsr.w   putString
000078B0  6000 001A                825      bra.w   handleCleanUp
000078B4                           826      
000078B4                           827  *------------------------------------------------------------------------------
000078B4                           828  * TRAP #15 Exception handler
000078B4                           829  *------------------------------------------------------------------------------
000078B4                           830  handleTrap15:
000078B4  41FA 0735                831      lea     tr15msg(PC), a0 * display message
000078B8  6100 0F2E                832      bsr.w   putString
000078BC  6000 000E                833      bra.w   handleCleanUp
000078C0                           834      
000078C0                           835  *------------------------------------------------------------------------------
000078C0                           836  * User Exception handler - all remaining exception handlers land here
000078C0                           837  *------------------------------------------------------------------------------
000078C0                           838  handleUnused:
000078C0  41FA 07CB                839      lea     usermsg(PC), a0 * display message
000078C4  6100 0F22                840      bsr.w   putString
000078C8  6000 0002                841      bra.w   handleCleanUp
000078CC                           842      
000078CC                           843  *------------------------------------------------------------------------------
000078CC                           844  * All exception handlers jump here to output the PC of the next instruction
000078CC                           845  * after the exception occured and then enter an endless loop.
000078CC                           846  *------------------------------------------------------------------------------
000078CC                           847  handleCleanUp:
000078CC  202F 0002                848      move.l  2(a7),d0        * get the address
000078D0  6100 0ED2                849      bsr.w   writeAddr32
000078D4  6100 0F0E                850      bsr.w   putCRLF
000078D8                           851  .infloop:
000078D8  60FE                     852      bra.s   .infloop
000078DA                           853  
000078DA                           854  *------------------------------------------------------------------------------
000078DA                           855  * Exception handler messages
000078DA                           856  *------------------------------------------------------------------------------
000078DA= 0A 0D 53 54 4F 50 ...    857  aemsg1:  dc.b   10,13,'STOP: An Address Error occured whilst executing code at address $',0
0000791E= 0A 0D 53 54 4F 50 ...    858  aemsg2:  dc.b   10,13,'STOP: The address location being accessed was $',0
00007950= 0A 0D 53 54 4F 50 ...    859  av1msg:  dc.b   10,13,'STOP: Autovector Level 1 exception occured near address $',0
0000798C= 0A 0D 53 54 4F 50 ...    860  av2msg:  dc.b   10,13,'STOP: Autovector Level 2 exception occured near address $',0
000079C8= 0A 0D 53 54 4F 50 ...    861  av3msg:  dc.b   10,13,'STOP: Autovector Level 3 exception occured near address $',0
00007A04= 0A 0D 53 54 4F 50 ...    862  av4msg:  dc.b   10,13,'STOP: Autovector Level 4 exception occured near address $',0
00007A40= 0A 0D 53 54 4F 50 ...    863  av5msg:  dc.b   10,13,'STOP: Autovector Level 5 exception occured near address $',0
00007A7C= 0A 0D 53 54 4F 50 ...    864  av6msg:  dc.b   10,13,'STOP: Autovector Level 6 exception occured near address $',0
00007AB8= 0A 0D 53 54 4F 50 ...    865  av7msg:  dc.b   10,13,'STOP: Autovector Level 7 exception occured near address $',0
00007AF4= 0A 0D 53 54 4F 50 ...    866  bemsg1:  dc.b   10,13,'STOP: A Bus Error occured whilst executing code at address $',0
00007B33= 0A 0D 20 20 20 20 ...    867  bemsg2:  dc.b   10,13,'    : The address location being accessed was $',0
00007B65= 0A 0D 53 54 4F 50 ...    868  cimsg:   dc.b   10,13,'STOP: CHK exception occured near address $',0
00007B92= 0A 0D 53 54 4F 50 ...    869  iimsg:   dc.b   10,13,'STOP: Illegal Instruction was encountered near address $',0
00007BCD= 0A 0D 53 54 4F 50 ...    870  lamsg:   dc.b   10,13,'STOP: LINE A exception occured near address $',0
00007BFD= 0A 0D 53 54 4F 50 ...    871  lfmsg:   dc.b   10,13,'STOP: LINE F exception occured near address $',0
00007C2D= 0A 0D 53 54 4F 50 ...    872  pvmsg:   dc.b   10,13,'STOP: Privilege Viloation exception occured near address $',0
00007C6A= 0A 0D 53 54 4F 50 ...    873  rimsg:   dc.b   10,13,'STOP: Reserved exception occured near address $',0
00007C9C= 0A 0D 53 54 4F 50 ...    874  simsg:   dc.b   10,13,'STOP: Spurious Interrupt exception occured near address $',0
00007CD8= 0A 0D 53 54 4F 50 ...    875  trmsg:   dc.b   10,13,'STOP: TRACE exception occured near address $',0
00007D07= 0A 0D 53 54 4F 50 ...    876  tr0msg:  dc.b   10,13,'STOP: TRAP #0 exception occured near address $',0
00007D38= 0A 0D 53 54 4F 50 ...    877  tr1msg:  dc.b   10,13,'STOP: TRAP #1 exception occured near address $',0
00007D69= 0A 0D 53 54 4F 50 ...    878  tr2msg:  dc.b   10,13,'STOP: TRAP #2 exception occured near address $',0
00007D9A= 0A 0D 53 54 4F 50 ...    879  tr3msg:  dc.b   10,13,'STOP: TRAP #3 exception occured near address $',0
00007DCB= 0A 0D 53 54 4F 50 ...    880  tr4msg:  dc.b   10,13,'STOP: TRAP #4 exception occured near address $',0
00007DFC= 0A 0D 53 54 4F 50 ...    881  tr5msg:  dc.b   10,13,'STOP: TRAP #5 exception occured near address $',0
00007E2D= 0A 0D 53 54 4F 50 ...    882  tr6msg:  dc.b   10,13,'STOP: TRAP #6 exception occured near address $',0
00007E5E= 0A 0D 53 54 4F 50 ...    883  tr7msg:  dc.b   10,13,'STOP: TRAP #7 exception occured near address $',0
00007E8F= 0A 0D 53 54 4F 50 ...    884  tr8msg:  dc.b   10,13,'STOP: TRAP #8 exception occured near address $',0
00007EC0= 0A 0D 53 54 4F 50 ...    885  tr9msg:  dc.b   10,13,'STOP: TRAP #9 exception occured near address $',0
00007EF1= 0A 0D 53 54 4F 50 ...    886  tr10msg: dc.b   10,13,'STOP: TRAP #10 exception occured near address $',0
00007F23= 0A 0D 53 54 4F 50 ...    887  tr11msg: dc.b   10,13,'STOP: TRAP #11 exception occured near address $',0
00007F55= 0A 0D 53 54 4F 50 ...    888  tr12msg: dc.b   10,13,'STOP: TRAP #12 exception occured near address $',0
00007F87= 0A 0D 53 54 4F 50 ...    889  tr13msg: dc.b   10,13,'STOP: TRAP #13 exception occured near address $',0
00007FB9= 0A 0D 53 54 4F 50 ...    890  tr14msg: dc.b   10,13,'STOP: TRAP #14 exception occured near address $',0
00007FEB= 0A 0D 53 54 4F 50 ...    891  tr15msg: dc.b   10,13,'STOP: TRAP #15 exception occured near address $',0
0000801D= 0A 0D 53 54 4F 50 ...    892  tvmsg:   dc.b   10,13,'STOP: TRAPV exception occured near address $',0
0000804C= 0A 0D 53 54 4F 50 ...    893  uimsg:   dc.b   10,13,'STOP: Uninitialised Interrupt exception occured near address $',0
0000808D= 0A 0D 53 54 4F 50 ...    894  usermsg: dc.b   10,13,'STOP: User exception occured near address $',0
000080BB= 0A 0D 53 54 4F 50 ...    895  zdmsg:   dc.b   10,13,'STOP: Divide By Zero error occured near address $',0
000080EF                           896  
000080EF                           897  * #############################################################################
000080EF                           898  * #############################################################################
000080EF                           899  * C O L D   S T A R T - This is the main entry point into the monitor
000080EF                           900  * #############################################################################
000080EF                           901  * #############################################################################
000080EF                           902  
000080F0                           903      ORG     (*+1)&-2    * make sure we start on a word aligned address
000080F0                           904  START:
000080F0  4FF9 001FF800            905      lea     STACK_START, sp     * Set the stack pointer just in case
000080F6                           906  
000080F6  46FC 2700                907      move.w  #$2700,sr               * mask off all interrupts
000080FA  31FC 0FFF 00F2           908      move.w  #(M302_BASE_ADDR>>12),M302_BAR          * 68302 BAR points to 0xFFFxxx
00008100                           909  
00008100                           910      * setup the MC68302 chip select #0 for the whole 128K of ROM
00008100  33FC FFC0 00FFF832       911      move.w  #(CS0_OR|$E000),M302_OR0     * external DTACK
00008108  33FC 0001 00FFF830       912      move.w  #(CS0_BR|$0001),M302_BR0
00008110                           913  
00008110                           914      * setup the MC68302 chip select #1 so 1M of RAM can be used
00008110  33FC FE00 00FFF836       915      move.w  #(CS1_OR|$E000),M302_OR1     * external DTACK
00008118  33FC 0201 00FFF834       916      move.w  #(CS1_BR|$0001),M302_BR1
00008120                           917  
00008120                           918      * setup the MC68302 chip select #2 for 128K of RCBus
00008120  33FC 5FC0 00FFF83A       919      move.w  #(CS2_OR|$4000),M302_OR2     * DTACK after 2 wait states
00008128  33FC 1F81 00FFF838       920      move.w  #(CS2_BR|$0001),M302_BR2
00008130                           921  
00008130                           922      * RAM should now be available
00008130  33FC 0040 00FFF812       923      move.w  #$40,M302_GIMR              * normal mode, vectors at 40-5F
00008138  33FC 0000 00FFF816       924      move.w  #0,M302_IMR                 * no interrupts
00008140  33FC FFFF 00FFF814       925      move.w  #$FFFF,M302_IPR             * clear pending interrupts
00008148  33FC FFFF 00FFF818       926      move.w  #$FFFF,M302_ISR             * clear in-service
00008150                           927  
00008150                           928      * copy the exception vector table into RAM
00008150  207C 000072F0            929      move.l  #rom2ramIVT,a0      * start of exception table in ROM
00008156  227C 00100000            930      move.l  #VEC_BASE,a1        * location in RAM to copy table to
0000815C  203C 000000FF            931      move.l  #255,d0             * 256 entries to copy
00008162                           932  .copy:
00008162  22D8                     933      move.l  (a0)+,(a1)+     * copy the byte from ROM to RAM
00008164  51C8 FFFC                934      dbra    d0,.copy
00008168                           935  
00008168                           936      * configure SCC1
00008168  6100 055A                937      bsr     SCC1Init
0000816C                           938  
0000816C                           939  *------------------------------------------------------------------------------
0000816C                           940  * Warm Restart entry point
0000816C                           941  *------------------------------------------------------------------------------
0000816C                           942  monStart:
0000816C  41FA 076C                943      lea     strBanner1(PC), a0  * Show the monitor details
00008170  6100 0676                944      bsr.w   putString
00008174                           945  
00008174  41FA 07C2                946      lea     strCommands(PC), a0 * And the command help message
00008178  6100 066E                947      bsr.w   putString
0000817C                           948  
0000817C                           949  monLoop:
0000817C  41FA 0961                950      lea     strPrompt(PC), a0   * Prompt
00008180  6100 0666                951      bsr.w   putString
00008184                           952  
00008184                           953  monLoop_NP:
00008184  6100 06CA                954      bsr.w   getCh           * get a character into D0
00008188  6100 0344                955      bsr.w   chToUpper       * convert character to upper case
0000818C                           956      
0000818C  0C00 000A                957      cmpi.b  #ASCII_LF,d0            * ignore Line-Feed
00008190  67EA                     958      beq.s   monLoop
00008192                           959      
00008192  B03C 0042                960      cmp.b   #'B', d0        * Boot EhBASIC v3.54
00008196  6700 005E                961      beq.w   cmdBootEHBASIC
0000819A                           962  
0000819A  B03C 0043                963      cmp.b   #'C', d0        * Boot CP/M-68K
0000819E  6700 007E                964      beq.w   cmdBootCPM
000081A2                           965  
000081A2  B03C 0044                966      cmp.b   #'D', d0        * Dump memory command
000081A6  6700 00B0                967      beq.w   cmdDispMemory
000081AA                           968  
000081AA  B03C 0049                969      cmp.b   #'I', d0        * Read from I/O space address
000081AE  6700 00F2                970      beq.w   cmdIORead
000081B2                           971  
000081B2  B03C 004D                972      cmp.b   #'M', d0        * Modify memory command
000081B6  6700 012C                973      beq.w   cmdModifyMemory
000081BA                           974  
000081BA  B03C 004F                975      cmp.b   #'O', d0        * Write to I/O space address
000081BE  6700 0182                976      beq.w   cmdIOWrite
000081C2                           977  
000081C2  B03C 0053                978      cmp.b   #'S', d0        * S record download
000081C6  6700 01C4                979      beq.w   cmdDownload
000081CA                           980  
000081CA  B03C 0047                981      cmp.b   #'G', d0        * Go command
000081CE  6700 00AA                982      beq.w   cmdRun
000081D2                           983  
000081D2  B03C 003F                984      cmp.b   #'?', d0        * Help command
000081D6  6700 0284                985      beq.w   cmdHelp
000081DA                           986  
000081DA  B03C 0020                987      cmp.b   #' ', d0        * Ignore spaces
000081DE  6FA4                     988      ble.s   monLoop_NP      * go back without printing prompt    
000081E0                           989  
000081E0  1200                     990      move.b  d0,d1           * save the unknown char
000081E2  41FA 08FE                991      lea     strUnkCmd(PC), a0   * unknown command
000081E6  6100 0600                992      bsr.w   putString
000081EA  1001                     993      move.b  d1,d0           * get unnknown char back
000081EC  6100 05D4                994      bsr.w   writeByte       * print it
000081F0                           995      
000081F0                           996  monLoop_CRLF:
000081F0  6100 05F2                997      bsr.w   putCRLF
000081F4  6086                     998      bra.s   monLoop
000081F6                           999      
000081F6                          1000  *------------------------------------------------------------------------------
000081F6                          1001  * (B) Boot EhBASIC v3.54
000081F6                          1002  *------------------------------------------------------------------------------
000081F6                          1003  cmdBootEHBASIC:
000081F6                          1004      * perform a simple check to see if EhBASIC has been programmed into the
000081F6                          1005      * EEPROM by reading address 0x9000 in the EEPROM. If it contains 0xFFFF,
000081F6                          1006      * then EhBASIC hasn't been programmed in!
000081F6  0C79 FFFF 00009000      1007      cmpi.w  #$FFFF,EHBASIC_BASE
000081FE  660C                    1008      bne.s   .bootEHBASIC
00008200  41FA 0A12               1009      lea     strBASICErr1(PC), a0
00008204  6100 05E2               1010      bsr.w   putString
00008208  6000 FF72               1011      bra.w   monLoop
0000820C                          1012  
0000820C                          1013  .bootEHBASIC:
0000820C  207C 00009000           1014      move.l  #EHBASIC_BASE,a0
00008212  4E90                    1015      jsr     (a0)            * jump to EhBASIC 
00008214                          1016  
00008214                          1017      * I don't think EhBASIC can return back to the monitor but just in case it can
00008214                          1018      * print out a message and wait for a reset.
00008214  41FA 0A34               1019      lea     strBASICReturn(PC), a0
00008218  6100 05CE               1020      bsr.w   putString
0000821C                          1021  .forever:
0000821C  60FE                    1022      bra.s   .forever
0000821E                          1023  
0000821E                          1024  *------------------------------------------------------------------------------
0000821E                          1025  * (C) Boot CP/M-68K v1.3
0000821E                          1026  *------------------------------------------------------------------------------
0000821E                          1027  cmdBootCPM:
0000821E                          1028      * perform a simple check to see if CP/M has been programmed into the EEPROM
0000821E                          1029      * by reading address 0x0400 in the EEPROM. If it contains 0xFFFF then CP/M
0000821E                          1030      * hasn't been programmed in!
0000821E  0C78 FFFF 0400          1031      cmpi.w  #$FFFF,CPM_BASE
00008224  660C                    1032      bne.s   .chkBIOS
00008226  41FA 093D               1033      lea     strCPMErr1(PC), a0
0000822A  6100 05BC               1034      bsr.w   putString
0000822E  6000 FF4C               1035      bra.w   monLoop
00008232                          1036      
00008232                          1037  .chkBIOS:   
00008232                          1038      * perform a simple check to see if the BIOS has been programmed into the EEPROM
00008232                          1039      * by reading address 0x0400 in the EEPROM. If it contains 0xFFFF then the CP/M
00008232                          1040      * BIOS hasn't been programmed in!
00008232  0C78 FFFF 6000          1041      cmpi.w  #$FFFF,$6000
00008238  660C                    1042      bne.s   .bootCPM
0000823A  41FA 0961               1043      lea     strCPMErr2(PC), a0
0000823E  6100 05A8               1044      bsr.w   putString
00008242  6000 FF38               1045      bra.w   monLoop
00008246                          1046      
00008246                          1047  .bootCPM:
00008246  207C 00000400           1048      move.l  #CPM_BASE,a0
0000824C  4E90                    1049      jsr     (a0)            * jump to CP/M-68K 
0000824E                          1050      
0000824E                          1051      * I don't think CP/M-68K can return back to the monitor but just in case it can
0000824E                          1052      * print out a message and wait for a reset.
0000824E  41FA 098A               1053      lea     strCPMReturn(PC), a0
00008252  6100 0594               1054      bsr.w   putString
00008256                          1055  .forever:
00008256  60FE                    1056      bra.s   .forever
00008258                          1057      
00008258                          1058  *------------------------------------------------------------------------------
00008258                          1059  * (D)ump memory
00008258                          1060  * Display 256 bytes of memory as ASCII-HEX characters
00008258                          1061  *------------------------------------------------------------------------------
00008258                          1062  cmdDispMemory:
00008258  6100 05D4               1063      bsr.w   putCh           * echo back the command character in D0
0000825C  103C 0020               1064      move.b  #' ',d0
00008260  6100 05CC               1065      bsr.w   putCh
00008264                          1066      
00008264  4282                    1067      clr.l   d2              * pre-set D2 to 0
00008266  7208                    1068      move.l  #8,d1           * read up to 8 digits
00008268  6100 02C2               1069      bsr.w   hexToIntEcho    * from the serial port into D0
0000826C  6500 FF0E               1070      bcs.w   monLoop         * back to prompt if there's an error
00008270                          1071      
00008270  2040                    1072      move.l  d0,a0           * A0 holds the start address
00008272  6100 01F4               1073      bsr.w   dumpRAM
00008276                          1074  
00008276  6000 FF04               1075      bra.w   monLoop
0000827A                          1076  
0000827A                          1077  *------------------------------------------------------------------------------
0000827A                          1078  * (G)o - execute code in memory starting at the specified address
0000827A                          1079  *------------------------------------------------------------------------------
0000827A                          1080  cmdRun:
0000827A  6100 05B2               1081      bsr.w   putCh           * echo back the command character in D0
0000827E  103C 0020               1082      move.b  #' ',d0
00008282  6100 05AA               1083      bsr.w   putCh
00008286                          1084  
00008286  4282                    1085      clr.l   d2              * pre-set D2 to 0
00008288  7208                    1086      move.l  #8,d1           * read up to 8 digits
0000828A  6100 02A0               1087      bsr.w   hexToIntEcho    * from the serial port
0000828E  6500 FEEC               1088      bcs.w   monLoop         * back to prompt if there's an error
00008292                          1089  
00008292  2040                    1090      move.l  d0, a0          * copy start address into A0
00008294  4E90                    1091      jsr     (a0)            * jump to user code
00008296                          1092      
00008296  41FA 0879               1093      lea     strUserReturn(PC),a0
0000829A  6100 054C               1094      bsr.w   putString
0000829E                          1095      
0000829E  6000 FEDC               1096      bra.w   monLoop
000082A2                          1097  
000082A2                          1098  *------------------------------------------------------------------------------
000082A2                          1099  * (I)nput a byte from I/O space address
000082A2                          1100  *------------------------------------------------------------------------------
000082A2                          1101  cmdIORead:
000082A2  6100 058A               1102      bsr.w   putCh           * echo back the command character in D0
000082A6  103C 0020               1103      move.b  #' ',d0
000082AA  6100 0582               1104      bsr.w   putCh
000082AE                          1105  
000082AE  4282                    1106      clr.l   d2              * pre-set D2 to 0
000082B0  7202                    1107      move.l  #2,d1           * read up to 2 digit address
000082B2  6100 0278               1108      bsr.w   hexToIntEcho    * from the serial port
000082B6  6500 FEC4               1109      bcs.w   monLoop         * back to prompt if there's an error
000082BA  1600                    1110      move.b  d0,d3           * save the typed in 8-bit address
000082BC  103C 003D               1111      move.b  #'=',d0
000082C0  6100 056C               1112      bsr.w   putCh           * send an EQUALS
000082C4                          1113  
000082C4                          1114      ; D3 = 8-bit address
000082C4  207C 00FD0000           1115      movea.l #IO_BASE,a0
000082CA  0283 000000FF           1116      andi.l  #$FF,d3         * clear all the unused bits
000082D0  E383                    1117      asl.l   #1,d3           * make it a word offset
000082D2  5283                    1118      addi.l  #1,d3           * make it an odd address to read from D0..D7
000082D4  1030 3000               1119      move.b  (0,a0,d3),d0    * and read the new value in
000082D8  6100 04E8               1120      bsr.w   writeByte       * display the value
000082DC  6100 0506               1121      bsr.w   putCRLF
000082E0  6000 FE9A               1122      bra.w   monLoop
000082E4                          1123  
000082E4                          1124  *------------------------------------------------------------------------------
000082E4                          1125  * (M)odify memory
000082E4                          1126  * Change memory contents 1 byte at a time
000082E4                          1127  *------------------------------------------------------------------------------
000082E4                          1128  cmdModifyMemory:
000082E4  6100 0548               1129      bsr.w   putCh           * echo back the command character in D0
000082E8  103C 0020               1130      move.b  #' ',d0
000082EC  6100 0540               1131      bsr.w   putCh
000082F0                          1132  
000082F0  4282                    1133      clr.l   d2              * pre-set D2 to 0
000082F2  7208                    1134      move.l  #8,d1           * read up to 8 digits
000082F4  6100 0236               1135      bsr.w   hexToIntEcho    * from the serial port
000082F8  6500 FE82               1136      bcs.w   monLoop         * back to prompt if there's an error
000082FC  1200                    1137      move.b  d0,d1           * save the typed in address
000082FE  6100 04E4               1138      bsr.w   putCRLF
00008302  1001                    1139      move.b  d1,d0           * restore the typed in address
00008304                          1140      
00008304  2040                    1141      move.l  d0,a0           * copy address into A0
00008306                          1142  .cMM_1:
00008306  6100 049C               1143      bsr.w   writeAddr32     * display the memory location address
0000830A  103C 0020               1144      move.b  #' ',d0
0000830E  6100 051E               1145      bsr.w   putCh
00008312  1010                    1146      move.b  (a0),d0         * get the current memory contents
00008314  1400                    1147      move.b  d0,d2           * pre-set D2 to the existing memory value
00008316  6100 04AA               1148      bsr.w   writeByte       * display the byte
0000831A  103C 0020               1149      move.b  #' ',d0
0000831E  6100 050E               1150      bsr.w   putCh
00008322  7202                    1151      move.l  #2,d1           * read up to 2 digits
00008324  6100 0206               1152      bsr.w   hexToIntEcho    * from the serial port
00008328  6500 0010               1153      bcs.w   .cMM_2          * back to prompt if there's an error
0000832C                          1154  
0000832C  10C0                    1155      move.b  d0,(a0)+        * write out the new byte and move on
0000832E  2F08                    1156      move.l  a0,-(SP)        * save our address
00008330  6100 04B2               1157      bsr.w   putCRLF
00008334  205F                    1158      move.l  (SP)+,a0        * restore our address
00008336  2008                    1159      move.l  a0,d0           * copy address back into D0 for printing
00008338  60CC                    1160      bra.s   .cMM_1
0000833A                          1161  
0000833A                          1162  .cMM_2:
0000833A  6100 04A8               1163      bsr.w   putCRLF
0000833E  6000 FE3C               1164      bra.w   monLoop
00008342                          1165      
00008342                          1166  *------------------------------------------------------------------------------
00008342                          1167  * (O)utput a byte to I/O space address
00008342                          1168  *------------------------------------------------------------------------------
00008342                          1169  cmdIOWrite:
00008342  6100 04EA               1170      bsr.w   putCh           * echo back the command character in D0
00008346  103C 0020               1171      move.b  #' ',d0
0000834A  6100 04E2               1172      bsr.w   putCh
0000834E                          1173  
0000834E  4282                    1174      clr.l   d2              * pre-set D2 to 0
00008350  7202                    1175      move.l  #2,d1           * read up to 2 digit address
00008352  6100 01D8               1176      bsr.w   hexToIntEcho    * from the serial port
00008356  6500 FE24               1177      bcs.w   monLoop         * back to prompt if there's an error
0000835A  1600                    1178      move.b  d0,d3           * save the typed in 8-bit address
0000835C  103C 003D               1179      move.b  #'=',d0
00008360  6100 04CC               1180      bsr.w   putCh           * send an EQUALS
00008364                          1181  
00008364  4282                    1182      clr.l   d2              * pre-set D2 to 0
00008366  7202                    1183      move.l  #2,d1           * read up to 2 digit value
00008368  6100 01C2               1184      bsr.w   hexToIntEcho    * from the serial port
0000836C  6500 FE0E               1185      bcs.w   monLoop         * back to prompt if there's an error
00008370                          1186  
00008370                          1187      ; D0 = value and D3 = 8-bit address
00008370  207C 00FD0000           1188      movea.l #IO_BASE,a0
00008376  0283 000000FF           1189      andi.l  #$FF,d3         * clear all the unused bits
0000837C  E383                    1190      asl.l   #1,d3           * make it a word offset
0000837E  5283                    1191      addi.l  #1,d3           * make it an odd address to write to D0..D7
00008380  1180 3000               1192      move.b  d0,(0,a0,d3)    * and write the new value out
00008384                          1193  
00008384  6100 045E               1194      bsr.w   putCRLF
00008388  6000 FDF2               1195      bra.w   monLoop
0000838C                          1196  
0000838C                          1197  *------------------------------------------------------------------------------
0000838C                          1198  * (S) - download a single line of a Motorola S-Record
0000838C                          1199  * A0 points to the SCC rx buffer holding the record inc the 'S' char
0000838C                          1200  * A2 points to the SCC rx buffer descriptor flags register
0000838C                          1201  *------------------------------------------------------------------------------
0000838C                          1202  cmdDownload:
0000838C                          1203  *------------------------------------------------------------------------------
0000838C                          1204  * Decode a single s-record that is held in one of the rx buffers and write it
0000838C                          1205  * directly to RAM.
0000838C                          1206  * A0 points to the rx buffer holding the record inc the 'S'
0000838C                          1207  * D0 = 0 if checksum OK or -1 if any error
0000838C                          1208  * Uses:
0000838C                          1209  *  D3 - running checksum
0000838C                          1210  
0000838C                          1211  ; Uses: D0,D3,D4,A0,A1
0000838C                          1212  *------------------------------------------------------------------------------
0000838C                          1213  decodeSRec:
0000838C  4283                    1214      clr.l   d3              * running checksum sum = 0
0000838E  5288                    1215      addq.l  #1, a0          * skip over 'S'
00008390                          1216  
00008390  1018                    1217      move.b  (a0)+, d0       * get s-record type
00008392  0400 0030               1218      sub.b   #'0', d0
00008396  13C0 001FF820           1219      move.b  d0, srecType
0000839C                          1220  
0000839C  6100 01CC               1221      bsr     readHexByte     * read byte count
000083A0  13C0 001FF821           1222      move.b  d0, srecByteCnt
000083A6  D600                    1223      add.b   d0, d3          * add byte count to checksum
000083A8                          1224  
000083A8                          1225      * Decode address based on record type
000083A8  4284                    1226      clr.l   d4              * D4 holds destination address
000083AA  0C39 0001 001FF820      1227      cmp.b   #1, srecType
000083B2  6738                    1228      beq.s   .addr2bytes
000083B4  0C39 0002 001FF820      1229      cmp.b   #2, srecType
000083BC  671E                    1230      beq.s   .addr3bytes
000083BE  0C39 0003 001FF820      1231      cmp.b   #3, srecType
000083C6  6704                    1232      beq.s   .addr4bytes
000083C8  6000 007E               1233      bra    .ignore
000083CC                          1234  
000083CC                          1235  .addr4Bytes:
000083CC  6100 019C               1236      bsr     readHexByte
000083D0  D600                    1237      add.b   d0, d3          * update checksum
000083D2  1800                    1238      move.b  d0, d4          * addr bits 24..31
000083D4  E18C                    1239      lsl.l   #8, d4          * shift ready for next byte
000083D6  5339 001FF821           1240      subi.b  #1, srecByteCnt * decrement byte count
000083DC                          1241      
000083DC                          1242  .addr3Bytes:
000083DC  6100 018C               1243      bsr     readHexByte
000083E0  D600                    1244      add.b   d0, d3          * update checksum
000083E2  1800                    1245      move.b  d0, d4          * addr bits 16..23
000083E4  E18C                    1246      lsl.l   #8, d4          * shift ready for next byte
000083E6  5339 001FF821           1247      subi.b  #1, srecByteCnt * decrement byte count
000083EC                          1248  
000083EC                          1249  .addr2Bytes:
000083EC  6100 017C               1250      bsr     readHexByte
000083F0  D600                    1251      add.b   d0, d3          * update checksum
000083F2  1800                    1252      move.b  d0, d4          * addr bits 8..15
000083F4  E18C                    1253      lsl.l   #8, d4          * shift ready for next byte
000083F6  6100 0172               1254      bsr     readHexByte
000083FA  D600                    1255      add.b   d0, d3          * update checksum
000083FC  1800                    1256      move.b  d0, d4          * addr bits 0..7
000083FE  5739 001FF821           1257      subi.b  #3, srecByteCnt * decrement byte count by 2 (+1 for csum)
00008404                          1258  
00008404                          1259      * D4 now holds the destination address
00008404  2244                    1260      move.l  d4, a1          * A1 = target address to store data
00008406  1839 001FF821           1261      move.b  srecByteCnt, d4 * D4 = no of data bytes to read in
0000840C                          1262  
0000840C                          1263      * Read data bytes and store at (A1)
0000840C                          1264  .rdLoop:
0000840C  4A04                    1265      tst.b   d4              * have we done yet?
0000840E  670C                    1266      beq.s   .rdChecksum
00008410  6100 0158               1267      bsr     readHexByte
00008414  D600                    1268      add.b   d0, d3          * update checksum
00008416  12C0                    1269      move.b  d0, (a1)+       * write byte to memory
00008418  5304                    1270      subq.b  #1, d4          * decrement byte count
0000841A  60F0                    1271      bra.s   .rdLoop
0000841C                          1272  
0000841C                          1273  .rdChecksum:
0000841C  6100 014C               1274      bsr     readHexByte     * D0 = checksum byte
00008420  D600                    1275      add.b   d0, d3          * final sum
00008422  0C03 00FF               1276      cmpi.b  #$ff, d3        * all good if D3 = $FF
00008426  6710                    1277      beq.s   .ok
00008428                          1278  .fail:
00008428  0052 8000               1279      ori.w   #$8000,(A2)     * signal buffer is free
0000842C  103C 0058               1280      move.b  #'X', d0        * checksum fail - print an X
00008430  6100 03FC               1281      bsr     putCh
00008434  6000 FD4E               1282      bra.w   monLoop_NP      * return to main loop without prompt
00008438                          1283  .ok:
00008438  0052 8000               1284      ori.w   #$8000,(A2)     * signal buffer is free
0000843C  103C 002E               1285      move.b  #'.', d0        * checksum good - print a dot
00008440  6100 03EC               1286      bsr     putCh
00008444  6000 FD3E               1287      bra.w   monLoop_NP      * return to main loop without prompt
00008448                          1288  .ignore:
00008448  0052 8000               1289      ori.w   #$8000,(A2)     * signal buffer is free
0000844C  103C 003F               1290      move.b  #'?', d0        * unsupported record type - question mark
00008450  6100 03DC               1291      bsr     putCh
00008454  6100 038E               1292      bsr.w   putCRLF
00008458  6000 FD22               1293      bra.w   monLoop
0000845C                          1294  
0000845C                          1295  *------------------------------------------------------------------------------
0000845C                          1296  * Display the supported commands
0000845C                          1297  *------------------------------------------------------------------------------
0000845C                          1298  cmdHelp:
0000845C  41FA 04DA               1299      lea     strCommands(PC), a0
00008460  6100 0386               1300      bsr.w   putString
00008464  6000 FD16               1301      bra.w   monLoop
00008468                          1302  
00008468                          1303  *------------------------------------------------------------------------------
00008468                          1304  * Dumps a 256 section of RAM to the screen
00008468                          1305  * Displays both hex values and ASCII characters
00008468                          1306  * a0 - Start Address
00008468                          1307  *------------------------------------------------------------------------------
00008468                          1308  dumpRAM:
00008468  48E7 E040               1309      movem.l d0-d2/a1, -(SP) * Save registers
0000846C  2248                    1310      move.l  a0,a1           * move the start address to A1
0000846E                          1311  
0000846E  6100 0374               1312      bsr.w   putCRLF         * new line - trashes D0 & A0
00008472                          1313      
00008472  323C 000F               1314      move.w  #15,d1          * 16 rows of data (DBRA needs 1 less!)
00008476                          1315  .dr_1:
00008476  343C 000F               1316      move.w  #15,d2          * 16 bytes of data per row (DBRA needs 1 less!)
0000847A  2009                    1317      move.l  a1, d0          * copy the start address of the line into D0          
0000847C  6100 0326               1318      bsr.w   writeAddr32     * Display as a 32-bit hex value
00008480  41FA 0675               1319      lea     strColonSpace(PC), a0
00008484  6100 0362               1320      bsr.w   putString
00008488  41F9 001FF800           1321      lea     msgASCIIDump, a0
0000848E                          1322  .dr_2:
0000848E  1019                    1323      move.b  (a1)+, d0       * Read a byte from RAM
00008490  6100 0330               1324      bsr.w   writeByte       * display byte as 2 hex digits  
00008494  6100 004A               1325      bsr.w   makePrintable   * convert to printable character
00008498  10C0                    1326      move.b  d0,(a0)+        * save the printable char in output string
0000849A  103C 0020               1327      move.b  #' ', d0
0000849E  6100 038E               1328      bsr.w   putCh           * insert a space
000084A2  51CA FFEA               1329      dbra    d2,.dr_2
000084A6                          1330  
000084A6  103C 0020               1331      move.b  #' ', d0
000084AA  6100 0382               1332      bsr.w   putCh           * insert a space
000084AE                          1333  
000084AE  10FC 000D               1334      move.b  #ASCII_CR,(a0)+
000084B2  10FC 000A               1335      move.b  #ASCII_LF,(a0)+
000084B6  10FC 0000               1336      move.b  #0,(a0)+
000084BA  41F9 001FF800           1337      lea     msgASCIIDump, a0
000084C0  6100 0326               1338      bsr.w   putString       * print out the printable bytes
000084C4  51C9 FFB0               1339      dbra    d1,.dr_1
000084C8                          1340  
000084C8  4CDF 0207               1341      movem.l (SP)+, d0-d2/a1 * Restore registers
000084CC  4E75                    1342      rts
000084CE                          1343              
000084CE                          1344  *------------------------------------------------------------------------------
000084CE                          1345  * Convert character in D0 to upper case
000084CE                          1346  * Only changes D0 if char is between 'a'..'z'
000084CE                          1347  *------------------------------------------------------------------------------
000084CE                          1348  chToUpper:
000084CE  B03C 0061               1349      cmp.b   #'a', d0         
000084D2  6D0A                    1350      blt.s   .done            * less than lower-case 'a' so leave alone
000084D4  B03C 007A               1351      cmp.b   #'z', d0
000084D8  6E04                    1352      bgt.s   .done            * greater than lower-case 'z' so leave alone
000084DA  0400 0020               1353      sub.b   #$20, d0         * convert to upper case
000084DE                          1354  .done:
000084DE  4E75                    1355      rts
000084E0                          1356      
000084E0                          1357  *------------------------------------------------------------------------------
000084E0                          1358  * Convert a byte into a print safe character
000084E0                          1359  * Substitute a '.' for any byte <32 or >126
000084E0                          1360  * D0 holds the byte
000084E0                          1361  *------------------------------------------------------------------------------
000084E0                          1362  makePrintable:
000084E0  B03C 0020               1363      cmp.b   #' ', d0         
000084E4  6D06                    1364      blt.s   .mp_1           * less than a SPACE (char 32)
000084E6                          1365  
000084E6  B03C 007E               1366      cmp.b   #'~', d0         
000084EA  6F04                    1367      ble.s   .mp_x           * less than a DEL (char 127)
000084EC                          1368  
000084EC                          1369  .mp_1:
000084EC  103C 002E               1370      move.b  #'.',d0         * substitute a DOT (char 46)
000084F0                          1371  .mp_x:
000084F0  4E75                    1372      rts
000084F2                          1373      
000084F2                          1374  *--------------------------------------------------------------------------
000084F2                          1375  * Read in an ASCII-HEX number - no echo back
000084F2                          1376  *
000084F2                          1377  * D2 = Value to return if no digits read in
000084F2                          1378  * D1 = Max no of ASCII digits to read in
000084F2                          1379  * D0 = Result
000084F2                          1380  * Carry flag set if an error occurs / not ASCII-HEX digit
000084F2                          1381  *--------------------------------------------------------------------------
000084F2                          1382  hexToInt:
000084F2                          1383  *   move.l  d2,-(SP)        * save D2
000084F2                          1384  *   clr.l   d2              * D2 used to accumulate the final value
000084F2                          1385  .h2i_1:
000084F2  6100 035C               1386      bsr.w   getCh           * get a character
000084F6  61D6                    1387      bsr.s   chToUpper       * convert to upper case if needed
000084F8                          1388  
000084F8  0C00 000A               1389      cmpi.b  #10,d0          * finish if it's CR or LF
000084FC  6724                    1390      beq.s   .h2i_x
000084FE  0C00 000D               1391      cmpi.b  #13,d0
00008502  671E                    1392      beq.s   .h2i_x
00008504                          1393      
00008504  0400 0030               1394      subi.b  #'0',d0
00008508  6B1C                    1395      bmi.s   .h2i_err        * quit if char is less than '0'
0000850A                          1396  
0000850A  0C00 0009               1397      cmpi.b  #9,d0
0000850E  6F0A                    1398      ble.s   .h2i_2          * is it <= 9
00008510                          1399      
00008510  5F00                    1400      subi.b  #7,d0
00008512  6B12                    1401      bmi.s   .h2i_err        * quit if char is >'9' and <'A'
00008514                          1402  
00008514  0C00 000F               1403      cmpi.b  #15,d0
00008518  6E0C                    1404      bgt.s   .h2i_err        * quit if char is >'F'
0000851A                          1405  
0000851A                          1406  .h2i_2:
0000851A  E98A                    1407      lsl.l   #4, d2
0000851C  8400                    1408      or.b    d0, d2          * insert the new digit
0000851E                          1409  
0000851E  5301                    1410      subq.b  #1, d1          * decrement the digit count
00008520  66D0                    1411      bne.s   .h2i_1          * go back for another digit?
00008522                          1412  
00008522                          1413  .h2i_x:
00008522  2002                    1414      move.l  d2,d0           * put the answer back into D0
00008524                          1415  *   move.l  (SP)+,d2        * restore D2
00008524  4E75                    1416      rts
00008526                          1417  
00008526                          1418  .h2i_err:
00008526                          1419  *   move.l  (SP)+,d2        * restore D2
00008526  003C 0001               1420      ori.b   #1,CCR          * set the CARRY flag to signal an error
0000852A  4E75                    1421      rts
0000852C                          1422  
0000852C                          1423  *--------------------------------------------------------------------------
0000852C                          1424  * Read in an ASCII-HEX number with echo back
0000852C                          1425  *
0000852C                          1426  * D2 = Value to return if no digits read in
0000852C                          1427  * D1 = Max no of ASCII digits to read in
0000852C                          1428  * D0 = Result
0000852C                          1429  * Carry flag set if an error occurs / not ASCII-HEX digit
0000852C                          1430  *--------------------------------------------------------------------------
0000852C                          1431  hexToIntEcho:
0000852C                          1432  *   move.l  d2,-(SP)        * save D2
0000852C                          1433  *   clr.l   d2              * D2 used to accumulate the final value
0000852C                          1434  .h2i_1:
0000852C  6100 0322               1435      bsr.w   getCh           * get a character
00008530  6100 02FC               1436      bsr.w   putCh           * echo it back
00008534  6198                    1437      bsr.s   chToUpper       * convert to upper case if needed
00008536                          1438  
00008536  0C00 000A               1439      cmpi.b  #10,d0          * finish if it's CR or LF
0000853A  6724                    1440      beq.s   .h2i_x
0000853C  0C00 000D               1441      cmpi.b  #13,d0
00008540  671E                    1442      beq.s   .h2i_x
00008542                          1443      
00008542  0400 0030               1444      subi.b  #'0',d0
00008546  6B1C                    1445      bmi.s   .h2i_err        * quit if char is less than '0'
00008548                          1446  
00008548  0C00 0009               1447      cmpi.b  #9,d0
0000854C  6F0A                    1448      ble.s   .h2i_2          * is it <= 9
0000854E                          1449      
0000854E  5F00                    1450      subi.b  #7,d0
00008550  6B12                    1451      bmi.s   .h2i_err        * quit if char is >'9' and <'A'
00008552                          1452  
00008552  0C00 000F               1453      cmpi.b  #15,d0
00008556  6E0C                    1454      bgt.s   .h2i_err        * quit if char is >'F'
00008558                          1455  
00008558                          1456  .h2i_2:
00008558  E98A                    1457      lsl.l   #4, d2
0000855A  8400                    1458      or.b    d0, d2          * insert the new digit
0000855C                          1459  
0000855C  5301                    1460      subq.b  #1, d1          * decrement the digit count
0000855E  66CC                    1461      bne.s   .h2i_1          * go back for another digit?
00008560                          1462  
00008560                          1463  .h2i_x:
00008560  2002                    1464      move.l  d2,d0           * put the answer back into D0
00008562                          1465  *   move.l  (SP)+,d2        * restore D2
00008562  4E75                    1466      rts
00008564                          1467  
00008564                          1468  .h2i_err:
00008564                          1469  *   move.l  (SP)+,d2        * restore D2
00008564  003C 0001               1470      ori.b   #1,CCR          * set the CARRY flag to signal an error
00008568  4E75                    1471      rts
0000856A                          1472  
0000856A                          1473  *------------------------------------------------------------------------------
0000856A                          1474  * ReadHexByte - read two ASCII hex chars at (A0)+
0000856A                          1475  * Uses: D1
0000856A                          1476  * Ret:  D0 = binary byte
0000856A                          1477  *------------------------------------------------------------------------------
0000856A                          1478  ReadHexByte:
0000856A  1218                    1479      move.b  (a0)+, d1
0000856C  6100 0010               1480      bsr     HexCharToNibble
00008570  E148                    1481      lsl.w   #8, d0          * save nibble in bits 8..11
00008572  1218                    1482      move.b  (a0)+, d1
00008574  6100 0008               1483      bsr     HexCharToNibble
00008578  E908                    1484      lsl.b   #4, d0          * shift nibble into bits 4..7
0000857A  E848                    1485      lsr.w   #4, d0          * shift whole byte into bits 0..7
0000857C  4E75                    1486      rts
0000857E                          1487  
0000857E                          1488  *------------------------------------------------------------------------------
0000857E                          1489  * HexCharToNibble - convert ASCII hex char in D1 to nibble
0000857E                          1490  * Ret:  D0 = converted char
0000857E                          1491  *------------------------------------------------------------------------------
0000857E                          1492  HexCharToNibble:
0000857E  1001                    1493      move.b  d1, d0          * move char to D0
00008580  B03C 0030               1494      cmp.b   #'0', d0        * compare with ASCII char '0'
00008584  6D38                    1495      blt.s   .HexError       * error if it's less than '0'
00008586  B03C 0039               1496      cmp.b   #'9', d0        * compare with ASCII char '9'
0000858A  6F2C                    1497      ble.s   .IsDigit        * it's a digit if less than '9'
0000858C  B03C 0041               1498      cmp.b   #'A', d0        * compare with ASCII char 'A'
00008590  6D2C                    1499      blt.s   .HexError       * error if it's less than 'A'
00008592  B03C 0046               1500      cmp.b   #'F', d0        * compare with ASCII char 'F'
00008596  6F16                    1501      ble.s   .IsUpper        * it's between 'A' and 'F'
00008598  B03C 0061               1502      cmp.b   #'a', d0        * compare with ASCII char 'a'
0000859C  6D20                    1503      blt.s   .HexError       * error if it's less than 'a'
0000859E  B03C 0066               1504      cmp.b   #'f', d0        * compare with ASCII char 'f'
000085A2  6E1A                    1505      bgt.s   .HexError       * error if it's greater than 'f'
000085A4  0400 0061               1506      sub.b   #'a', d0
000085A8  0600 000A               1507      add.b   #10, d0
000085AC  4E75                    1508      rts
000085AE                          1509  .IsUpper:
000085AE  0400 0041               1510      sub.b   #'A', d0
000085B2  0600 000A               1511      add.b   #10, d0
000085B6  4E75                    1512      rts
000085B8                          1513  .IsDigit:
000085B8  0400 0030               1514      sub.b   #'0', d0
000085BC  4E75                    1515      rts
000085BE                          1516  .HexError:
000085BE  7000                    1517      moveq   #0, d0
000085C0  4E75                    1518      rts
000085C2                          1519  
000085C2                          1520  *==============================================================================
000085C2                          1521  *==============================================================================
000085C2                          1522  * EASy68K TRAP #15 routines
000085C2                          1523  *==============================================================================
000085C2                          1524  *==============================================================================
000085C2                          1525  
000085C2                          1526  *------------------------------------------------------------------------------
000085C2                          1527  * This is the jump table for the TRAP #15 tasks - not all tasks are supported!
000085C2                          1528  *------------------------------------------------------------------------------
000085C2                          1529  
000085C2                          1530  easy68kTaskTable:
000085C2  6000 008A               1531      bra.w   easyTask0 
000085C6  6000 009E               1532      bra.w   easyTask1 
000085CA  6000 005E               1533      bra.w   easyTask2 
000085CE  6000 005A               1534      bra.w   easyTask3 
000085D2  6000 0056               1535      bra.w   easyTask4 
000085D6  6000 00A2               1536      bra.w   easyTask5 
000085DA  6000 00A6               1537      bra.w   easyTask6 
000085DE  6000 00AA               1538      bra.w   easyTask7 
000085E2  6000 0046               1539      bra.w   easyTask8 
000085E6  6000 0042               1540      bra.w   easyTask9 
000085EA  6000 003E               1541      bra.w   easyTask10
000085EE  6000 003A               1542      bra.w   easyTask11
000085F2  6000 0036               1543      bra.w   easyTask12
000085F6  6000 0098               1544      bra.w   easyTask13
000085FA  6000 00A0               1545      bra.w   easyTask14
000085FE  6000 002A               1546      bra.w   easyTask15
00008602  6000 0026               1547      bra.w   easyTask16
00008606  6000 0022               1548      bra.w   easyTask17
0000860A  6000 001E               1549      bra.w   easyTask18
0000860E  6000 001A               1550      bra.w   easyTask19
00008612  6000 0016               1551      bra.w   easyTask20
00008616  6000 0012               1552      bra.w   easyTask21
0000861A  6000 000E               1553      bra.w   easyTask22
0000861E  6000 000A               1554      bra.w   easyTask23
00008622  6000 0006               1555      bra.w   easyTask24
00008626  6000 0002               1556      bra.w   easyTask25
0000862A                          1557  
0000862A                          1558  *------------------------------------------------------------------------------
0000862A                          1559  * These are the EASy68K tasks not yet implemented
0000862A                          1560  * The required task number is in D0
0000862A                          1561  * Display a message and stop in an endless loop.
0000862A                          1562  *------------------------------------------------------------------------------
0000862A                          1563  
0000862A                          1564  easyTask2: 
0000862A                          1565  easyTask3:
0000862A                          1566  easyTask4:
0000862A                          1567  easyTask8: 
0000862A                          1568  easyTask9: 
0000862A                          1569  easyTask10:
0000862A                          1570  easyTask11:
0000862A                          1571  easyTask12:
0000862A                          1572  easyTask15:
0000862A                          1573  easyTask16:
0000862A                          1574  easyTask17:
0000862A                          1575  easyTask18:
0000862A                          1576  easyTask19:
0000862A                          1577  easyTask20:
0000862A                          1578  easyTask21:
0000862A                          1579  easyTask22:
0000862A                          1580  easyTask23:
0000862A                          1581  easyTask24:
0000862A                          1582  easyTask25:
0000862A                          1583  easyTaskUnsupported:
0000862A  C141                    1584      exg     d0,d1           ; put the task number into D1
0000862C  41FA 04FF               1585      lea     strEasyTask1(PC), a0
00008630  6100 01B6               1586      bsr.w   putString
00008634  C141                    1587      exg     d0,d1           ; put the task number back into D0
00008636  80FC 000A               1588      divu    #10,d0          ; divide task number by 10
0000863A  6100 018E               1589      bsr.w   writeNibble     ; output the 10's digit
0000863E  4840                    1590      swap    d0
00008640  6100 0188               1591      bsr.w   writeNibble     ; output the 1's digit
00008644  41FA 0508               1592      lea     strEasyTask2(PC), a0
00008648  6100 019E               1593      bsr.w   putString
0000864C                          1594  .infloop:
0000864C  60FE                    1595      bra.s   .infloop
0000864E                          1596  
0000864E                          1597  *------------------------------------------------------------------------------
0000864E                          1598  * EASy68K TRAP #15 - Task 0
0000864E                          1599  * Display n characters of string at (A1), n is D1.W (stops on NULL or max 255) with CR, LF.
0000864E                          1600  *------------------------------------------------------------------------------
0000864E                          1601  easyTask0:
0000864E  0241 00FF               1602      andi.w  #$00FF,d1   * DBRA works on a WORD so make sure upper byte is zero
00008652  5301                    1603      sub.b   #1,d1       * DBRA requires 1 less than actual number
00008654                          1604  .loop:
00008654  1019                    1605      move.b  (a1)+, d0    * Read in character
00008656  6708                    1606      beq.s   .end         * Check for the null
00008658                          1607      
00008658  6100 01D4               1608      bsr.w   putCh        * Otherwise write the character
0000865C  51C9 FFF6               1609      dbra    d1,.loop     * And continue
00008660                          1610  .end:
00008660  6100 0182               1611      bsr.w   putCRLF     * append CR & LF
00008664  4E75                    1612      rts
00008666                          1613  
00008666                          1614  *------------------------------------------------------------------------------
00008666                          1615  * EASy68K TRAP #15 - Task 1
00008666                          1616  * Display n characters of string at (A1), n is D1.W (stops on NULL or max 255) without CR, LF.
00008666                          1617  *------------------------------------------------------------------------------
00008666                          1618  easyTask1:
00008666  0241 00FF               1619      andi.w  #$00FF,d1   * DBRA works on a WORD so make sure upper byte is zero
0000866A  5301                    1620      sub.b   #1,d1       * DBRA requires 1 less than actual number
0000866C                          1621  .loop:
0000866C  1019                    1622      move.b  (a1)+, d0    * Read in character
0000866E  6708                    1623      beq.s   .end         * Check for the null
00008670                          1624      
00008670  6100 01BC               1625      bsr.w   putCh        * Otherwise write the character
00008674  51C9 FFF6               1626      dbra    d1,.loop     * And continue
00008678                          1627  .end:
00008678  4E75                    1628      rts
0000867A                          1629  
0000867A                          1630  *------------------------------------------------------------------------------
0000867A                          1631  * EASy68K TRAP #15 - Task 5
0000867A                          1632  * Read single ASCII character from the keyboard into D1.B. 
0000867A                          1633  *------------------------------------------------------------------------------
0000867A                          1634  easyTask5:
0000867A  6100 01D4               1635      bsr.w   getCh       * wait for char - returned in D0
0000867E  1200                    1636      move.b  d0,d1       * move the char into D1
00008680  4E75                    1637      rts
00008682                          1638      
00008682                          1639  *------------------------------------------------------------------------------
00008682                          1640  * EASy68K TRAP #15 - Task 6
00008682                          1641  * Display single ASCII character in D1.B.   
00008682                          1642  *------------------------------------------------------------------------------
00008682                          1643  easyTask6:
00008682  1001                    1644      move.b  d1,d0       * move the char into D0
00008684  6100 01A8               1645      bsr.w   putCh       * output the char
00008688  4E75                    1646      rts
0000868A                          1647  
0000868A                          1648  *------------------------------------------------------------------------------
0000868A                          1649  * EASy68K TRAP #15 - Task 7
0000868A                          1650  * Check for keyboard input. Set D1.B to 1 if keyboard input is pending,
0000868A                          1651  * otherwise set to 0.
0000868A                          1652  *------------------------------------------------------------------------------
0000868A                          1653  easyTask7:
0000868A  6100 0224               1654      bsr.w   chkCh
0000868E  4E75                    1655      rts
00008690                          1656  
00008690                          1657  *------------------------------------------------------------------------------
00008690                          1658  * EASy68K TRAP #15 - Task 13
00008690                          1659  * Display the NULL terminated string at (A1) with CR, LF.
00008690                          1660  *------------------------------------------------------------------------------
00008690                          1661  easyTask13:
00008690  C149                    1662      exg     a0,a1           * A0 now holds the pointer to the string
00008692  6100 0154               1663      bsr.w   putString
00008696  6100 014C               1664      bsr.w   putCRLF         * append CR & LF
0000869A  4E75                    1665      rts
0000869C                          1666  
0000869C                          1667  *------------------------------------------------------------------------------
0000869C                          1668  * EASy68K TRAP #15 - Task 14
0000869C                          1669  * Display the NULL terminated string pointed to by (A1).
0000869C                          1670  *------------------------------------------------------------------------------
0000869C                          1671  easyTask14:
0000869C  C149                    1672      exg     a0,a1           * A0 now holds the pointer to the string
0000869E  6100 0148               1673      bsr.w   putString
000086A2  4E75                    1674      rts
000086A4                          1675  
000086A4                          1676  *------------------------------------------------------------------------------
000086A4                          1677  * This is the entry point for the TRAP #15 handler that gets called when any
000086A4                          1678  * TRAP #15 services are required. Only a few tasks are implemented.
000086A4                          1679  * Unimplemented tasks will produce an error message.
000086A4                          1680  *------------------------------------------------------------------------------
000086A4                          1681  easy68kTrap15:
000086A4  48E7 10A0               1682      movem.l d3/a0/a2,-(sp)
000086A8  45FA FF18               1683      lea     easy68kTaskTable(PC),a2
000086AC  B03C 0019               1684      cmp.b   #25,d0          ; is task number greater than 25?
000086B0  6E00 FF78               1685      bgt     easyTaskUnsupported
000086B4                          1686      
000086B4  4283                    1687      clr.l   d3
000086B6  1600                    1688      move.b  d0,d3           ; task number into D3
000086B8  E58B                    1689      lsl.l   #2,d3           ; convert task number into longword offset
000086BA  4EB2 3000               1690      jsr     (a2,d3)         ; jump to the specific task handler
000086BE                          1691      
000086BE  4CDF 0508               1692      movem.l (sp)+,d3/a0/a2
000086C2  4E73                    1693      rte
000086C4                          1694  
000086C4                          1695  *--------------------------------------------------------------------------
000086C4                          1696  * Initialise SCC1 as a UART - Section E.2 of the 68302UM
000086C4                          1697  * Uses 1 Tx buffer and 2 Rx buffers, all held in external RAM.
000086C4                          1698  * Baud rate is set by SER1_BAUD defined at the top of this file.
000086C4                          1699  * Tx and Rx buffer sizes are set by SER1_BUFSIZE defined at the top of this file.
000086C4                          1700  *
000086C4                          1701  * NOTE:
000086C4                          1702  * An Rx buffer will become ready for reading if:
000086C4                          1703  * - A special character is received
000086C4                          1704  * - Max characters received - set by value in MRBLR registers
000086C4                          1705  * - A gap between characters received greater than MAXIDL
000086C4                          1706  *--------------------------------------------------------------------------
000086C4                          1707  SCC1Init:
000086C4  33FC 00C0 00FFF8B4      1708      move.w  #$00C0,M302_SIMODE
000086CC  33FC 0016 00FFF882      1709      move.w  #(SER1_BAUD<<1),M302_SCON1  * set SCC1 baud rate
000086D4  33FC 0101 00FFF884      1710      move.w  #$0101,M302_SCM1                * set SCC1 to UART mode 8N1
000086DC                          1711  
000086DC                          1712      * TxBD0 in internal RAM
000086DC  33FC 2000 00FFF440      1713      move.w  #$2000,M302_SCC1PB+M302_TXBD0       * INT RAM - first and only tx buffer
000086E4  33FC 0000 00FFF442      1714      move.w  #$0000,M302_SCC1PB+M302_TXBD0+2 * no bytes in tx buffer
000086EC  23FC 00FFF000 00FFF444  1715      move.l  #SCC1TXB0,M302_SCC1PB+M302_TXBD0+4
000086F6                          1716  
000086F6                          1717      * RxBD0 in internal RAM
000086F6  33FC 8000 00FFF400      1718      move.w  #$8000,M302_SCC1PB+M302_RXBD0       * first rx buffer
000086FE  23FC 00FFF080 00FFF404  1719      move.l  #SCC1RXB0,M302_SCC1PB+M302_RXBD0+4
00008708                          1720  
00008708                          1721      * RxBD1 in internal RAM
00008708  33FC A000 00FFF408      1722      move.w  #$A000,M302_SCC1PB+M302_RXBD1       * second and final rx buffer
00008710  23FC 00FFF100 00FFF40C  1723      move.l  #SCC1RXB1,M302_SCC1PB+M302_RXBD1+4
0000871A                          1724  
0000871A  13FC 0020 00FFF480      1725      move.b  #$20,M302_SCC1PB+M302_RFCR
00008722  13FC 0020 00FFF481      1726      move.b  #$20,M302_SCC1PB+M302_TFCR
0000872A                          1727      
0000872A                          1728      * set the max rx buffer length to slightly less than the actual max size
0000872A  33FC 007C 00FFF482      1729      move.w  #SER1_BUFSIZE-4,M302_SCC1PB+M302_MRBLR
00008732                          1730      
00008732                          1731      * set MAXIDL to about 10mS - i.e. the time taken for 38 chars @ 38400 baud
00008732                          1732      * if another char isn't received within 10mS, then buffer will be closed 
00008732  33FC 0026 00FFF49C      1733      move.w  #38,M302_SCC1PB+M302_MAXIDL     * set MAXIDL to a small value
0000873A                          1734      
0000873A  33FC 0000 00FFF4A0      1735      move.w  #0,M302_SCC1PB+M302_BRKCR           * no BREAK characters
00008742                          1736      
00008742  33FC 0000 00FFF4A2      1737      move.w  #0,M302_SCC1PB+M302_PAREC           * reset PARITY ERROR counter
0000874A  33FC 0000 00FFF4A4      1738      move.w  #0,M302_SCC1PB+M302_FRMEC           * reset FRAME ERROR counter
00008752  33FC 0000 00FFF4A6      1739      move.w  #0,M302_SCC1PB+M302_NOSEC           * reset NOISE counter
0000875A  33FC 0000 00FFF4A8      1740      move.w  #0,M302_SCC1PB+M302_BRKEC           * reset BREAK counter
00008762                          1741      
00008762  33FC 0000 00FFF4AA      1742      move.w  #0,M302_SCC1PB+M302_UADDR1      * clear UART adress characters
0000876A  33FC 0000 00FFF4AC      1743      move.w  #0,M302_SCC1PB+M302_UADDR2
00008772                          1744  
00008772  33FC 000D 00FFF4B0      1745      move.w  #$000D,M302_SCC1PB+M302_CCHAR1  * CR is a special character
0000877A  33FC 8000 00FFF4B2      1746      move.w  #$8000,M302_SCC1PB+M302_CCHAR2  * no more special characters
00008782  33FC 0000 00FFF4BE      1747      move.w  #0,M302_SCC1PB+M302_CCHAR8
0000878A                          1748      
0000878A  13FC 00FF 00FFF888      1749      move.b  #$FF,M302_SCCE1              * clear any SCC1 events
00008792  13FC 0000 00FFF88A      1750      move.b  #0,M302_SCCM1                * no interrupts from SCC1
0000879A  0079 000C 00FFF884      1751      ori.w   #$000C,M302_SCM1                * enable SCC1 Tx & Rx
000087A2                          1752  
000087A2  4E75                    1753      rts
000087A4                          1754      
000087A4                          1755  *==============================================================================
000087A4                          1756  * These are the various printing routines that handle displaying of bytes,
000087A4                          1757  * words, long words and 24-bit values as ASCII hexadecimal text. The routines
000087A4                          1758  * must be kept in this order as program flow is meant to fall out of one
000087A4                          1759  * routine and into the next, often without a return statement.
000087A4                          1760  *==============================================================================
000087A4                          1761  
000087A4                          1762  *------------------------------------------------------------------------------
000087A4                          1763  * Output a 32-bit address as 8 ASCII hexadecimal digits
000087A4                          1764  * D0 holds the 32-bit address
000087A4                          1765  *------------------------------------------------------------------------------
000087A4                          1766  writeAddr32:
000087A4  2F00                    1767      move.l  d0,-(sp)    ; save D0 first
000087A6  E098                    1768      ror.l   #8,d0
000087A8  E098                    1769      ror.l   #8,d0
000087AA  610E                    1770      bsr.s   writeWord   ; write bits 16..31
000087AC  201F                    1771      move.l  (sp)+,d0    ; restore D0
000087AE  600A                    1772      bra.s   writeWord
000087B0                          1773      
000087B0                          1774  *------------------------------------------------------------------------------
000087B0                          1775  * Output a 24-bit address as 6 ASCII hexadecimal digits
000087B0                          1776  * D0 holds the address in bits 0..23
000087B0                          1777  * NOTE: the writeWord function must be directly after this function
000087B0                          1778  *------------------------------------------------------------------------------
000087B0                          1779  writeAddr24:
000087B0  2F00                    1780      move.l  d0,-(sp)    ; save D0 first
000087B2  E098                    1781      ror.l   #8,d0
000087B4  E098                    1782      ror.l   #8,d0
000087B6  610A                    1783      bsr.s   writeByte   ; write bits 16..23
000087B8  201F                    1784      move.l  (sp)+,d0    ; restore D0
000087BA                          1785      
000087BA                          1786  *------------------------------------------------------------------------------
000087BA                          1787  * Output a word as 4 ASCII hexadecimal digits
000087BA                          1788  * D0 holds the word in bits 0..15
000087BA                          1789  * NOTE: the writeByte function must be directly after this function
000087BA                          1790  *------------------------------------------------------------------------------
000087BA                          1791  writeWord:
000087BA  3F00                    1792      move.w  d0,-(sp)    ; save D0 first
000087BC  E058                    1793      ror.w   #8,d0       ; get upper byte (0 => shift 8 times)
000087BE  6102                    1794      bsr.s   writeByte
000087C0  301F                    1795      move.w  (sp)+,d0    ; restore D0
000087C2                          1796  
000087C2                          1797  *------------------------------------------------------------------------------
000087C2                          1798  * Output a byte as 2 ASCII hexadecimal digits
000087C2                          1799  * D0 holds the byte in bits 0..7
000087C2                          1800  * NOTE: the writeNibble function must be directly after this function
000087C2                          1801  *------------------------------------------------------------------------------
000087C2                          1802  writeByte:
000087C2  1F00                    1803      move.b  d0,-(sp)    ; save D0 first
000087C4  E818                    1804      ror.b   #4,d0       ; get upper nibble
000087C6  6102                    1805      bsr.s   writeNibble
000087C8  101F                    1806      move.b  (sp)+,d0    ; restore D0
000087CA                          1807      
000087CA                          1808  *------------------------------------------------------------------------------
000087CA                          1809  * Output 4 bits as an ASCII hexadecimal digit
000087CA                          1810  * D0 holds the nibble in bits 0..3
000087CA                          1811  *------------------------------------------------------------------------------
000087CA                          1812  writeNibble:
000087CA  1F00                    1813      move.b  d0,-(sp)    ; save D0 first
000087CC  0200 000F               1814      andi.b  #$0F,d0     ; make sure we only have the lower 4 bits
000087D0  0C00 000A               1815      cmpi.b  #10,d0      ; compare D0 to 10
000087D4  6502                    1816      bcs.b   .wn1        ; less than 10 so don't add 7
000087D6  5E00                    1817      addi.b  #07,d0      ; add 7
000087D8                          1818  .wn1:
000087D8  0600 0030               1819      addi.b  #'0',d0     ; add ASCII code for char zero
000087DC  6100 0050               1820      bsr     putCh       ; write the ASCII digit out
000087E0  101F                    1821      move.b  (sp)+,d0    ; restore D0
000087E2  4E75                    1822      rts
000087E4                          1823  
000087E4                          1824  *------------------------------------------------------------------------------
000087E4                          1825  * Prints a newline (CR, LF)
000087E4                          1826  * NOTE: the putString function must follow this function
000087E4                          1827  *------------------------------------------------------------------------------
000087E4                          1828  putCRLF:
000087E4  41FA 030E               1829      lea     strNewline(PC), a0
000087E8                          1830  
000087E8                          1831  *------------------------------------------------------------------------------
000087E8                          1832  * Write a null terminated string to SCC1, blocking if tx buffer is not ready
000087E8                          1833  * A0 holds the address of the first character of the null terminated string
000087E8                          1834  *------------------------------------------------------------------------------
000087E8                          1835  putString:
000087E8  48E7 8040               1836      movem.l d0/a1,-(sp)             * save d0 & a1
000087EC                          1837  
000087EC                          1838  .ps_1:
000087EC  0839 0007 00FFF440      1839      btst.b  #7,M302_SCC1PB+M302_TXBD0           * test the R bit in TXBD0
000087F4  66F6                    1840      bne.s   .ps_1                   * test again if R=1
000087F6                          1841  
000087F6                          1842      * SCC1 TX buffer #0 is available for use
000087F6  227C 00FFF000           1843      movea.l #SCC1TXB0,a1            * A1 points to SCC1 Tx buffer
000087FC  4280                    1844      clr.l   d0                      * clear our char counter
000087FE                          1845  
000087FE                          1846  .ps_2:
000087FE  12D8                    1847      move.b  (a0)+,(a1)+             * copy the char to SCC1 Tx buffer
00008800  6718                    1848      beq.s   .ps_ex                  * done if it's a NULL
00008802  5240                    1849      addq.w  #1,d0                   * increment tx buffer char count
00008804  0C40 007F               1850      cmpi.w  #SER1_BUFSIZE-1,d0      * have we filled the tx buffer?
00008808  66F4                    1851      bne.s   .ps_2
0000880A                          1852      
0000880A                          1853      * SCC1 TX buffer is full so send it
0000880A  33C0 00FFF442           1854      move.w  d0,M302_SCC1PB+M302_TXBD0+2     * write number of chars to send
00008810  0079 8000 00FFF440      1855      ori.w   #$8000,M302_SCC1PB+M302_TXBD0       * signal tx buffer ready
00008818  60D2                    1856      bra.s   .ps_1                   * go back and wait for buffer to empty
0000881A                          1857  
0000881A                          1858  .ps_ex:
0000881A  33C0 00FFF442           1859      move.w  d0,M302_SCC1PB+M302_TXBD0+2     * write number of chars to send
00008820  0079 8000 00FFF440      1860      ori.w   #$8000,M302_SCC1PB+M302_TXBD0       * signal tx buffer ready
00008828                          1861  
00008828  4CDF 0201               1862      movem.l (sp)+,d0/a1             * restore d0 & a1
0000882C  4E75                    1863      rts
0000882E                          1864  
0000882E                          1865  *------------------------------------------------------------------------------
0000882E                          1866  * Write a character to SCC1, blocking if UART is not ready
0000882E                          1867  * D0 = char to send
0000882E                          1868  *------------------------------------------------------------------------------
0000882E                          1869  putCh:
0000882E  0839 0007 00FFF440      1870      btst.b  #7,M302_SCC1PB+M302_TXBD0           * test the R bit in TXBD0
00008836  66F6                    1871      bne.s   putCh                   * test again if R=1
00008838                          1872  
00008838                          1873      * SCC1 TX buffer is available for use
00008838  13C0 00FFF000           1874      move.b  d0,SCC1TXB0             * write the char to the tx buffer
0000883E  33FC 0001 00FFF442      1875      move.w  #1,M302_SCC1PB+M302_TXBD0+2     * set 1 char to send
00008846  0079 8000 00FFF440      1876      ori.w   #$8000,M302_SCC1PB+M302_TXBD0       * signal tx buffer ready
0000884E  4E75                    1877      rts
00008850                          1878  
00008850                          1879  *------------------------------------------------------------------------------
00008850                          1880  * Read a character from SCC1 - blocking call so will wait for character
00008850                          1881  * Check both Rx buffers for a character. If it's an S, then don't free the
00008850                          1882  * buffer as the S-record routine will do that.
00008850                          1883  * D0 = recevied char
00008850                          1884  * If it's an S-record then A0=addr of buffer & A2=addr of flags
00008850                          1885  *------------------------------------------------------------------------------
00008850                          1886  getCh:
00008850                          1887      * check Rx buffer #0
00008850  3039 00FFF400           1888      move.w  M302_SCC1PB+M302_RXBD0,d0           * read RxBD #0 status flags
00008856  0240 8000               1889      andi.w  #$8000,d0               * mask all but the empty flag
0000885A  6624                    1890      bne.s   .getCh1                 * check RxBD #1
0000885C                          1891      
0000885C  1039 00FFF080           1892      move.b  SCC1RXB0,d0             * get the received char
00008862  0C00 0053               1893      cmpi.b  #'S',d0                 * is it the start of an S-record?
00008866  660E                    1894      bne.s   .ex1
00008868  207C 00FFF080           1895      move.l  #SCC1RXB0,a0            * A0 = addr of buffer
0000886E  247C 00FFF400           1896      move.l  #M302_SCC1PB+M302_RXBD0,a2        * A2 = addr of buffer flags
00008874  4E75                    1897      rts                             * exit without freeing buffer
00008876                          1898  .ex1:
00008876  0079 8000 00FFF400      1899      ori.w   #$8000,M302_SCC1PB+M302_RXBD0       * signal buffer is free
0000887E  4E75                    1900      rts
00008880                          1901  
00008880                          1902  .getCh1:
00008880                          1903      * check Rx buffer #1
00008880  3039 00FFF408           1904      move.w  M302_SCC1PB+M302_RXBD1,d0           * read RxBD #1 status flags
00008886  0240 8000               1905      andi.w  #$8000,d0               * mask all but the empty flag
0000888A  66C4                    1906      bne.s   getCh                   * check RxBD #0 again
0000888C                          1907      
0000888C  1039 00FFF100           1908      move.b  SCC1RXB1,d0             * read the receved char
00008892  0C00 0053               1909      cmpi.b  #'S',d0                 * is it the start of an S-record?
00008896  660E                    1910      bne.s   .ex2
00008898  207C 00FFF100           1911      move.l  #SCC1RXB1,a0            * A0 = addr of buffer
0000889E  247C 00FFF408           1912      move.l  #M302_SCC1PB+M302_RXBD1,a2        * A2 = addr of buffer flags
000088A4  4E75                    1913      rts                             * exit without freeing buffer
000088A6                          1914  .ex2:
000088A6  0079 8000 00FFF408      1915      ori.w   #$8000,M302_SCC1PB+M302_RXBD1       * signal buffer is free
000088AE  4E75                    1916      rts
000088B0                          1917  
000088B0                          1918  *------------------------------------------------------------------------------
000088B0                          1919  * Check for a character received on SCC1
000088B0                          1920  * Check both Rx buffers for a character.
000088B0                          1921  * Set D1.B to 1 if keyboard input is pending, otherwise set to 0.
000088B0                          1922  *------------------------------------------------------------------------------
000088B0                          1923  chkCh:
000088B0                          1924      * check Rx buffer #0
000088B0  3039 00FFF400           1925      move.w  M302_SCC1PB+M302_RXBD0,d0           * read RxBD #0 status flags
000088B6  0240 8000               1926      andi.w  #$8000,d0               * mask all but the empty flag
000088BA  6606                    1927      bne.s   .chkRx1                 * no char so check RxBD #1
000088BC                          1928      
000088BC  123C 0001               1929      move.b  #1,d1                   * signal there's a char available
000088C0  4E75                    1930      rts
000088C2                          1931  
000088C2                          1932  .chkRx1:
000088C2                          1933      * check Rx buffer #1
000088C2  3039 00FFF408           1934      move.w  M302_SCC1PB+M302_RXBD1,d0           * read RxBD #1 status flags
000088C8  0240 8000               1935      andi.w  #$8000,d0               * mask all but the empty flag
000088CC  6606                    1936      bne.s   chkCh_ex                * checks done - no char available
000088CE                          1937      
000088CE  123C 0001               1938      move.b  #1,d1                   * signal there's a char available
000088D2  4E75                    1939      rts
000088D4                          1940  
000088D4                          1941  chkCh_ex:
000088D4  123C 0000               1942      move.b  #0,d1                   * signal there's no char available
000088D8  4E75                    1943      rts
000088DA                          1944  
000088DA                          1945  *------------------------------------------------------------------------------
000088DA                          1946  * String constants
000088DA                          1947  *------------------------------------------------------------------------------
000088DA                          1948  strBanner1:
000088DA= 0A 0D                   1949      dc.b 10,13
000088DC= 53 69 6D 70 6C 65 ...   1950      dc.b 'Simple RCBus 68302 ROM Monitor v0.2',10,13
00008901= 52 4F 4D 3A 20 30 ...   1951      dc.b 'ROM: 0x000000 .. 0x01FFFF',10,13
0000891C= 52 41 4D 3A 20 30 ...   1952      dc.b 'RAM: 0x100000 .. 0x1FFFFF',10,13,0
00008938                          1953  strCommands:
00008938= 0A 0D 43 6F 6D 6D ...   1954      dc.b 10,13,'Commands: ',10,13
00008946= 42 20 20 20 20 20 ...   1955      dc.b 'B     : Start EhBASIC v3.54',10,13
00008963= 43 20 20 20 20 20 ...   1956      dc.b 'C     : Start CP/M-68K v1.3',10,13
00008980= 44 6E 6E 6E 6E 20 ...   1957      dc.b 'Dnnnn : Display 256 bytes of memory starting at address nnnn',10,13
000089BE= 47 6E 6E 6E 6E 20 ...   1958      dc.b 'Gnnnn : Execute code starting at address nnnn',10,13
000089ED= 49 61 61 20 20 20 ...   1959      dc.b 'Iaa   : Read a byte from address aa in I/O space',10,13
00008A1F= 4D 6E 6E 6E 6E 20 ...   1960      dc.b 'Mnnnn : Modify memory starting at address nnnn',10,13
00008A4F= 4F 61 61 62 62 20 ...   1961      dc.b 'Oaabb : Write byte bb to address aa in I/O space',10,13
00008A81= 53 31 78 78 78 20 ...   1962      dc.b 'S1xxx : Download S1 Hex Record ',10,13          
00008AA2= 53 32 78 78 78 20 ...   1963      dc.b 'S2xxx : Download S2 Hex Record ',10,13    
00008AC3= 3F 20 20 20 20 20 ...   1964      dc.b '?     : Display this help',10,13
00008ADE= 00                      1965      dc.b 0
00008ADF                          1966  strPrompt:
00008ADF= 3E 20 00                1967      dc.b '> ',0
00008AE2                          1968  strUnkCmd:
00008AE2= 55 6E 6B 6E 6F 77 ...   1969      dc.b 'Unknown Command: ',0
00008AF4                          1970  strNewline:
00008AF4= 0A 0D 00                1971      dc.b 10,13,0
00008AF7                          1972  strColonSpace:
00008AF7= 3A 20 00                1973      dc.b ': ',0
00008AFA                          1974  strUninitInt:
00008AFA= 55 6E 68 61 6E 64 ...   1975      dc.b 'Unhandled interrupt.',10,13,0
00008B11                          1976  strUserReturn:
00008B11= 0A 0D 55 73 65 72 ...   1977      dc.b 10,13,'User program completed.',10,13,0
00008B2D                          1978  strEasyTask1:
00008B2D= 0A 0D 53 54 4F 50 ...   1979      dc.b    10,13,'STOP: EASy68K TRAP #15 - Task ',0
00008B4E                          1980  strEasyTask2:
00008B4E= 20 6E 6F 74 20 79 ...   1981      dc.b    ' not yet implemented',10,13,0
00008B65                          1982  strCPMErr1:
00008B65= 0A 0D 43 61 6E 6E ...   1983      dc.b    10,13,'Cannot boot CP/M-68K - CP/M-68K missing from EEPROM',10,13,0
00008B9D                          1984  strCPMErr2:
00008B9D= 0A 0D 43 61 6E 6E ...   1985      dc.b    10,13,'Cannot boot CP/M-68K - CP/M-68K BIOS missing from EEPROM',10,13,0
00008BDA                          1986  strCPMReturn:
00008BDA= 0A 0D 43 50 2F 4D ...   1987      dc.b    10,13,'CP/M-68K returned to Monitor. Press RESET to restart.',10,13,0
00008C14                          1988  strBASICErr1:
00008C14= 0A 0D 43 61 6E 6E ...   1989      dc.b    10,13,'Cannot boot EhBASIC - EhBASIC missing from EEPROM',10,13,0
00008C4A                          1990  strBASICReturn:
00008C4A= 0A 0D 45 68 42 41 ...   1991      dc.b    10,13,'EhBASIC returned to Monitor. Press RESET to restart.',10,13,0
00008C83                          1992  
00008C83                          1993  *------------------------------------------------------------------------------
00008C83                          1994  * put the SCC1 Tx and Rx buffers in internal 68302 RAM
00008C83                          1995  *------------------------------------------------------------------------------
00FFF000                          1996      org     M302_BASE_ADDR
00FFF000                          1997      
00FFF000                          1998  * SCC1 RX and Tx buffers - 1 Tx and 2 Rx
00FFF000                          1999  SCC1TXB0:   ds.b    SER1_BUFSIZE
00FFF080                          2000  SCC1RXB0:   ds.b    SER1_BUFSIZE
00FFF100                          2001  SCC1RXB1:   ds.b    SER1_BUFSIZE
00FFF180                          2002  
00FFF180                          2003  *------------------------------------------------------------------------------
00FFF180                          2004  * Monitor variables
00FFF180                          2005  *------------------------------------------------------------------------------
001FF800                          2006      ORG     STACK_START
001FF800                          2007  msgASCIIDump:
001FF800                          2008      ds.b 20
001FF814                          2009  serBuff:   
001FF814                          2010      ds.b    8
001FF81C                          2011      
001FF81C                          2012      ORG     (*+1)&-2       * force word alignment
001FF81C                          2013  
001FF81C                          2014  srecAddr:      ds.l 1
001FF820                          2015  srecType:      ds.b 1
001FF821                          2016  srecByteCnt:   ds.b 1
001FF822                          2017  
001FF822                          2018      END    START            * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AEMSG1              78DA
AEMSG2              791E
ASCII_CR            D
ASCII_LF            A
AV1MSG              7950
AV2MSG              798C
AV3MSG              79C8
AV4MSG              7A04
AV5MSG              7A40
AV6MSG              7A7C
AV7MSG              7AB8
BEMSG1              7AF4
BEMSG2              7B33
BIOS_PRIV           1000
CCP_BSS_BASE        1FD800
CCP_PRIV            1000
CHKCH               88B0
CHKCH:CHKRX1        88C2
CHKCH_EX            88D4
CHTOUPPER           84CE
CHTOUPPER:DONE      84DE
CIMSG               7B65
CMDBOOTCPM          821E
CMDBOOTCPM:BOOTCPM  8246
CMDBOOTCPM:CHKBIOS  8232
CMDBOOTCPM:FOREVER  8256
CMDBOOTEHBASIC      81F6
CMDBOOTEHBASIC:BOOTEHBASIC  820C
CMDBOOTEHBASIC:FOREVER  821C
CMDDISPMEMORY       8258
CMDDOWNLOAD         838C
CMDHELP             845C
CMDIOREAD           82A2
CMDIOWRITE          8342
CMDMODIFYMEMORY     82E4
CMDMODIFYMEMORY:CMM_1  8306
CMDMODIFYMEMORY:CMM_2  833A
CMDRUN              827A
CPM_BASE            400
CS0_BR              0
CS0_OR              1FC0
CS1_BR              200
CS1_OR              1E00
CS2_BR              1F80
CS2_OR              1FC0
DECODESREC          838C
DECODESREC:ADDR2BYTES  83EC
DECODESREC:ADDR3BYTES  83DC
DECODESREC:ADDR4BYTES  83CC
DECODESREC:FAIL     8428
DECODESREC:IGNORE   8448
DECODESREC:OK       8438
DECODESREC:RDCHECKSUM  841C
DECODESREC:RDLOOP   840C
DUMPRAM             8468
DUMPRAM:DR_1        8476
DUMPRAM:DR_2        848E
EASY68KTASKTABLE    85C2
EASY68KTRAP15       86A4
EASYTASK0           864E
EASYTASK0:END       8660
EASYTASK0:LOOP      8654
EASYTASK1           8666
EASYTASK10          862A
EASYTASK11          862A
EASYTASK12          862A
EASYTASK13          8690
EASYTASK14          869C
EASYTASK15          862A
EASYTASK16          862A
EASYTASK17          862A
EASYTASK18          862A
EASYTASK19          862A
EASYTASK1:END       8678
EASYTASK1:LOOP      866C
EASYTASK2           862A
EASYTASK20          862A
EASYTASK21          862A
EASYTASK22          862A
EASYTASK23          862A
EASYTASK24          862A
EASYTASK25          862A
EASYTASK3           862A
EASYTASK4           862A
EASYTASK5           867A
EASYTASK6           8682
EASYTASK7           868A
EASYTASK8           862A
EASYTASK9           862A
EASYTASKUNSUPPORTED  862A
EASYTASKUNSUPPORTED:INFLOOP  864C
EHBASIC_BASE        9000
GETCH               8850
GETCH:EX1           8876
GETCH:EX2           88A6
GETCH:GETCH1        8880
HANDLEADDRERR       770C
HANDLEAV1           77AC
HANDLEAV2           77B8
HANDLEAV3           77C4
HANDLEAV4           77D0
HANDLEAV5           77DC
HANDLEAV6           77E8
HANDLEAV7           77F4
HANDLEBUSERR        76F0
HANDLECHKINST       7740
HANDLECLEANUP       78CC
HANDLECLEANUP:INFLOOP  78D8
HANDLEILLINST       7728
HANDLELINEA         7770
HANDLELINEF         777C
HANDLEPRIV          7758
HANDLERES1          7788
HANDLERES10         7788
HANDLERES11         7788
HANDLERES2          7788
HANDLERES3          7788
HANDLERES4          7788
HANDLERES5          7788
HANDLERES6          7788
HANDLERES7          7788
HANDLERES8          7788
HANDLERES9          7788
HANDLESPUR          77A0
HANDLETRACE         7764
HANDLETRAP0         7800
HANDLETRAP1         780C
HANDLETRAP10        7878
HANDLETRAP11        7884
HANDLETRAP12        7890
HANDLETRAP13        789C
HANDLETRAP14        78A8
HANDLETRAP15        78B4
HANDLETRAP2         7818
HANDLETRAP3         7824
HANDLETRAP4         7830
HANDLETRAP5         783C
HANDLETRAP6         7848
HANDLETRAP7         7854
HANDLETRAP8         7860
HANDLETRAP9         786C
HANDLETRAPV         774C
HANDLEUNINIT        7794
HANDLEUNUSED        78C0
HANDLEZERODIV       7734
HEXCHARTONIBBLE     857E
HEXCHARTONIBBLE:HEXERROR  85BE
HEXCHARTONIBBLE:ISDIGIT  85B8
HEXCHARTONIBBLE:ISUPPER  85AE
HEXTOINT            84F2
HEXTOINT:H2I_1      84F2
HEXTOINT:H2I_2      851A
HEXTOINT:H2I_ERR    8526
HEXTOINT:H2I_X      8522
HEXTOINTECHO        852C
HEXTOINTECHO:H2I_1  852C
HEXTOINTECHO:H2I_2  8558
HEXTOINTECHO:H2I_ERR  8564
HEXTOINTECHO:H2I_X  8560
IIMSG               7B92
IO_BASE             FD0000
JMP302EV00          71F0
JMP302EV01          71F8
JMP302EV02          7200
JMP302EV03          7208
JMP302EV04          7210
JMP302EV05          7218
JMP302EV06          7220
JMP302EV07          7228
JMP302EV08          7230
JMP302EV09          7238
JMP302EV0A          7240
JMP302EV0B          7248
JMP302EV0C          7250
JMP302EV0D          7258
JMP302EV0E          7260
JMP302EV0F          7268
JMP302EV10          7270
JMP302EV11          7278
JMP302EV12          7280
JMP302EV13          7288
JMP302EV14          7290
JMP302EV15          7298
JMP302EV16          72A0
JMP302EV17          72A8
JMP302EV18          72B0
JMP302EV19          72B8
JMP302EV1A          72C0
JMP302EV1B          72C8
JMP302EV1C          72D0
JMP302EV1D          72D8
JMP302EV1E          72E0
JMP302EV1F          72E8
JMPADDRERR          7008
JMPAV1              70B8
JMPAV2              70C0
JMPAV3              70C8
JMPAV4              70D0
JMPAV5              70D8
JMPAV6              70E0
JMPAV7              70E8
JMPBUSERR           7000
JMPCHKINST          7020
JMPILLINST          7010
JMPLINEA            7040
JMPLINEF            7048
JMPPRIV             7030
JMPRES1             7050
JMPRES10            70A0
JMPRES11            70A8
JMPRES2             7058
JMPRES3             7060
JMPRES4             7070
JMPRES5             7078
JMPRES6             7080
JMPRES7             7088
JMPRES8             7090
JMPRES9             7098
JMPSPUR             70B0
JMPTRACE            7038
JMPTRAP0            70F0
JMPTRAP1            70F8
JMPTRAP10           7140
JMPTRAP11           7148
JMPTRAP12           7150
JMPTRAP13           7158
JMPTRAP14           7160
JMPTRAP15           7168
JMPTRAP2            7100
JMPTRAP3            7108
JMPTRAP4            7110
JMPTRAP5            7118
JMPTRAP6            7120
JMPTRAP7            7128
JMPTRAP8            7130
JMPTRAP9            7138
JMPTRAPV            7028
JMPUNINIT           7068
JMPUNUSED           7170
JMPZERODIV          7018
LAMSG               7BCD
LFMSG               7BFD
M302_BAR            F2
M302_BASE_ADDR      FFF000
M302_BR0            FFF830
M302_BR1            FFF834
M302_BR2            FFF838
M302_BR3            FFF83C
M302_BRKCR          A0
M302_BRKEC          A8
M302_CCHAR1         B0
M302_CCHAR2         B2
M302_CCHAR3         B4
M302_CCHAR4         B6
M302_CCHAR5         B8
M302_CCHAR6         BA
M302_CCHAR7         BC
M302_CCHAR8         BE
M302_CKCR           FA
M302_CR             FFF860
M302_DSR1           FFF886
M302_DSR2           FFF896
M302_DSR3           FFF8A6
M302_FRMEC          A4
M302_GIMR           FFF812
M302_IMR            FFF816
M302_IPR            FFF814
M302_ISR            FFF818
M302_MAXIDL         9C
M302_MRBLR          82
M302_NOSEC          A6
M302_OR0            FFF832
M302_OR1            FFF836
M302_OR2            FFF83A
M302_OR3            FFF83E
M302_PACNT          FFF81E
M302_PADAT          FFF822
M302_PADDR          FFF820
M302_PAREC          A2
M302_PBCNT          FFF824
M302_PBDAT          FFF828
M302_PBDDR          FFF826
M302_RFCR           80
M302_RXBD0          0
M302_RXBD1          8
M302_RXBD2          10
M302_RXBD3          18
M302_RXBD4          20
M302_RXBD5          28
M302_RXBD6          30
M302_RXBD7          38
M302_RXIBN          87
M302_SCC1PB         FFF400
M302_SCC2PB         FFF500
M302_SCC3PB         FFF600
M302_SCCE1          FFF888
M302_SCCE2          FFF898
M302_SCCE3          FFF8A8
M302_SCCM1          FFF88A
M302_SCCM2          FFF89A
M302_SCCM3          FFF8AA
M302_SCCS1          FFF88C
M302_SCCS2          FFF89C
M302_SCCS3          FFF8AC
M302_SCM1           FFF884
M302_SCM2           FFF894
M302_SCM3           FFF8A4
M302_SCON1          FFF882
M302_SCON2          FFF892
M302_SCON3          FFF8A2
M302_SCR            F4
M302_SIMASK         FFF8B2
M302_SIMODE         FFF8B4
M302_SPMODE         FFF8B0
M302_TCN1           FFF846
M302_TCN2           FFF856
M302_TCR1           FFF844
M302_TCR2           FFF854
M302_TER1           FFF849
M302_TER2           FFF859
M302_TFCR           81
M302_TMR1           FFF840
M302_TMR2           FFF850
M302_TRR1           FFF842
M302_TRR2           FFF852
M302_TXBD0          40
M302_TXBD1          48
M302_TXBD2          50
M302_TXBD3          58
M302_TXBD4          60
M302_TXBD5          68
M302_TXBD6          70
M302_TXBD7          78
M302_TXIBN          93
M302_UADDR1         AA
M302_UADDR2         AC
M302_WCN            FFF84C
M302_WRR            FFF84A
MAKEPRINTABLE       84E0
MAKEPRINTABLE:MP_1  84EC
MAKEPRINTABLE:MP_X  84F0
MEM_BASE            FC0000
MONLOOP             817C
MONLOOP_CRLF        81F0
MONLOOP_NP          8184
MONSTART            816C
MON_BASE            7000
MON_PRIV            800
MSGASCIIDUMP        1FF800
PUTCH               882E
PUTCRLF             87E4
PUTSTRING           87E8
PUTSTRING:PS_1      87EC
PUTSTRING:PS_2      87FE
PUTSTRING:PS_EX     881A
PVMSG               7C2D
RAMVECJUMP          0
RAM_BASE            100000
RAM_SIZE            100000
RCB_BASE            FC0000
RCB_SIZE            20000
READHEXBYTE         856A
RIMSG               7C6A
ROM2RAMIVT          72F0
ROM_BASE            0
ROM_SIZE            20000
SCC1INIT            86C4
SCC1RXB0            FFF080
SCC1RXB1            FFF100
SCC1TXB0            FFF000
SER1_BAUD           B
SER1_BUFSIZE        80
SERBUFF             1FF814
SIMSG               7C9C
SRECADDR            1FF81C
SRECBYTECNT         1FF821
SRECTYPE            1FF820
STACK_START         1FF800
START               80F0
START:COPY          8162
STRBANNER1          88DA
STRBASICERR1        8C14
STRBASICRETURN      8C4A
STRCOLONSPACE       8AF7
STRCOMMANDS         8938
STRCPMERR1          8B65
STRCPMERR2          8B9D
STRCPMRETURN        8BDA
STREASYTASK1        8B2D
STREASYTASK2        8B4E
STRNEWLINE          8AF4
STRPROMPT           8ADF
STRUNINITINT        8AFA
STRUNKCMD           8AE2
STRUSERRETURN       8B11
SYSCLK              708000
TR0MSG              7D07
TR10MSG             7EF1
TR11MSG             7F23
TR12MSG             7F55
TR13MSG             7F87
TR14MSG             7FB9
TR15MSG             7FEB
TR1MSG              7D38
TR2MSG              7D69
TR3MSG              7D9A
TR4MSG              7DCB
TR5MSG              7DFC
TR6MSG              7E2D
TR7MSG              7E5E
TR8MSG              7E8F
TR9MSG              7EC0
TRMSG               7CD8
TVMSG               801D
UIMSG               804C
USERMSG             808D
VEC_BASE            100000
VEC_SIZE            400
WRITEADDR24         87B0
WRITEADDR32         87A4
WRITEBYTE           87C2
WRITENIBBLE         87CA
WRITENIBBLE:WN1     87D8
WRITEWORD           87BA
ZDMSG               80BB
