00007EE8 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 07/01/2026 16:10:32

00000000                             1  *******************************************************************************
00000000                             2  *
00000000                             3  *  ######   #####  #     #                      #####   #####  #    # 
00000000                             4  *  #     # #     # ##   ##  ####  #    #       #     # #     # #   #  
00000000                             5  *  #     # #       # # # # #    # ##   #       #       #     # #  #   
00000000                             6  *  ######  #       #  #  # #    # # #  # ##### ######   #####  ###    
00000000                             7  *  #   #   #       #     # #    # #  # #       #     # #     # #  #   
00000000                             8  *  #    #  #     # #     # #    # #   ##       #     # #     # #   #  
00000000                             9  *  #     #  #####  #     #  ####  #    #        #####   #####  #    # v1.4
00000000                            10  *
00000000                            11  *******************************************************************************
00000000                            12  * This is my own simple monitor program for my RCBus 68000 board. It supports
00000000                            13  * simple S-Record loading as well as memory display & simple memory editing.
00000000                            14  * In addition it allows reading and writing bytes to the RCBus IO space.
00000000                            15  *
00000000                            16  * There's no breakpoints, single stepping or disassembly stuff.
00000000                            17  *******************************************************************************
00000000                            18  * Hardware assumptions:
00000000                            19  *
00000000                            20  * + My RCBus SIO board is used and an MC68681 (or equivalent) SIO chip is
00000000                            21  *   present at the address DUART1 (see devices.inc)
00000000                            22  * + ROM is present at address 0x000000 onwards
00000000                            23  * + RAM is present at address RAM_BASE (see memory.inc)
00000000                            24  *******************************************************************************
00000000                            25  * EEPROM programming:
00000000                            26  *
00000000                            27  * Use EASyBIN to split the S-Record into ODD and EVEN bytes.
00000000                            28  * + The *_0.BIN file goes in the U ROM socket - holding D08..D15
00000000                            29  * + The *_1.BIN file goes in the L ROM socket - holding D00..D07
00000000                            30  *******************************************************************************
00000000                            31  * Exception Handling:
00000000                            32  *
00000000                            33  * ROM starts at 0x000000 and holds the ROM exception vector table that points
00000000                            34  * to the exception handling routines in ROM. These ROM handlers fetch the
00000000                            35  * addresses of the actual exception handling routines from the start of RAM 
00000000                            36  * or wherever VEC_BASE is defined and re-directs execution to that address.
00000000                            37  * Initially the RAM addresses all point back to handlers in ROM but can be
00000000                            38  * overwritten to point to a user supplied handler in RAM. 
00000000                            39  *
00000000                            40  * Some Easy68k TRAP #15 text I/O routines are implemented as follows:
00000000                            41  * Currently only tasks 0,1,5,6,13 & 14 are supported.
00000000                            42  *******************************************************************************
00000000                            43  * EhBASIC Support:
00000000                            44  *
00000000                            45  * The EhBASIC s-record file can be programmed into the EEPROMs at the same
00000000                            46  * time as this monitor and should reside at address EHBASIC_BASE (see memory.inc).
00000000                            47  *******************************************************************************
00000000                            48  * Interrupts:
00000000                            49  *
00000000                            50  * An interrupt handler is setup to handle autovector level 2 interrupts from
00000000                            51  * the DUART. Make sure that the jumper is set on the SIO board for level 2
00000000                            52  * interrupts.
00000000                            53  *******************************************************************************
00000000                            54  
00000000                            55      INCLUDE "..\asm-inc\memory.inc"
00000000                            56  
00000000  =00007000                 57  MON_BASE        EQU     $7000
00000000                            58  
00000000  =00009000                 59  EHBASIC_BASE    EQU     $9000
00000000                            60  
00000000  =00100000                 61  RAM_BASE        EQU     $100000
00000000  =00100000                 62  RAM_LEN         EQU     $100000
00000000                            63  
00000000  =00100000                 64  VEC_BASE        EQU     RAM_BASE
00000000  =00000400                 65  VEC_SIZE        EQU     $400         * table takes up 1024 bytes
00000000                            66  
00000000  =00F80000                 67  IO_BASE         EQU     $F80000     * I/O space base address = 00F8_0000
00000000                            68  
00000000  =00F00000                 69  MEM_BASE        EQU     $F00000     * Mem space base address = 00F0_0000
00000000                            70  
00000000  =00000400                 71  CPM_BASE        EQU     $0400       * CP/M-68K entry point
00000000                            72  
00000000  =001FD800                 73  CCP_BSS_BASE    EQU     $1FD800
00000000  =00001000                 74  CCP_PRIV        EQU     4096
00000000                            75  
00000000  =00000800                 76  MON_PRIV        EQU     2048
00000000                            77  
00000000  =00001000                 78  BIOS_PRIV       EQU     4096
00000000                            79  
00000000  =001FF800                 80  STACK_START     EQU     RAM_BASE+RAM_LEN-MON_PRIV
00000000  =001FF800                 81  -------------------- end include --------------------
00000000                            82      INCLUDE "..\asm-inc\devices.inc"
00000000                            83  
00000000  =00D00000                 84  DUART1      EQU     $D00000
00000000                            85  
00000000  =00000010                 86  SC145ADDR   EQU     $10           * SC145 base address is 0x10
00000000                            87  
00000000  =00F80020                 88  SC145       EQU     IO_BASE+(SC145ADDR<<1)
00000000                            89  
00000000                            90  
00000000  =00D00001                 91  MRA         EQU DUART1+1           * Mode Register A             (R/W)
00000000  =00D00003                 92  SRA         EQU DUART1+3           * Status Register A           (R)
00000000  =00D00003                 93  CSRA        EQU DUART1+3           * Clock Select Register A     (W)
00000000  =00D00005                 94  CRA         EQU DUART1+5           * Commands Register A         (W)
00000000  =00D00007                 95  RBA         EQU DUART1+7           * Receiver Buffer A           (R)
00000000  =00D00007                 96  TBA         EQU DUART1+7           * Transmitter Buffer A        (W)
00000000  =00D00009                 97  ACR         EQU DUART1+9           * Aux. Control Register       (R/W)
00000000  =00D0000B                 98  ISR         EQU DUART1+11          * Interrupt Status Register   (R)
00000000  =00D0000B                 99  IMR         EQU DUART1+11          * Interrupt Mask Register     (W)
00000000  =00D00011                100  MRB         EQU DUART1+17          * Mode Register B             (R/W)
00000000  =00D00013                101  SRB         EQU DUART1+19          * Status Register B           (R)
00000000  =00D00013                102  CSRB        EQU DUART1+19          * Clock Select Register B     (W)
00000000  =00D00015                103  CRB         EQU DUART1+21          * Commands Register B         (W)
00000000  =00D00017                104  RBB         EQU DUART1+23          * Reciever Buffer B           (R)
00000000  =00D00017                105  TBB         EQU DUART1+23          * Transmitter Buffer B        (W)
00000000  =00D00019                106  IVR         EQU DUART1+25          * Interrupt Vector Register   (R/W)
00000000  =00D0001B                107  IPR         EQU DUART1+27          * Input Port Register         (R)
00000000  =00D0001B                108  OPCR        EQU DUART1+27          * Output Port Config Register (W)
00000000  =00D0001D                109  BCNT        EQU DUART1+29          * Start Counter               (R)
00000000  =00D0001D                110  SOPR        EQU DUART1+29          * Set Output Port Register    (W)
00000000  =00D0001F                111  ECNT        EQU DUART1+31          * Stop Counter                (R)
00000000  =00D0001F                112  ROPR        EQU DUART1+31          * Reset Output Port Register  (W)
00000000                           113  
00000000  =00000066                114  BAUD_1200       EQU     $66         * 1200 baud
00000000  =00000088                115  BAUD_2400       EQU     $88         * 2400 baud
00000000  =00000099                116  BAUD_4800       EQU     $99         * 4800 baud
00000000  =000000BB                117  BAUD_9600       EQU     $BB         * 9600 baud
00000000  =000000CC                118  BAUD_38400      EQU     $CC         * 38400 baud
00000000                           119  
00000000  =000000CC                120  BAUD_RATE       EQU     BAUD_38400
00000000                           121  
00000000  =00F80021                122  CF_DATA     EQU SC145+1           * Data               (R/W)
00000000  =00F80023                123  CF_FEATURES EQU SC145+3           * Features           (W)
00000000  =00F80023                124  CF_ERROR    EQU SC145+3           * Error              (R)
00000000  =00F80025                125  CF_SECCOUNT EQU SC145+5           * Sector Count       (R/W)
00000000  =00F80027                126  CF_SECTOR   EQU SC145+7           * Sector Number      (R/W)
00000000  =00F80029                127  CF_CYL_LOW  EQU SC145+9           * Cylinder Low Byte  (R/W) 
00000000  =00F8002B                128  CF_CYL_HI   EQU SC145+11          * Cylinder High Byte (R/W)
00000000  =00F8002D                129  CF_HEAD     EQU SC145+13          * Drive / Head       (R/W)
00000000  =00F8002F                130  CF_STATUS   EQU SC145+15          * Status             (R)
00000000  =00F8002F                131  CF_COMMAND  EQU SC145+15          * Command            (W)
00000000                           132  
00000000  =00F80027                133  CF_LBA0007  EQU SC145+7           * LBA bits 07..00    (R/W)
00000000  =00F80029                134  CF_LBA0815  EQU SC145+9           * LBA bits 15..08    (R/W)
00000000  =00F8002B                135  CF_LBA1623  EQU SC145+11          * LBA bits 23..16    (R/W)
00000000  =00F8002D                136  CF_LBA2427  EQU SC145+13          * LBA bits 27..24    (R/W)
00000000                           137  
00000000  =00000001                138  CF_8BIT     EQU 1                 * Set 8-bit mode
00000000  =00000082                139  CF_NOCACHE  EQU $82               * Disable the cache
00000000                           140  
00000000  =00000020                141  CF_RD_SEC   EQU $20               * Read Sector Command
00000000  =00000030                142  CF_WR_SEC   EQU $30               * Write Sector Command
00000000  =000000EF                143  CF_SET_FEAT EQU $EF               * Set Feature Command
00000000  =000000E0                144  CF_LBAMODE  EQU $E0               * LBA mode
00000000  =000000E0                145  -------------------- end include --------------------
00000000                           146  
00000000                           147  *******************************************************************************
00000000                           148  * The serial port originally ran at 38400 baud for the MC68681 SIO chip.
00000000                           149  * Alternative compatibe chips were made by Philips (SCC68681,SCN68681 & SCC68692)
00000000                           150  * that supported higher baud rates using a special test mode.
00000000                           151  * Set HI_SPEED to 1 to enable 115200 baud or 0 for standard 38400 baud.  
00000000                           152  *******************************************************************************
00000000  =00000001                153  HI_SPEED    equ 1
00000000                           154  
00000000                           155  *******************************************************************************
00000000                           156  * ramVecJump : Macro to "jump" to exception handler in the RAM vector table
00000000                           157  * Parameter \1 is the vector number 
00000000                           158  * Put the handler address held in RAM onto the stack and RET to it
00000000                           159  *******************************************************************************
00000000                           160  ramVecJump  MACRO
00000000                           161      move.l  VEC_BASE+(\1<<2),-(SP)
00000000                           162      rts
00000000                           163      ENDM
00000000                           164  
00000000                           165  *------------------------------------------------------------------------------
00000000                           166  * ASCII control characters
00000000                           167  *------------------------------------------------------------------------------
00000000  =0000000A                168  LF    equ $0A
00000000  =0000000D                169  CR    equ $0D
00000000                           170  
00000000                           171  *------------------------------------------------------------------------------
00000000                           172  * Serial port receive buffer size - must be multiples of 2!
00000000                           173  *------------------------------------------------------------------------------
00000000  =00000100                174  SERIAL_BUFFER_SIZE  equ 256
00000000  =000000FF                175  SERIAL_BUFFER_MASK  equ SERIAL_BUFFER_SIZE-1
00000000  =000000C8                176  SERIAL_BUFFER_UPPER equ 200
00000000  =00000019                177  SERIAL_BUFFER_LOWER equ 25
00000000                           178  
00000000                           179  *******************************************************************************
00000000                           180  *
00000000                           181  *  ######  ####### #     #       #     # #######  #####  ####### ####### ######   #####  
00000000                           182  *  #     # #     # ##   ##       #     # #       #     #    #    #     # #     # #     # 
00000000                           183  *  #     # #     # # # # #       #     # #       #          #    #     # #     # #       
00000000                           184  *  ######  #     # #  #  #       #     # #####   #          #    #     # ######   #####  
00000000                           185  *  #   #   #     # #     #        #   #  #       #          #    #     # #   #         # 
00000000                           186  *  #    #  #     # #     #         # #   #       #     #    #    #     # #    #  #     # 
00000000                           187  *  #     # ####### #     #          #    #######  #####     #    ####### #     #  #####  
00000000                           188  *                                                                                       
00000000                           189  *******************************************************************************
00000000                           190  * 68000 ROM Exception Vector Table
00000000                           191  *
00000000                           192  * All exceptions eventually get the handler addresses from the RAM vector table. 
00000000                           193  *******************************************************************************
00000000                           194  
00000000                           195      ORG     $0000
00000000                           196  
00000000= 001FF800                 197      DC.l    STACK_START    * Supervisor stack pointer
00000004= 00007EE8                 198      DC.l    START          * Initial PC    
00000008                           199  
00000008= 00007000                 200      DC.L    jmpBusErr      *02 Bus Error
0000000C= 00007008                 201      DC.L    jmpAddrErr     *03 Address Error
00000010= 00007010                 202      DC.L    jmpIllInst     *04 Illegal Instruction
00000014= 00007018                 203      DC.L    jmpZeroDiv     *05 Zero Divide
00000018= 00007020                 204      DC.L    jmpChkInst     *06 CHK Instruction
0000001C= 00007028                 205      DC.L    jmpTrapV       *07 TRAPV Instruction
00000020= 00007030                 206      DC.L    jmpPriv        *08 Privilege Violation
00000024= 00007038                 207      DC.L    jmpTrace       *09 Trace
00000028= 00007040                 208      DC.L    jmpLineA       *0A Line 1010 Emulator
0000002C= 00007048                 209      DC.L    jmpLineF       *0B Line 1111 Emulator
00000030= 00007050                 210      DC.L    jmpRes1        *0C (Unassigned, Reserved)
00000034= 00007058                 211      DC.L    jmpRes2        *0D (Unassigned, Reserved)
00000038= 00007060                 212      DC.L    jmpRes3        *0E (Unassigned, Reserved)
0000003C= 00007068                 213      DC.L    jmpUnInit      *0F Uninitialized Interrupt Vector
00000040= 00007070                 214      DC.L    jmpRes4        *10 (Unassigned, Reserved)
00000044= 00007078                 215      DC.L    jmpRes5        *11 (Unassigned, Reserved)
00000048= 00007080                 216      DC.L    jmpRes6        *12 (Unassigned, Reserved)
0000004C= 00007088                 217      DC.L    jmpRes7        *13 (Unassigned, Reserved)
00000050= 00007090                 218      DC.L    jmpRes8        *14 (Unassigned, Reserved)
00000054= 00007098                 219      DC.L    jmpRes9        *15 (Unassigned, Reserved)
00000058= 000070A0                 220      DC.L    jmpRes10       *16 (Unassigned, Reserved)
0000005C= 000070A8                 221      DC.L    jmpRes11       *17 (Unassigned, Reserved)
00000060= 000070B0                 222      DC.L    jmpSpur        *18 Spurious Interrupt
00000064= 000070B8                 223      DC.L    jmpAV1         *19 Level 1 Interrupt Autovector
00000068= 000070C0                 224      DC.L    jmpAV2         *1A Level 2 Interrupt Autovector
0000006C= 000070C8                 225      DC.L    jmpAV3         *1B Level 3 Interrupt Autovector
00000070= 000070D0                 226      DC.L    jmpAV4         *1C Level 4 Interrupt Autovector
00000074= 000070D8                 227      DC.L    jmpAV5         *1D Level 5 Interrupt Autovector
00000078= 000070E0                 228      DC.L    jmpAV6         *1E Level 6 Interrupt Autovector
0000007C= 000070E8                 229      DC.L    jmpAV7         *1F Level 7 Interrupt Autovector
00000080= 000070F0                 230      DC.L    jmpTrap0       *20 TRAP #0  Instruction Vector
00000084= 000070F8                 231      DC.L    jmpTrap1       *21 TRAP #1  Instruction Vector
00000088= 00007100                 232      DC.L    jmpTrap2       *22 TRAP #2  Instruction Vector
0000008C= 00007108                 233      DC.L    jmpTrap3       *23 TRAP #3  Instruction Vector
00000090= 00007110                 234      DC.L    jmpTrap4       *24 TRAP #4  Instruction Vector
00000094= 00007118                 235      DC.L    jmpTrap5       *25 TRAP #5  Instruction Vector
00000098= 00007120                 236      DC.L    jmpTrap6       *26 TRAP #6  Instruction Vector
0000009C= 00007128                 237      DC.L    jmpTrap7       *27 TRAP #7  Instruction Vector
000000A0= 00007130                 238      DC.L    jmpTrap8       *28 TRAP #8  Instruction Vector
000000A4= 00007138                 239      DC.L    jmpTrap9       *29 TRAP #9  Instruction Vector
000000A8= 00007140                 240      DC.L    jmpTrap10      *2A TRAP #10 Instruction Vector
000000AC= 00007148                 241      DC.L    jmpTrap11      *2B TRAP #11 Instruction Vector
000000B0= 00007150                 242      DC.L    jmpTrap12      *2C TRAP #12 Instruction Vector
000000B4= 00007158                 243      DC.L    jmpTrap13      *2D TRAP #13 Instruction Vector
000000B8= 00007160                 244      DC.L    jmpTrap14      *2E TRAP #14 Instruction Vector
000000BC= 00007168                 245      DC.L    jmpTrap15      *2E TRAP #15 Instruction Vector
000000C0                           246          
000000C0                           247  *------------------------------------------------------------------------------
000000C0                           248  * Exception Vectors 30 to FF are not used on my system so just point them
000000C0                           249  * all to the default handler.
000000C0                           250  
000000C0= 00007170 00007170 ...    251      DCB.L   208,jmpUnused
00000400                           252  
00000400                           253  *******************************************************************************
00000400                           254  * Place the monitor program after the CP/M BIOS code.
00000400                           255  *******************************************************************************
00000400                           256  
00007000                           257      ORG     MON_BASE
00007000                           258  
00007000                           259  *******************************************************************************
00007000                           260  * The hard coded ROM exception vector table entries point to these individual
00007000                           261  * handlers that then jump to (actually RETurn to) the address specified in the
00007000                           262  * RAM exception vector table.
00007000                           263  *******************************************************************************
00007000                           264  
00007000                           265      ORG     (*+1)&-2    * make sure the table is word aligned
00007000                           266  
00007000                           267m jmpBusErr:  ramVecJump  $02
00007008                           268m jmpAddrErr: ramVecJump  $03
00007010                           269m jmpIllInst: ramVecJump  $04
00007018                           270m jmpZeroDiv: ramVecJump  $05
00007020                           271m jmpChkInst: ramVecJump  $06
00007028                           272m jmpTrapV:   ramVecJump  $07
00007030                           273m jmpPriv:    ramVecJump  $08
00007038                           274m jmpTrace:   ramVecJump  $09
00007040                           275m jmpLineA:   ramVecJump  $0A
00007048                           276m jmpLineF:   ramVecJump  $0B
00007050                           277m jmpRes1:    ramVecJump  $0C
00007058                           278m jmpRes2:    ramVecJump  $0D
00007060                           279m jmpRes3:    ramVecJump  $0E
00007068                           280m jmpUnInit:  ramVecJump  $0F
00007070                           281m jmpRes4:    ramVecJump  $10
00007078                           282m jmpRes5:    ramVecJump  $11
00007080                           283m jmpRes6:    ramVecJump  $12
00007088                           284m jmpRes7:    ramVecJump  $13
00007090                           285m jmpRes8:    ramVecJump  $14
00007098                           286m jmpRes9:    ramVecJump  $15
000070A0                           287m jmpRes10:   ramVecJump  $16
000070A8                           288m jmpRes11:   ramVecJump  $17
000070B0                           289m jmpSpur:    ramVecJump  $18
000070B8                           290m jmpAV1:     ramVecJump  $19
000070C0                           291m jmpAV2:     ramVecJump  $1A
000070C8                           292m jmpAV3:     ramVecJump  $1B
000070D0                           293m jmpAV4:     ramVecJump  $1C
000070D8                           294m jmpAV5:     ramVecJump  $1D
000070E0                           295m jmpAV6:     ramVecJump  $1E
000070E8                           296m jmpAV7:     ramVecJump  $1F
000070F0                           297m jmpTrap0:   ramVecJump  $20
000070F8                           298m jmpTrap1:   ramVecJump  $21
00007100                           299m jmpTrap2:   ramVecJump  $22
00007108                           300m jmpTrap3:   ramVecJump  $23
00007110                           301m jmpTrap4:   ramVecJump  $24
00007118                           302m jmpTrap5:   ramVecJump  $25
00007120                           303m jmpTrap6:   ramVecJump  $26
00007128                           304m jmpTrap7:   ramVecJump  $27
00007130                           305m jmpTrap8:   ramVecJump  $28
00007138                           306m jmpTrap9:   ramVecJump  $29
00007140                           307m jmpTrap10:  ramVecJump  $2A
00007148                           308m jmpTrap11:  ramVecJump  $2B
00007150                           309m jmpTrap12:  ramVecJump  $2C
00007158                           310m jmpTrap13:  ramVecJump  $2D
00007160                           311m jmpTrap14:  ramVecJump  $2E
00007168                           312m jmpTrap15:  ramVecJump  $2F
00007170                           313  
00007170                           314m jmpUnused:  ramVecJump  $30
00007178                           315  
00007178                           316  *******************************************************************************
00007178                           317  *
00007178                           318  *  ######     #    #     #       #     # #######  #####  ####### ####### ######   #####  
00007178                           319  *  #     #   # #   ##   ##       #     # #       #     #    #    #     # #     # #     # 
00007178                           320  *  #     #  #   #  # # # #       #     # #       #          #    #     # #     # #       
00007178                           321  *  ######  #     # #  #  #       #     # #####   #          #    #     # ######   #####  
00007178                           322  *  #   #   ####### #     #        #   #  #       #          #    #     # #   #         # 
00007178                           323  *  #    #  #     # #     #         # #   #       #     #    #    #     # #    #  #     # 
00007178                           324  *  #     # #     # #     #          #    #######  #####     #    ####### #     #  #####  
00007178                           325  *                                                                                       
00007178                           326  *******************************************************************************
00007178                           327  * 68000 RAM Exception Vector Table
00007178                           328  *
00007178                           329  * This is the initial exception vector table that gets copied into RAM.
00007178                           330  * It initially redirects back to the basic exception handlers in ROM until the
00007178                           331  * user program inserts their own exception handler address.
00007178                           332  *******************************************************************************
00007178                           333  
00007178                           334      ORG     (*+1)&-2       * make sure the table is word aligned
00007178                           335  
00007178                           336  ramIVT:
00007178= 001FF800                 337      DC.L    STACK_START    *00 Supervisor stack pointer
0000717C= 00007EE8                 338      DC.L    START          *01 Initial PC    
00007180                           339  
00007180= 00007578                 340      DC.L    handleBusErr   *02 Bus Error
00007184= 00007590                 341      DC.L    handleAddrErr  *03 Address Error
00007188= 000075A8                 342      DC.L    handleIllInst  *04 Illegal Instruction
0000718C= 000075B0                 343      DC.L    handleZeroDiv  *05 Zero Divide
00007190= 000075B8                 344      DC.L    handleChkInst  *06 CHK Instruction
00007194= 000075C0                 345      DC.L    handleTrapV    *07 TRAPV Instruction
00007198= 000075C8                 346      DC.L    handlePriv     *08 Privilege Violation
0000719C= 000075D0                 347      DC.L    handleTrace    *09 Trace
000071A0= 000075D8                 348      DC.L    handleLineA    *0A Line 1010 Emulator
000071A4= 000075E0                 349      DC.L    handleLineF    *0B Line 1111 Emulator
000071A8= 000075E8                 350      DC.L    handleRes1     *0C (Unassigned, Reserved)
000071AC= 000075E8                 351      DC.L    handleRes2     *0D (Unassigned, Reserved)
000071B0= 000075E8                 352      DC.L    handleRes3     *0E (Unassigned, Reserved)
000071B4= 000075F0                 353      DC.L    handleUnInit   *0F Uninitialized Interrupt Vector
000071B8= 000075E8                 354      DC.L    handleRes4     *10 (Unassigned, Reserved)
000071BC= 000075E8                 355      DC.L    handleRes5     *11 (Unassigned, Reserved)
000071C0= 000075E8                 356      DC.L    handleRes6     *12 (Unassigned, Reserved)
000071C4= 000075E8                 357      DC.L    handleRes7     *13 (Unassigned, Reserved)
000071C8= 000075E8                 358      DC.L    handleRes8     *14 (Unassigned, Reserved)
000071CC= 000075E8                 359      DC.L    handleRes9     *15 (Unassigned, Reserved)
000071D0= 000075E8                 360      DC.L    handleRes10    *16 (Unassigned, Reserved)
000071D4= 000075E8                 361      DC.L    handleRes11    *17 (Unassigned, Reserved)
000071D8= 000075F8                 362      DC.L    handleSpur     *18 Spurious Interrupt
000071DC= 00007600                 363      DC.L    handleAV1      *19 Level 1 Interrupt Autovector
000071E0= 00008338                 364      DC.L    serISR         *1A Level 2 Interrupt Autovector
000071E4= 00007610                 365      DC.L    handleAV3      *1B Level 3 Interrupt Autovector
000071E8= 00007618                 366      DC.L    handleAV4      *1C Level 4 Interrupt Autovector
000071EC= 00007620                 367      DC.L    handleAV5      *1D Level 5 Interrupt Autovector
000071F0= 00007628                 368      DC.L    handleAV6      *1E Level 6 Interrupt Autovector
000071F4= 00007630                 369      DC.L    handleAV7      *1F Level 7 Interrupt Autovector
000071F8= 00007638                 370      DC.L    handleTrap0    *20 TRAP #0  Instruction Vector
000071FC= 00007640                 371      DC.L    handleTrap1    *21 TRAP #1  Instruction Vector
00007200= 00007648                 372      DC.L    handleTrap2    *22 TRAP #2  Instruction Vector
00007204= 00007650                 373      DC.L    handleTrap3    *23 TRAP #3  Instruction Vector
00007208= 00007658                 374      DC.L    handleTrap4    *24 TRAP #4  Instruction Vector
0000720C= 00007660                 375      DC.L    handleTrap5    *25 TRAP #5  Instruction Vector
00007210= 00007668                 376      DC.L    handleTrap6    *26 TRAP #6  Instruction Vector
00007214= 00007670                 377      DC.L    handleTrap7    *27 TRAP #7  Instruction Vector
00007218= 00007678                 378      DC.L    handleTrap8    *28 TRAP #8  Instruction Vector
0000721C= 00007680                 379      DC.L    handleTrap9    *29 TRAP #9  Instruction Vector
00007220= 00007688                 380      DC.L    handleTrap10   *2A TRAP #10 Instruction Vector
00007224= 00007690                 381      DC.L    handleTrap11   *2B TRAP #11 Instruction Vector
00007228= 00007698                 382      DC.L    handleTrap12   *2C TRAP #12 Instruction Vector
0000722C= 000076A0                 383      DC.L    handleTrap13   *2D TRAP #13 Instruction Vector
00007230= 000076A8                 384      DC.L    handleTrap14   *2E TRAP #14 Instruction Vector
00007234= 000084DA                 385      DC.L    easy68kTrap15  *2F TRAP #15 Instruction Vector
00007238                           386  
00007238= 000076B8 000076B8 ...    387      DCB.L   208,handleUnused
00007578                           388  
00007578                           389  *******************************************************************************
00007578                           390  * Below are the actual exception handlers that the RAM based vector table
00007578                           391  * initially points to. The user can overwrite the RAM vector table addresses
00007578                           392  * with the address of their own exception handler. These basic handlers simply
00007578                           393  * write a message to the serial port and enter an endless loop.
00007578                           394  *******************************************************************************
00007578                           395  
00007578                           396  *------------------------------------------------------------------------------
00007578                           397  * BUS ERROR handler
00007578                           398  * Print a message showing the PC and address being accessed
00007578                           399  *------------------------------------------------------------------------------
00007578                           400  handleBusErr:
00007578  41FA 0372                401      lea     bemsg1(PC), a0      * A0 = first message address
0000757C  6100 0FC0                402      bsr.w   putString           * display it
00007580  202F 000A                403      move.l  10(a7),d0           * get the program counter 
00007584  6100 0F74                404      bsr.w   writeAddr32         * display it
00007588                           405      
00007588  41FA 03A1                406      lea     bemsg2(PC), a0      * A0 = second message address
0000758C  6000 0132                407      bra.w   handleCleanUp
00007590                           408      
00007590                           409  *------------------------------------------------------------------------------
00007590                           410  * ADDRESS ERROR handler
00007590                           411  * Print a message showing the PC and address being accessed
00007590                           412  *------------------------------------------------------------------------------
00007590                           413  handleAddrErr:
00007590  41FA 0140                414      lea     aemsg1(PC), a0      * A0 = first message address
00007594  6100 0FA8                415      bsr.w   putString           * display it
00007598  202F 000A                416      move.l  10(a7),d0           * get the program counter 
0000759C  6100 0F5C                417      bsr.w   writeAddr32         * display it
000075A0                           418      
000075A0  41FA 0174                419      lea     aemsg2(PC), a0      * A0 = second message address
000075A4  6000 011A                420      bra.w   handleCleanUp
000075A8                           421      
000075A8                           422  *------------------------------------------------------------------------------
000075A8                           423  * ILLEGAL INSTRUCTION handler
000075A8                           424  *------------------------------------------------------------------------------
000075A8                           425  handleIllInst:
000075A8  41FA 03E0                426      lea     iimsg(PC), a0       * A0 = address of message to display
000075AC  6000 0112                427      bra.w   handleCleanUp
000075B0                           428      
000075B0                           429  *------------------------------------------------------------------------------
000075B0                           430  * DIVISION BY ZERO handler
000075B0                           431  *------------------------------------------------------------------------------
000075B0                           432  handleZeroDiv:
000075B0  41FA 0901                433      lea     zdmsg(PC), a0       * A0 = address of message to display
000075B4  6000 010A                434      bra.w   handleCleanUp
000075B8                           435      
000075B8                           436  *------------------------------------------------------------------------------
000075B8                           437  * CHK handler
000075B8                           438  *------------------------------------------------------------------------------
000075B8                           439  handleChkInst:
000075B8  41FA 03A3                440      lea     cimsg(PC), a0       * A0 = address of message to display
000075BC  6000 0102                441      bra.w   handleCleanUp
000075C0                           442      
000075C0                           443  *------------------------------------------------------------------------------
000075C0                           444  * TRAPV handler
000075C0                           445  *------------------------------------------------------------------------------
000075C0                           446  handleTrapV:
000075C0  41FA 0853                447      lea     tvmsg(PC), a0       * A0 = address of message to display
000075C4  6000 00FA                448      bra.w   handleCleanUp
000075C8                           449      
000075C8                           450  *------------------------------------------------------------------------------
000075C8                           451  * PRIVILEGE VIOLATION handler
000075C8                           452  *------------------------------------------------------------------------------
000075C8                           453  handlePriv:
000075C8  41FA 045B                454      lea     pvmsg(PC), a0       * A0 = address of message to display
000075CC  6000 00F2                455      bra.w   handleCleanUp
000075D0                           456      
000075D0                           457  *------------------------------------------------------------------------------
000075D0                           458  * TRACE handler
000075D0                           459  *------------------------------------------------------------------------------
000075D0                           460  handleTrace:
000075D0  41FA 04FE                461      lea     trmsg(PC), a0       * A0 = address of message to display
000075D4  6000 00EA                462      bra.w   handleCleanUp
000075D8                           463      
000075D8                           464  *------------------------------------------------------------------------------
000075D8                           465  * Unimplementd Instruction - Line A handler
000075D8                           466  *------------------------------------------------------------------------------
000075D8                           467  handleLineA:
000075D8  41FA 03EB                468      lea     lamsg(PC), a0       * A0 = address of message to display
000075DC  6000 00E2                469      bra.w   handleCleanUp
000075E0                           470      
000075E0                           471  *------------------------------------------------------------------------------
000075E0                           472  * Unimplementd Instruction - Line F handler
000075E0                           473  *------------------------------------------------------------------------------
000075E0                           474  handleLineF:
000075E0  41FA 0413                475      lea     lfmsg(PC), a0       * A0 = address of message to display
000075E4  6000 00DA                476      bra.w   handleCleanUp
000075E8                           477      
000075E8                           478  *------------------------------------------------------------------------------
000075E8                           479  * Reserved Instruction handler
000075E8                           480  *------------------------------------------------------------------------------
000075E8                           481  handleRes1:
000075E8                           482  handleRes2:
000075E8                           483  handleRes3:
000075E8                           484  handleRes4:
000075E8                           485  handleRes5:
000075E8                           486  handleRes6:
000075E8                           487  handleRes7:
000075E8                           488  handleRes8:
000075E8                           489  handleRes9:
000075E8                           490  handleRes10:
000075E8                           491  handleRes11:
000075E8  41FA 0478                492      lea     rimsg(PC), a0       * A0 = address of message to display
000075EC  6000 00D2                493      bra.w   handleCleanUp
000075F0                           494      
000075F0                           495  *------------------------------------------------------------------------------
000075F0                           496  * Uninitialised Interrupt handler
000075F0                           497  *------------------------------------------------------------------------------
000075F0                           498  handleUnInit:
000075F0  41FA 0852                499      lea     uimsg(PC), a0       * A0 = address of message to display
000075F4  6000 00CA                500      bra.w   handleCleanUp
000075F8                           501      
000075F8                           502  *------------------------------------------------------------------------------
000075F8                           503  * Spurious Interrupt handler
000075F8                           504  *------------------------------------------------------------------------------
000075F8                           505  handleSpur:
000075F8  41FA 049A                506      lea     simsg(PC), a0       * A0 = address of message to display
000075FC  6000 00C2                507      bra.w   handleCleanUp
00007600                           508      
00007600                           509  *------------------------------------------------------------------------------
00007600                           510  * Autovector Level 1 Exception handler
00007600                           511  *------------------------------------------------------------------------------
00007600                           512  handleAV1:
00007600  41FA 0146                513      lea     av1msg(PC), a0      * A0 = address of message to display
00007604  6000 00BA                514      bra.w   handleCleanUp
00007608                           515  
00007608                           516  *------------------------------------------------------------------------------
00007608                           517  * Autovector Level 2 Exception handler
00007608                           518  *------------------------------------------------------------------------------
00007608                           519  handleAV2:
00007608  41FA 017A                520      lea     av2msg(PC), a0      * A0 = address of message to display
0000760C  6000 00B2                521      bra.w   handleCleanUp
00007610                           522  
00007610                           523  *------------------------------------------------------------------------------
00007610                           524  * Autovector Level 3 Exception handler
00007610                           525  *------------------------------------------------------------------------------
00007610                           526  handleAV3:
00007610  41FA 01AE                527      lea     av3msg(PC), a0      * A0 = address of message to display
00007614  6000 00AA                528      bra.w   handleCleanUp
00007618                           529  
00007618                           530  *------------------------------------------------------------------------------
00007618                           531  * Autovector Level 4 Exception handler
00007618                           532  *------------------------------------------------------------------------------
00007618                           533  handleAV4:
00007618  41FA 01E2                534      lea     av4msg(PC), a0      * A0 = address of message to display
0000761C  6000 00A2                535      bra.w   handleCleanUp
00007620                           536  
00007620                           537  *------------------------------------------------------------------------------
00007620                           538  * Autovector Level 5 Exception handler
00007620                           539  *------------------------------------------------------------------------------
00007620                           540  handleAV5:
00007620  41FA 0216                541      lea     av5msg(PC), a0      * A0 = address of message to display
00007624  6000 009A                542      bra.w   handleCleanUp
00007628                           543  
00007628                           544  *------------------------------------------------------------------------------
00007628                           545  * Autovector Level 6 Exception handler
00007628                           546  *------------------------------------------------------------------------------
00007628                           547  handleAV6:
00007628  41FA 024A                548      lea     av6msg(PC), a0      * A0 = address of message to display
0000762C  6000 0092                549      bra.w   handleCleanUp
00007630                           550  
00007630                           551  *------------------------------------------------------------------------------
00007630                           552  * Autovector Level 7 Exception handler
00007630                           553  *------------------------------------------------------------------------------
00007630                           554  handleAV7:
00007630  41FA 027E                555      lea     av7msg(PC), a0      * A0 = address of message to display
00007634  6000 008A                556      bra.w   handleCleanUp
00007638                           557      
00007638                           558  *------------------------------------------------------------------------------
00007638                           559  * TRAP #0 Exception handler
00007638                           560  *------------------------------------------------------------------------------
00007638                           561  handleTrap0:
00007638  41FA 04C5                562      lea     tr0msg(PC), a0      * A0 = address of message to display
0000763C  6000 0082                563      bra.w   handleCleanUp
00007640                           564  
00007640                           565  *------------------------------------------------------------------------------
00007640                           566  * TRAP #1 Exception handler
00007640                           567  *------------------------------------------------------------------------------
00007640                           568  handleTrap1:
00007640  41FA 04EE                569      lea     tr1msg(PC), a0      * A0 = address of message to display
00007644  6000 007A                570      bra.w   handleCleanUp
00007648                           571  
00007648                           572  *------------------------------------------------------------------------------
00007648                           573  * TRAP #2 Exception handler
00007648                           574  *------------------------------------------------------------------------------
00007648                           575  handleTrap2:
00007648  41FA 0517                576      lea     tr2msg(PC), a0      * A0 = address of message to display
0000764C  6000 0072                577      bra.w   handleCleanUp
00007650                           578  
00007650                           579  *------------------------------------------------------------------------------
00007650                           580  * TRAP #3 Exception handler
00007650                           581  *------------------------------------------------------------------------------
00007650                           582  handleTrap3:
00007650  41FA 0540                583      lea     tr3msg(PC), a0      * A0 = address of message to display
00007654  6000 006A                584      bra.w   handleCleanUp
00007658                           585  
00007658                           586  *------------------------------------------------------------------------------
00007658                           587  * TRAP #4 Exception handler
00007658                           588  *------------------------------------------------------------------------------
00007658                           589  handleTrap4:
00007658  41FA 0569                590      lea     tr4msg(PC), a0      * A0 = address of message to display
0000765C  6000 0062                591      bra.w   handleCleanUp
00007660                           592  
00007660                           593  *------------------------------------------------------------------------------
00007660                           594  * TRAP #5 Exception handler
00007660                           595  *------------------------------------------------------------------------------
00007660                           596  handleTrap5:
00007660  41FA 0592                597      lea     tr5msg(PC), a0      * A0 = address of message to display
00007664  6000 005A                598      bra.w   handleCleanUp
00007668                           599  
00007668                           600  *------------------------------------------------------------------------------
00007668                           601  * TRAP #6 Exception handler
00007668                           602  *------------------------------------------------------------------------------
00007668                           603  handleTrap6:
00007668  41FA 05BB                604      lea     tr6msg(PC), a0      * A0 = address of message to display
0000766C  6000 0052                605      bra.w   handleCleanUp
00007670                           606  
00007670                           607  *------------------------------------------------------------------------------
00007670                           608  * TRAP #7 Exception handler
00007670                           609  *------------------------------------------------------------------------------
00007670                           610  handleTrap7:
00007670  41FA 05E4                611      lea     tr7msg(PC), a0      * A0 = address of message to display
00007674  6000 004A                612      bra.w   handleCleanUp
00007678                           613  
00007678                           614  *------------------------------------------------------------------------------
00007678                           615  * TRAP #8 Exception handler
00007678                           616  *------------------------------------------------------------------------------
00007678                           617  handleTrap8:
00007678  41FA 060D                618      lea     tr8msg(PC), a0      * A0 = address of message to display
0000767C  6000 0042                619      bra.w   handleCleanUp
00007680                           620  
00007680                           621  *------------------------------------------------------------------------------
00007680                           622  * TRAP #9 Exception handler
00007680                           623  *------------------------------------------------------------------------------
00007680                           624  handleTrap9:
00007680  41FA 0636                625      lea     tr9msg(PC), a0      * A0 = address of message to display
00007684  6000 003A                626      bra.w   handleCleanUp
00007688                           627  
00007688                           628  *------------------------------------------------------------------------------
00007688                           629  * TRAP #10 Exception handler
00007688                           630  *------------------------------------------------------------------------------
00007688                           631  handleTrap10:
00007688  41FA 065F                632      lea     tr10msg(PC), a0     * A0 = address of message to display
0000768C  6000 0032                633      bra.w   handleCleanUp
00007690                           634  
00007690                           635  *------------------------------------------------------------------------------
00007690                           636  * TRAP #11 Exception handler
00007690                           637  *------------------------------------------------------------------------------
00007690                           638  handleTrap11:
00007690  41FA 0689                639      lea     tr11msg(PC), a0     * A0 = address of message to display
00007694  6000 002A                640      bra.w   handleCleanUp
00007698                           641  
00007698                           642  *------------------------------------------------------------------------------
00007698                           643  * TRAP #12 Exception handler
00007698                           644  *------------------------------------------------------------------------------
00007698                           645  handleTrap12:
00007698  41FA 06B3                646      lea     tr12msg(PC), a0     * A0 = address of message to display
0000769C  6000 0022                647      bra.w   handleCleanUp
000076A0                           648      
000076A0                           649  *------------------------------------------------------------------------------
000076A0                           650  * TRAP #13 Exception handler
000076A0                           651  *------------------------------------------------------------------------------
000076A0                           652  handleTrap13:
000076A0  41FA 06DD                653      lea     tr13msg(PC), a0     * A0 = address of message to display
000076A4  6000 001A                654      bra.w   handleCleanUp
000076A8                           655      
000076A8                           656  *------------------------------------------------------------------------------
000076A8                           657  * TRAP #14 Exception handler
000076A8                           658  *------------------------------------------------------------------------------
000076A8                           659  handleTrap14:
000076A8  41FA 0707                660      lea     tr14msg(PC), a0     * A0 = address of message to display
000076AC  6000 0012                661      bra.w   handleCleanUp
000076B0                           662      
000076B0                           663  *------------------------------------------------------------------------------
000076B0                           664  * TRAP #15 Exception handler
000076B0                           665  *------------------------------------------------------------------------------
000076B0                           666  handleTrap15:
000076B0  41FA 0731                667      lea     tr15msg(PC), a0     * A0 = address of message to display
000076B4  6000 000A                668      bra.w   handleCleanUp
000076B8                           669      
000076B8                           670  *------------------------------------------------------------------------------
000076B8                           671  * User Exception handler - all remaining exception handlers land here
000076B8                           672  *------------------------------------------------------------------------------
000076B8                           673  handleUnused:
000076B8  41FA 07CB                674      lea     usermsg(PC), a0     * A0 = address of message to display
000076BC  6000 0002                675      bra.w   handleCleanUp
000076C0                           676      
000076C0                           677  *------------------------------------------------------------------------------
000076C0                           678  * All exception handlers jump here to output the PC of the next instruction
000076C0                           679  * after the exception occured.
000076C0                           680  * A0 holds the address of a null terminated message to be displayed first.
000076C0                           681  *------------------------------------------------------------------------------
000076C0                           682  handleCleanUp:
000076C0  6100 0E7C                683      bsr.w   putString           * print out the relevant message
000076C4  202F 0002                684      move.l  2(a7),d0            * get the saved PC address
000076C8  6100 0E30                685      bsr.w   writeAddr32         * and display it
000076CC  6100 0E6C                686      bsr.w   putCRLF
000076D0                           687  .infloop:
000076D0  60FE                     688      bra.s   .infloop            * and stay here forever ...
000076D2                           689  
000076D2                           690  *******************************************************************************
000076D2                           691  * Exception handler messages
000076D2                           692  *******************************************************************************
000076D2= 0A 0D 53 54 4F 50 ...    693  aemsg1:  dc.b   10,13,'STOP: An Address Error occured whilst executing code at address $',0
00007716= 0A 0D 53 54 4F 50 ...    694  aemsg2:  dc.b   10,13,'STOP: The address location being accessed was $',0
00007748= 0A 0D 53 54 4F 50 ...    695  av1msg:  dc.b   10,13,'STOP: Autovector Level 1 exception occured near address $',0
00007784= 0A 0D 53 54 4F 50 ...    696  av2msg:  dc.b   10,13,'STOP: Autovector Level 2 exception occured near address $',0
000077C0= 0A 0D 53 54 4F 50 ...    697  av3msg:  dc.b   10,13,'STOP: Autovector Level 3 exception occured near address $',0
000077FC= 0A 0D 53 54 4F 50 ...    698  av4msg:  dc.b   10,13,'STOP: Autovector Level 4 exception occured near address $',0
00007838= 0A 0D 53 54 4F 50 ...    699  av5msg:  dc.b   10,13,'STOP: Autovector Level 5 exception occured near address $',0
00007874= 0A 0D 53 54 4F 50 ...    700  av6msg:  dc.b   10,13,'STOP: Autovector Level 6 exception occured near address $',0
000078B0= 0A 0D 53 54 4F 50 ...    701  av7msg:  dc.b   10,13,'STOP: Autovector Level 7 exception occured near address $',0
000078EC= 0A 0D 53 54 4F 50 ...    702  bemsg1:  dc.b   10,13,'STOP: A Bus Error occured whilst executing code at address $',0
0000792B= 0A 0D 20 20 20 20 ...    703  bemsg2:  dc.b   10,13,'    : The address location being accessed was $',0
0000795D= 0A 0D 53 54 4F 50 ...    704  cimsg:   dc.b   10,13,'STOP: CHK exception occured near address $',0
0000798A= 0A 0D 53 54 4F 50 ...    705  iimsg:   dc.b   10,13,'STOP: Illegal Instruction was encountered near address $',0
000079C5= 0A 0D 53 54 4F 50 ...    706  lamsg:   dc.b   10,13,'STOP: LINE A exception occured near address $',0
000079F5= 0A 0D 53 54 4F 50 ...    707  lfmsg:   dc.b   10,13,'STOP: LINE F exception occured near address $',0
00007A25= 0A 0D 53 54 4F 50 ...    708  pvmsg:   dc.b   10,13,'STOP: Privilege Viloation exception occured near address $',0
00007A62= 0A 0D 53 54 4F 50 ...    709  rimsg:   dc.b   10,13,'STOP: Reserved exception occured near address $',0
00007A94= 0A 0D 53 54 4F 50 ...    710  simsg:   dc.b   10,13,'STOP: Spurious Interrupt exception occured near address $',0
00007AD0= 0A 0D 53 54 4F 50 ...    711  trmsg:   dc.b   10,13,'STOP: TRACE exception occured near address $',0
00007AFF= 0A 0D 53 54 4F 50 ...    712  tr0msg:  dc.b   10,13,'STOP: TRAP #0 exception occured near address $',0
00007B30= 0A 0D 53 54 4F 50 ...    713  tr1msg:  dc.b   10,13,'STOP: TRAP #1 exception occured near address $',0
00007B61= 0A 0D 53 54 4F 50 ...    714  tr2msg:  dc.b   10,13,'STOP: TRAP #2 exception occured near address $',0
00007B92= 0A 0D 53 54 4F 50 ...    715  tr3msg:  dc.b   10,13,'STOP: TRAP #3 exception occured near address $',0
00007BC3= 0A 0D 53 54 4F 50 ...    716  tr4msg:  dc.b   10,13,'STOP: TRAP #4 exception occured near address $',0
00007BF4= 0A 0D 53 54 4F 50 ...    717  tr5msg:  dc.b   10,13,'STOP: TRAP #5 exception occured near address $',0
00007C25= 0A 0D 53 54 4F 50 ...    718  tr6msg:  dc.b   10,13,'STOP: TRAP #6 exception occured near address $',0
00007C56= 0A 0D 53 54 4F 50 ...    719  tr7msg:  dc.b   10,13,'STOP: TRAP #7 exception occured near address $',0
00007C87= 0A 0D 53 54 4F 50 ...    720  tr8msg:  dc.b   10,13,'STOP: TRAP #8 exception occured near address $',0
00007CB8= 0A 0D 53 54 4F 50 ...    721  tr9msg:  dc.b   10,13,'STOP: TRAP #9 exception occured near address $',0
00007CE9= 0A 0D 53 54 4F 50 ...    722  tr10msg: dc.b   10,13,'STOP: TRAP #10 exception occured near address $',0
00007D1B= 0A 0D 53 54 4F 50 ...    723  tr11msg: dc.b   10,13,'STOP: TRAP #11 exception occured near address $',0
00007D4D= 0A 0D 53 54 4F 50 ...    724  tr12msg: dc.b   10,13,'STOP: TRAP #12 exception occured near address $',0
00007D7F= 0A 0D 53 54 4F 50 ...    725  tr13msg: dc.b   10,13,'STOP: TRAP #13 exception occured near address $',0
00007DB1= 0A 0D 53 54 4F 50 ...    726  tr14msg: dc.b   10,13,'STOP: TRAP #14 exception occured near address $',0
00007DE3= 0A 0D 53 54 4F 50 ...    727  tr15msg: dc.b   10,13,'STOP: TRAP #15 exception occured near address $',0
00007E15= 0A 0D 53 54 4F 50 ...    728  tvmsg:   dc.b   10,13,'STOP: TRAPV exception occured near address $',0
00007E44= 0A 0D 53 54 4F 50 ...    729  uimsg:   dc.b   10,13,'STOP: Uninitialised Interrupt exception occured near address $',0
00007E85= 0A 0D 53 54 4F 50 ...    730  usermsg: dc.b   10,13,'STOP: User exception occured near address $',0
00007EB3= 0A 0D 53 54 4F 50 ...    731  zdmsg:   dc.b   10,13,'STOP: Divide By Zero error occured near address $',0
00007EE7                           732  
00007EE7                           733  *******************************************************************************
00007EE7                           734  *
00007EE7                           735  *   #####  ####### #       ######         #####  #######    #    ######  ####### 
00007EE7                           736  *  #     # #     # #       #     #       #     #    #      # #   #     #    #    
00007EE7                           737  *  #       #     # #       #     #       #          #     #   #  #     #    #    
00007EE7                           738  *  #       #     # #       #     #        #####     #    #     # ######     #    
00007EE7                           739  *  #       #     # #       #     #             #    #    ####### #   #      #    
00007EE7                           740  *  #     # #     # #       #     #       #     #    #    #     # #    #     #    
00007EE7                           741  *   #####  ####### ####### ######         #####     #    #     # #     #    #    
00007EE7                           742  *                                                                               
00007EE7                           743  *******************************************************************************
00007EE7                           744  * Monitor execution starts here after power-on or a reset.
00007EE7                           745  *******************************************************************************
00007EE7                           746  
00007EE8                           747      ORG     (*+1)&-2    * make sure we start on a word aligned address
00007EE8                           748  START:
00007EE8  4FF9 001FF800            749      lea     STACK_START, sp     * Set the stack pointer just in case
00007EEE                           750  
00007EEE                           751      * copy the RAM exception vector table into RAM
00007EEE  207C 00007178            752      move.l  #ramIVT,a0          * start of RAM exception table in ROM
00007EF4  227C 00100000            753      move.l  #VEC_BASE,a1        * location in RAM to copy table to
00007EFA  203C 000000FF            754      move.l  #255,d0             * 256 entries to copy
00007F00                           755  .copy:
00007F00  22D8                     756      move.l  (a0)+,(a1)+         * copy the byte from ROM to RAM
00007F02  51C8 FFFC                757      dbra    d0,.copy
00007F06                           758  
00007F06  6100 03C6                759      bsr.w   serInit             * initialise serial port
00007F0A  46FC 2000                760      move.w  #$2000,sr           * enable interrupts
00007F0E                           761  
00007F0E                           762  *------------------------------------------------------------------------------
00007F0E                           763  * Warm Restart entry point
00007F0E                           764  *------------------------------------------------------------------------------
00007F0E                           765  monStart:
00007F0E  41FA 063A                766      lea     strBanner1(PC), a0  * Show the monitor details
00007F12  6100 062A                767      bsr.w   putString
00007F16                           768  
00007F16  41FA 0690                769      lea     strCommands(PC), a0 * And the command help message
00007F1A  6100 0622                770      bsr.w   putString
00007F1E                           771  
00007F1E                           772  monLoop:
00007F1E  41FA 0812                773      lea     strPrompt(PC), a0   * Prompt
00007F22  6100 061A                774      bsr.w   putString
00007F26                           775  
00007F26                           776  monLoop_NP:
00007F26  6100 0480                777      bsr.w   getc                * get a character into D0
00007F2A  6100 0306                778      bsr.w   chToUpper           * convert character to upper case
00007F2E                           779      
00007F2E  0C00 000A                780      cmpi.b  #LF,d0              * ignore Line-Feed
00007F32  67EA                     781      beq.s   monLoop
00007F34                           782      
00007F34  B03C 0042                783      cmp.b   #'B', d0            * Boot EhBASIC v3.54
00007F38  6700 0056                784      beq.w   cmdBootEHBASIC
00007F3C                           785  
00007F3C  B03C 0044                786      cmp.b   #'D', d0            * Dump memory command
00007F40  6700 0076                787      beq.w   cmdDispMemory
00007F44                           788  
00007F44  B03C 0049                789      cmp.b   #'I', d0            * Read from I/O space address
00007F48  6700 00B8                790      beq.w   cmdIORead
00007F4C                           791  
00007F4C  B03C 004D                792      cmp.b   #'M', d0            * Modify memory command
00007F50  6700 00F2                793      beq.w   cmdModifyMemory
00007F54                           794  
00007F54  B03C 004F                795      cmp.b   #'O', d0            * Write to I/O space address
00007F58  6700 0148                796      beq.w   cmdIOWrite
00007F5C                           797  
00007F5C  B03C 0053                798      cmp.b   #'S', d0            * S record download
00007F60  6700 018A                799      beq.w   cmdDownload
00007F64                           800  
00007F64  B03C 0047                801      cmp.b   #'G', d0            * Go command
00007F68  6700 0070                802      beq.w   cmdRun
00007F6C                           803  
00007F6C  B03C 003F                804      cmp.b   #'?', d0            * Help command
00007F70  6700 024E                805      beq.w   cmdHelp
00007F74                           806  
00007F74  B03C 0020                807      cmp.b   #' ', d0            * Ignore spaces
00007F78  6FAC                     808      ble.s   monLoop_NP          * go back without printing prompt    
00007F7A                           809  
00007F7A  1200                     810      move.b  d0,d1               * save the unknown char
00007F7C  41FA 07B7                811      lea     strUnkCmd(PC), a0   * unknown command
00007F80  6100 05BC                812      bsr.w   putString
00007F84  1001                     813      move.b  d1,d0               * get unnknown char back
00007F86  6100 0590                814      bsr.w   writeByte           * print it
00007F8A                           815      
00007F8A                           816  monLoop_CRLF:
00007F8A  6100 05AE                817      bsr.w   putCRLF
00007F8E  608E                     818      bra.s   monLoop
00007F90                           819      
00007F90                           820  *------------------------------------------------------------------------------
00007F90                           821  * (B) Boot EhBASIC v3.54
00007F90                           822  *------------------------------------------------------------------------------
00007F90                           823  cmdBootEHBASIC:
00007F90                           824      * perform a simple check to see if EhBASIC has been programmed into the
00007F90                           825      * EEPROM by reading address 0x9000 in the EEPROM. If it contains 0xFFFF,
00007F90                           826      * then EhBASIC hasn't been programmed in!
00007F90  0C79 FFFF 00009000       827      cmpi.w  #$FFFF,EHBASIC_BASE
00007F98  660C                     828      bne.s   .bootEHBASIC
00007F9A  41FA 081C                829      lea     strBASICErr1(PC), a0
00007F9E  6100 059E                830      bsr.w   putString
00007FA2  6000 FF7A                831      bra.w   monLoop
00007FA6                           832  
00007FA6                           833  .bootEHBASIC:
00007FA6  207C 00009000            834      move.l  #EHBASIC_BASE,a0
00007FAC  4E90                     835      jsr     (a0)                * jump to EhBASIC 
00007FAE                           836  
00007FAE                           837      * I don't think EhBASIC can return back to the monitor but just in case it can
00007FAE                           838      * print out a message and wait for a reset.
00007FAE  41FA 083E                839      lea     strBASICReturn(PC), a0
00007FB2  6100 058A                840      bsr.w   putString
00007FB6                           841  .forever:
00007FB6  60FE                     842      bra.s   .forever
00007FB8                           843  
00007FB8                           844  *------------------------------------------------------------------------------
00007FB8                           845  * (D)ump memory
00007FB8                           846  * Display 256 bytes of memory as ASCII-HEX characters
00007FB8                           847  *------------------------------------------------------------------------------
00007FB8                           848  cmdDispMemory:
00007FB8  6100 03DC                849      bsr.w   putc                * echo back the command character in D0
00007FBC  103C 0020                850      move.b  #' ',d0
00007FC0  6100 03D4                851      bsr.w   putc
00007FC4                           852      
00007FC4  4282                     853      clr.l   d2                  * pre-set D2 to 0
00007FC6  7208                     854      move.l  #8,d1               * read up to 8 digits
00007FC8  6100 02C6                855      bsr.w   hexToIntEcho        * from the serial port into D0
00007FCC  6500 FF50                856      bcs.w   monLoop             * back to prompt if there's an error
00007FD0                           857      
00007FD0  2040                     858      move.l  d0,a0               * A0 holds the start address
00007FD2  6100 01F8                859      bsr.w   dumpRAM
00007FD6                           860  
00007FD6  6000 FF46                861      bra.w   monLoop
00007FDA                           862  
00007FDA                           863  *------------------------------------------------------------------------------
00007FDA                           864  * (G)o - execute code in memory starting at the specified address
00007FDA                           865  *------------------------------------------------------------------------------
00007FDA                           866  cmdRun:
00007FDA  6100 03BA                867      bsr.w   putc                * echo back the command character in D0
00007FDE  103C 0020                868      move.b  #' ',d0
00007FE2  6100 03B2                869      bsr.w   putc
00007FE6                           870  
00007FE6  4282                     871      clr.l   d2                  * pre-set D2 to 0
00007FE8  7208                     872      move.l  #8,d1               * read up to 8 digits
00007FEA  6100 02A4                873      bsr.w   hexToIntEcho        * from the serial port
00007FEE  6500 FF2E                874      bcs.w   monLoop             * back to prompt if there's an error
00007FF2                           875  
00007FF2  2040                     876      move.l  d0, a0              * copy start address into A0
00007FF4  4E90                     877      jsr     (a0)                * jump to user code
00007FF6                           878      
00007FF6  41FA 076C                879      lea     strUserReturn(PC),a0
00007FFA  6100 0542                880      bsr.w   putString
00007FFE                           881      
00007FFE  6000 FF1E                882      bra.w   monLoop
00008002                           883  
00008002                           884  *------------------------------------------------------------------------------
00008002                           885  * (I)nput a byte from I/O space address
00008002                           886  *------------------------------------------------------------------------------
00008002                           887  cmdIORead:
00008002  6100 0392                888      bsr.w   putc                * echo back the command character in D0
00008006  103C 0020                889      move.b  #' ',d0
0000800A  6100 038A                890      bsr.w   putc
0000800E                           891  
0000800E  4282                     892      clr.l   d2                  * pre-set D2 to 0
00008010  7202                     893      move.l  #2,d1               * read up to 2 digit address
00008012  6100 027C                894      bsr.w   hexToIntEcho        * from the serial port
00008016  6500 FF06                895      bcs.w   monLoop             * back to prompt if there's an error
0000801A  1600                     896      move.b  d0,d3               * save the typed in 8-bit address
0000801C  103C 003D                897      move.b  #'=',d0
00008020  6100 0374                898      bsr.w   putc                * send an EQUALS
00008024                           899  
00008024                           900      ; D3 = 8-bit address
00008024  207C 00F80000            901      movea.l #IO_BASE,a0
0000802A  0283 000000FF            902      andi.l  #$FF,d3             * clear all the unused bits
00008030  E383                     903      asl.l   #1,d3               * make it a word offset
00008032  5283                     904      addi.l  #1,d3               * make it an odd address to read from D0..D7
00008034  1030 3000                905      move.b  (0,a0,d3),d0        * and read the new value in
00008038  6100 04DE                906      bsr.w   writeByte           * display the value
0000803C  6100 04FC                907      bsr.w   putCRLF
00008040  6000 FEDC                908      bra.w   monLoop
00008044                           909  
00008044                           910  *------------------------------------------------------------------------------
00008044                           911  * (M)odify memory
00008044                           912  * Change memory contents 1 byte at a time
00008044                           913  *------------------------------------------------------------------------------
00008044                           914  cmdModifyMemory:
00008044  6100 0350                915      bsr.w   putc                * echo back the command character in D0
00008048  103C 0020                916      move.b  #' ',d0
0000804C  6100 0348                917      bsr.w   putc
00008050                           918  
00008050  4282                     919      clr.l   d2                  * pre-set D2 to 0
00008052  7208                     920      move.l  #8,d1               * read up to 8 digits
00008054  6100 023A                921      bsr.w   hexToIntEcho        * from the serial port
00008058  6500 FEC4                922      bcs.w   monLoop             * back to prompt if there's an error
0000805C  1200                     923      move.b  d0,d1               * save the typed in address
0000805E  6100 04DA                924      bsr.w   putCRLF
00008062  1001                     925      move.b  d1,d0               * restore the typed in address
00008064                           926      
00008064  2040                     927      move.l  d0,a0               * copy address into A0
00008066                           928  .cMM_1:
00008066  6100 0492                929      bsr.w   writeAddr32         * display the memory location address
0000806A  103C 0020                930      move.b  #' ',d0
0000806E  6100 0326                931      bsr.w   putc
00008072  1010                     932      move.b  (a0),d0             * get the current memory contents
00008074  1400                     933      move.b  d0,d2               * pre-set D2 to the existing memory value
00008076  6100 04A0                934      bsr.w   writeByte           * display the byte
0000807A  103C 0020                935      move.b  #' ',d0
0000807E  6100 0316                936      bsr.w   putc
00008082  7202                     937      move.l  #2,d1               * read up to 2 digits
00008084  6100 020A                938      bsr.w   hexToIntEcho        * from the serial port
00008088  6500 0010                939      bcs.w   .cMM_2              * back to prompt if there's an error
0000808C                           940  
0000808C  10C0                     941      move.b  d0,(a0)+            * write out the new byte and move on
0000808E  2F08                     942      move.l  a0,-(SP)            * save our address
00008090  6100 04A8                943      bsr.w   putCRLF
00008094  205F                     944      move.l  (SP)+,a0            * restore our address
00008096  2008                     945      move.l  a0,d0               * copy address back into D0 for printing
00008098  60CC                     946      bra.s   .cMM_1
0000809A                           947  
0000809A                           948  .cMM_2:
0000809A  6100 049E                949      bsr.w   putCRLF
0000809E  6000 FE7E                950      bra.w   monLoop
000080A2                           951      
000080A2                           952  *------------------------------------------------------------------------------
000080A2                           953  * (O)utput a byte to I/O space address
000080A2                           954  *------------------------------------------------------------------------------
000080A2                           955  cmdIOWrite:
000080A2  6100 02F2                956      bsr.w   putc                * echo back the command character in D0
000080A6  103C 0020                957      move.b  #' ',d0
000080AA  6100 02EA                958      bsr.w   putc
000080AE                           959  
000080AE  4282                     960      clr.l   d2                  * pre-set D2 to 0
000080B0  7202                     961      move.l  #2,d1               * read up to 2 digit address
000080B2  6100 01DC                962      bsr.w   hexToIntEcho        * from the serial port
000080B6  6500 FE66                963      bcs.w   monLoop             * back to prompt if there's an error
000080BA  1600                     964      move.b  d0,d3               * save the typed in 8-bit address
000080BC  103C 003D                965      move.b  #'=',d0
000080C0  6100 02D4                966      bsr.w   putc                * send an EQUALS
000080C4                           967  
000080C4  4282                     968      clr.l   d2                  * pre-set D2 to 0
000080C6  7202                     969      move.l  #2,d1               * read up to 2 digit value
000080C8  6100 01C6                970      bsr.w   hexToIntEcho        * from the serial port
000080CC  6500 FE50                971      bcs.w   monLoop             * back to prompt if there's an error
000080D0                           972  
000080D0                           973      ; D0 = value and D3 = 8-bit address
000080D0  207C 00F80000            974      movea.l #IO_BASE,a0
000080D6  0283 000000FF            975      andi.l  #$FF,d3             * clear all the unused bits
000080DC  E383                     976      asl.l   #1,d3               * make it a word offset
000080DE  5283                     977      addi.l  #1,d3               * make it an odd address to write to D0..D7
000080E0  1180 3000                978      move.b  d0,(0,a0,d3)        * and write the new value out
000080E4                           979  
000080E4  6100 0454                980      bsr.w   putCRLF
000080E8  6000 FE34                981      bra.w   monLoop
000080EC                           982  
000080EC                           983  *------------------------------------------------------------------------------
000080EC                           984  * (S) - download a single line of a Motorola S-Record
000080EC                           985  *------------------------------------------------------------------------------
000080EC                           986  cmdDownload:
000080EC  6100 02BA                987      bsr.w   getc                * get the S-Record type
000080F0  B03C 0031                988      cmp.b   #'1', d0
000080F4  671A                     989      beq.s   .cdl_S1             * read in an S1 record
000080F6  B03C 0032                990      cmp.b   #'2', d0
000080FA  6738                     991      beq.s   .cdl_S2             * read in an S2 record
000080FC  B03C 0038                992      cmp.b   #'8', d0
00008100  6700 00A8                993      beq.w   .cdl_EOL89          * handle S8 SRec terminator
00008104  B03C 0039                994      cmp.b   #'9', d0
00008108  6700 00A0                995      beq.w   .cdl_EOL89          * handle S9 SRec terminator
0000810C                           996  
0000810C  6600 008A                997      bne     .cdl_EOL            * not S1 or S2 so ignore to end of line
00008110                           998              
00008110                           999  .cdl_S1:        
00008110  4282                    1000      clr.l   d2
00008112  123C 0002               1001      move.b  #2, d1              * 2 characters to read
00008116  6100 013E               1002      bsr     hexToInt            * convert to byte count
0000811A  2C00                    1003      move.l  d0, d6              * D6 = byte count
0000811C  2E00                    1004      move.l  d0, d7              * D7 = byte count (running checksum)
0000811E                          1005  
0000811E  4282                    1006      clr.l   d2
00008120  123C 0004               1007      move.b  #4, d1              * 4 characters to read
00008124  6100 0130               1008      bsr     hexToInt            * convert to address
00008128  2640                    1009      movea.l d0, a3              * A3 = destination address
0000812A  DE00                    1010      add.b   d0, d7              * update checksum with bits 00..07
0000812C  E088                    1011      lsr.l   #8, d0
0000812E  DE00                    1012      add.b   d0, d7              * update checksum with bits 08..15
00008130                          1013  
00008130  5746                    1014      subq.w  #3, D6              * take off the 3 bytes we just read in
00008132                          1015  
00008132  6026                    1016      bra.s   .cdl_1              
00008134                          1017                  
00008134                          1018  .cdl_S2:            
00008134  4282                    1019      clr.l   d2
00008136  123C 0002               1020      move.b  #2, d1              * 2 characters to read
0000813A  6100 011A               1021      bsr     hexToInt            * convert to byte count
0000813E  2C00                    1022      move.l  d0, d6              * D6 = byte count
00008140  2E00                    1023      move.l  d0, d7              * D7 = byte count (running checksum)
00008142                          1024  
00008142  4282                    1025      clr.l   d2
00008144  123C 0006               1026      move.b  #6, d1              * 6 characters to read
00008148  6100 010C               1027      bsr     hexToInt            * convert to address
0000814C  2640                    1028      movea.l d0, a3              * A3 = destination address
0000814E  DE00                    1029      add.b   d0, d7              * update checksum with bits 00..07
00008150  E088                    1030      lsr.l   #8, d0
00008152  DE00                    1031      add.b   d0, d7              * update checksum with bits 08..15
00008154  E088                    1032      lsr.l   #8, d0
00008156  DE00                    1033      add.b   d0, d7              * update checksum with bits 16..23
00008158                          1034  
00008158  5946                    1035      subq.w  #4, d6              * take off the 4 bytes we just read in
0000815A                          1036  
0000815A                          1037  .cdl_1:
0000815A  4A46                    1038      tst.w   d6                  * read all the bytes yet?
0000815C  6712                    1039      beq.s   .cdl_2
0000815E                          1040  
0000815E  4282                    1041      clr.l   d2
00008160  323C 0002               1042      move.w  #2, d1              * 2 characters to read
00008164  6100 00F0               1043      bsr     hexToInt            * convert to data byte
00008168  16C0                    1044      move.b  d0, (a3)+           * write the byte to memory
0000816A  DE00                    1045      add.b   d0, d7              * update checksum
0000816C  5346                    1046      subq.w  #1, d6              * decrement byte count
0000816E  60EA                    1047      bra.s   .cdl_1
00008170                          1048  
00008170                          1049  .cdl_2:
00008170  4282                    1050      clr.l   d2
00008172  323C 0002               1051      move.w  #2, d1              * 2 characters to read
00008176  6100 00DE               1052      bsr     hexToInt            * convert to checksum byte
0000817A  DE00                    1053      add.b   d0, d7              * D7 = calc checksum + srec checksum
0000817C  5207                    1054      addq.b  #1, d7              * checksum + 1 should = 0 if OK
0000817E  670C                    1055      beq.s   .cdl_X
00008180                          1056  
00008180  103C 0058               1057      move.b  #'X', d0            * checksum fail - print an X
00008184  6100 0210               1058      bsr     putc
00008188  6000 FD9C               1059      bra.w   monLoop_NP          * return to main loop without prompt
0000818C                          1060  
0000818C                          1061  .cdl_X
0000818C  103C 002E               1062      move.b  #'.', d0            * checksum good - print a dot
00008190  6100 0204               1063      bsr     putc
00008194  6000 FD90               1064      bra.w   monLoop_NP          * return to main loop without prompt
00008198                          1065  
00008198                          1066  .cdl_EOL
00008198  6100 020E               1067      bsr.w   getc                * discard chars until CR or LF
0000819C  0C00 000D               1068      cmpi.b  #CR,d0
000081A0  67EA                    1069      beq.s   .cdl_X
000081A2  0C00 000A               1070      cmpi.b  #LF,d0
000081A6  67E4                    1071      beq.s   .cdl_X
000081A8  60EE                    1072      bra.s   .cdl_EOL
000081AA                          1073  
000081AA                          1074  .cdl_EOL89
000081AA  6100 01FC               1075      bsr.w   getc                * discard chars until CR or LF
000081AE  0C00 000D               1076      cmpi.b  #CR,d0
000081B2  6700 FDD6               1077      beq.w   monLoop_CRLF        * return to main loop with prompt
000081B6  0C00 000A               1078      cmpi.b  #LF,d0
000081BA  6700 FDCE               1079      beq.w   monLoop_CRLF        * return to main loop with prompt
000081BE  60EA                    1080      bra.s   .cdl_EOL89
000081C0                          1081      
000081C0                          1082  *------------------------------------------------------------------------------
000081C0                          1083  * Display the supported commands
000081C0                          1084  *------------------------------------------------------------------------------
000081C0                          1085  cmdHelp:
000081C0  41FA 03E6               1086      lea     strCommands(PC), a0
000081C4  6100 0378               1087      bsr.w   putString
000081C8  6000 FD54               1088      bra.w   monLoop
000081CC                          1089  
000081CC                          1090  *------------------------------------------------------------------------------
000081CC                          1091  * Dumps a 256 section of RAM to the screen
000081CC                          1092  * Displays both hex values and ASCII characters
000081CC                          1093  * a0 - Start Address
000081CC                          1094  *------------------------------------------------------------------------------
000081CC                          1095  dumpRAM:
000081CC  48E7 E040               1096      movem.l d0-d2/a1, -(SP)     * Save registers
000081D0  2248                    1097      move.l  a0,a1               * move the start address to A1
000081D2                          1098  
000081D2  6100 0366               1099      bsr.w   putCRLF             * new line - trashes D0 & A0
000081D6                          1100      
000081D6  323C 000F               1101      move.w  #15,d1              * 16 rows of data (DBRA needs 1 less!)
000081DA                          1102  .dr_1:
000081DA  343C 000F               1103      move.w  #15,d2              * 16 bytes of data per row (DBRA needs 1 less!)
000081DE  2009                    1104      move.l  a1, d0              * copy the start address of the line into D0          
000081E0  6100 0318               1105      bsr.w   writeAddr32         * Display as a 32-bit hex value
000081E4  41FA 0564               1106      lea     strColonSpace(PC), a0
000081E8  6100 0354               1107      bsr.w   putString
000081EC  41F9 001FF906           1108      lea     msgASCIIDump, a0
000081F2                          1109  .dr_2:
000081F2  1019                    1110      move.b  (a1)+, d0           * Read a byte from RAM
000081F4  6100 0322               1111      bsr.w   writeByte           * display byte as 2 hex digits  
000081F8  6100 004A               1112      bsr.w   makePrintable       * convert to printable character
000081FC  10C0                    1113      move.b  d0,(a0)+            * save the printable char in output string
000081FE  103C 0020               1114      move.b  #' ', d0
00008202  6100 0192               1115      bsr.w   putc                * insert a space
00008206  51CA FFEA               1116      dbra    d2,.dr_2
0000820A                          1117  
0000820A  103C 0020               1118      move.b  #' ', d0
0000820E  6100 0186               1119      bsr.w   putc                * insert a space
00008212                          1120  
00008212  10FC 000D               1121      move.b  #CR,(a0)+
00008216  10FC 000A               1122      move.b  #LF,(a0)+
0000821A  10FC 0000               1123      move.b  #0,(a0)+
0000821E  41F9 001FF906           1124      lea     msgASCIIDump, a0
00008224  6100 0318               1125      bsr.w   putString           * print out the printable bytes
00008228  51C9 FFB0               1126      dbra    d1,.dr_1
0000822C                          1127  
0000822C  4CDF 0207               1128      movem.l (SP)+, d0-d2/a1     * Restore registers
00008230  4E75                    1129      rts
00008232                          1130              
00008232                          1131  *------------------------------------------------------------------------------
00008232                          1132  * Convert character in D0 to upper case
00008232                          1133  * Only changes D0 if char is between 'a'..'z'
00008232                          1134  *------------------------------------------------------------------------------
00008232                          1135  chToUpper:
00008232  B03C 0061               1136      cmp.b   #'a', d0         
00008236  6D0A                    1137      blt.s   .done               * less than lower-case 'a' so leave alone
00008238  B03C 007A               1138      cmp.b   #'z', d0
0000823C  6E04                    1139      bgt.s   .done               * greater than lower-case 'z' so leave alone
0000823E  0400 0020               1140      sub.b   #$20, d0            * convert to upper case
00008242                          1141  .done:
00008242  4E75                    1142      rts
00008244                          1143      
00008244                          1144  *------------------------------------------------------------------------------
00008244                          1145  * Convert a byte into a print safe character
00008244                          1146  * Substitute a '.' for any byte <32 or >126
00008244                          1147  * D0 holds the byte
00008244                          1148  *------------------------------------------------------------------------------
00008244                          1149  makePrintable:
00008244  B03C 0020               1150      cmp.b   #' ', d0         
00008248  6D06                    1151      blt.s   .mp_1               * less than a SPACE (char 32)
0000824A                          1152  
0000824A  B03C 007E               1153      cmp.b   #'~', d0         
0000824E  6F04                    1154      ble.s   .mp_x               * less than a DEL (char 127)
00008250                          1155  
00008250                          1156  .mp_1:
00008250  103C 002E               1157      move.b  #'.',d0             * substitute a DOT (char 46)
00008254                          1158  .mp_x:
00008254  4E75                    1159      rts
00008256                          1160      
00008256                          1161  *--------------------------------------------------------------------------
00008256                          1162  * Read in an ASCII-HEX number - no echo back
00008256                          1163  *
00008256                          1164  * D2 = Value to return if no digits read in
00008256                          1165  * D1 = Max no of ASCII digits to read in
00008256                          1166  * D0 = Result
00008256                          1167  * Carry flag set if an error occurs / not ASCII-HEX digit
00008256                          1168  *--------------------------------------------------------------------------
00008256                          1169  hexToInt:
00008256                          1170  *   move.l  d2,-(SP)            * save D2
00008256                          1171  *   clr.l   d2                  * D2 used to accumulate the final value
00008256                          1172  .h2i_1:
00008256  6100 0150               1173      bsr.w   getc                * get a character
0000825A  61D6                    1174      bsr.s   chToUpper           * convert to upper case if needed
0000825C                          1175  
0000825C  0C00 000A               1176      cmpi.b  #10,d0              * finish if it's CR or LF
00008260  6724                    1177      beq.s   .h2i_x
00008262  0C00 000D               1178      cmpi.b  #13,d0
00008266  671E                    1179      beq.s   .h2i_x
00008268                          1180      
00008268  0400 0030               1181      subi.b  #'0',d0
0000826C  6B1C                    1182      bmi.s   .h2i_err            * quit if char is less than '0'
0000826E                          1183  
0000826E  0C00 0009               1184      cmpi.b  #9,d0
00008272  6F0A                    1185      ble.s   .h2i_2              * is it <= 9
00008274                          1186      
00008274  5F00                    1187      subi.b  #7,d0
00008276  6B12                    1188      bmi.s   .h2i_err            * quit if char is >'9' and <'A'
00008278                          1189  
00008278  0C00 000F               1190      cmpi.b  #15,d0
0000827C  6E0C                    1191      bgt.s   .h2i_err            * quit if char is >'F'
0000827E                          1192  
0000827E                          1193  .h2i_2:
0000827E  E98A                    1194      lsl.l   #4, d2
00008280  8400                    1195      or.b    d0, d2              * insert the new digit
00008282                          1196  
00008282  5301                    1197      subq.b  #1, d1              * decrement the digit count
00008284  66D0                    1198      bne.s   .h2i_1              * go back for another digit?
00008286                          1199  
00008286                          1200  .h2i_x:
00008286  2002                    1201      move.l  d2,d0               * put the answer back into D0
00008288                          1202  *   move.l  (SP)+,d2            * restore D2
00008288  4E75                    1203      rts
0000828A                          1204  
0000828A                          1205  .h2i_err:
0000828A                          1206  *   move.l  (SP)+,d2            * restore D2
0000828A  003C 0001               1207      ori.b   #1,CCR              * set the CARRY flag to signal an error
0000828E  4E75                    1208      rts
00008290                          1209  
00008290                          1210  *--------------------------------------------------------------------------
00008290                          1211  * Read in an ASCII-HEX number with echo back
00008290                          1212  *
00008290                          1213  * D2 = Value to return if no digits read in
00008290                          1214  * D1 = Max no of ASCII digits to read in
00008290                          1215  * D0 = Result
00008290                          1216  * Carry flag set if an error occurs / not ASCII-HEX digit
00008290                          1217  *--------------------------------------------------------------------------
00008290                          1218  hexToIntEcho:
00008290                          1219  *   move.l  d2,-(SP)            * save D2
00008290                          1220  *   clr.l   d2                  * D2 used to accumulate the final value
00008290                          1221  .h2i_1:
00008290  6100 0116               1222      bsr.w   getc                * get a character
00008294  6100 0100               1223      bsr.w   putc                * echo it back
00008298  6198                    1224      bsr.s   chToUpper           * convert to upper case if needed
0000829A                          1225  
0000829A  0C00 000A               1226      cmpi.b  #10,d0              * finish if it's CR or LF
0000829E  6724                    1227      beq.s   .h2i_x
000082A0  0C00 000D               1228      cmpi.b  #13,d0
000082A4  671E                    1229      beq.s   .h2i_x
000082A6                          1230      
000082A6  0400 0030               1231      subi.b  #'0',d0
000082AA  6B1C                    1232      bmi.s   .h2i_err            * quit if char is less than '0'
000082AC                          1233  
000082AC  0C00 0009               1234      cmpi.b  #9,d0
000082B0  6F0A                    1235      ble.s   .h2i_2              * is it <= 9
000082B2                          1236      
000082B2  5F00                    1237      subi.b  #7,d0
000082B4  6B12                    1238      bmi.s   .h2i_err            * quit if char is >'9' and <'A'
000082B6                          1239  
000082B6  0C00 000F               1240      cmpi.b  #15,d0
000082BA  6E0C                    1241      bgt.s   .h2i_err            * quit if char is >'F'
000082BC                          1242  
000082BC                          1243  .h2i_2:
000082BC  E98A                    1244      lsl.l   #4, d2
000082BE  8400                    1245      or.b    d0, d2              * insert the new digit
000082C0                          1246  
000082C0  5301                    1247      subq.b  #1, d1              * decrement the digit count
000082C2  66CC                    1248      bne.s   .h2i_1              * go back for another digit?
000082C4                          1249  
000082C4                          1250  .h2i_x:
000082C4  2002                    1251      move.l  d2,d0               * put the answer back into D0
000082C6                          1252  *   move.l  (SP)+,d2            * restore D2
000082C6  4E75                    1253      rts
000082C8                          1254  
000082C8                          1255  .h2i_err:
000082C8                          1256  *   move.l  (SP)+,d2            * restore D2
000082C8  003C 0001               1257      ori.b   #1,CCR              * set the CARRY flag to signal an error
000082CC  4E75                    1258      rts
000082CE                          1259  
000082CE                          1260  *******************************************************************************
000082CE                          1261  *
000082CE                          1262  *   #####  ####### ######  ###    #    #          ######  ####### ######  ####### 
000082CE                          1263  *  #     # #       #     #  #    # #   #          #     # #     # #     #    #    
000082CE                          1264  *  #       #       #     #  #   #   #  #          #     # #     # #     #    #    
000082CE                          1265  *   #####  #####   ######   #  #     # #          ######  #     # ######     #    
000082CE                          1266  *        # #       #   #    #  ####### #          #       #     # #   #      #    
000082CE                          1267  *  #     # #       #    #   #  #     # #          #       #     # #    #     #    
000082CE                          1268  *   #####  ####### #     # ### #     # #######    #       ####### #     #    #    
000082CE                          1269  *                                                                                                   
000082CE                          1270  *******************************************************************************
000082CE                          1271  
000082CE                          1272  *------------------------------------------------------------------------------
000082CE                          1273  * Initialise the serial port
000082CE                          1274  *
000082CE                          1275  * Assumes that there is a 68681 DUART at the address defined by DUART1 in
000082CE                          1276  * devices.inc and initialises port A and enables the rx interrupt.
000082CE                          1277  *------------------------------------------------------------------------------
000082CE                          1278  serInit:
000082CE  13FC 0030 00D00005      1279      move.b  #$30, CRA           * Reset Transmitter
000082D6  13FC 0020 00D00005      1280      move.b  #$20, CRA           * Reset Receiver
000082DE  13FC 0010 00D00005      1281      move.b  #$10, CRA           * Reset Mode Register Pointer
000082E6                          1282      
000082E6  23FC 00000000 001FF800  1283      move.l  #0,ser0RxHead       * Set queue head and tail ptrs to 0
000082F0  33FC 0000 001FF804      1284      move.w  #0,ser0RxSize       * No chars in receive queue
000082F8                          1285  
000082F8  13FC 0000 00D00009      1286      move.b  #$00, ACR           * Baud Rate Set #1
00008300  13FC 0013 00D00001      1287      move.b  #$13, MRA           * No Parity & 8-bit
00008308  13FC 0007 00D00001      1288      move.b  #$07, MRA           * Normal Mode, No CTS/RTS & 1 stop bit
00008310                          1289  
00008310                          1290      * if HI_SPEED = 0 then set 38400 baud
00008310                 FALSE    1291      ifeq HI_SPEED
00008310                          1292      endc
00008310                          1293  
00008310                          1294      * if HI_SPEED > 0 then set 115200 baud
00008310                 TRUE     1295      ifgt HI_SPEED
00008310  1039 00D00005           1296      move.b  CRA,d0              * Read CRA - sets BRG test mode
00008316  13FC 0066 00D00003      1297      move.b  #BAUD_1200, CSRA    * Set Tx and Rx baud rates to 115200 (old 1200)
0000831E                          1298      endc
0000831E                          1299      
0000831E  13FC 0002 00D0000B      1300      move.b  #$02, IMR           * Rx interrupt enabled
00008326  13FC 0005 00D00005      1301      move.b  #$05, CRA           * Enable Transmit/Recieve
0000832E  13FC 0001 00D0001D      1302      move.b  #$01, SOPR          * set OP0 low - i.e. CTS low
00008336  4E75                    1303      rts
00008338                          1304  
00008338                          1305  *------------------------------------------------------------------------------
00008338                          1306  * Serial port interrupt handler
00008338                          1307  *
00008338                          1308  * Should only be called when a char has been received.
00008338                          1309  *
00008338                          1310  *------------------------------------------------------------------------------
00008338                          1311  serISR:
00008338                          1312      * save registers we are about to trash
00008338  48E7 E080               1313      movem.l d0-d2/a0,-(sp)
0000833C                          1314  
0000833C  0839 0001 00D0000B      1315      btst.b  #1,ISR              * check the RXRDYA bit
00008344  6700 004A               1316      beq.w   serExit
00008348                          1317  
00008348                          1318      * a char has been received so save it in the rx queue
00008348  1039 00D00007           1319      move.b  RBA,d0              * get the character
0000834E  207C 001FF800           1320      movea.l #ser0RxQueue,a0     * A0 = ptr to rx queue parameters
00008354  2210                    1321      move.l  (a0),d1             * D1.L MSW = head and LSW = tail
00008356  4841                    1322      swap    d1                  * D1.L MSW = tail and LSW = head
00008358  3401                    1323      move.w  d1,d2               * D2.W holds the queue head index
0000835A  4841                    1324      swap    d1                  * D1.L MSW = head and LSW = tail
0000835C                          1325  
0000835C                          1326  
0000835C  5242                    1327      addq.w  #1,d2               * advance the head index
0000835E  0242 00FF               1328      andi.w  #SERIAL_BUFFER_MASK,d2
00008362  B441                    1329      cmp.w   d1,d2               * if head = tail then buffer full
00008364  6604                    1330      bne.s   serSave             * if head <> tail then add char to buffer
00008366                          1331  
00008366                          1332      * the serial buffer is full - what now?
00008366  6000 0028               1333      bra.w   serExit
0000836A                          1334  
0000836A                          1335  serSave:
0000836A  4841                    1336      swap    d1                  * D1.L MSW = tail and LSW = head
0000836C  0281 0000FFFF           1337      andi.l  #$0000FFFF,d1       * D1 holds just the old head index
00008372  1180 1006               1338      move.b  d0,6(a0,d1)         * save the char to the rx queue
00008376  3082                    1339      move.w  d2,(a0)             * save the updated head index
00008378  5279 001FF804           1340      addq.w  #1,ser0RxSize       * increment number of chars in rx queue
0000837E                          1341  
0000837E                          1342      * check if rx queue is nearly full
0000837E  0C79 00C8 001FF804      1343      cmpi.w  #SERIAL_BUFFER_UPPER,ser0RxSize
00008386  6F08                    1344      ble.s   serExit
00008388                          1345  
00008388                          1346      * no of chars in queue has reached the upper threshold
00008388                          1347      * set CTS HIGH to hopefully tell the host to stop sending.
00008388  13FC 0001 00D0001F      1348      move.b  #$01, ROPR          * set OP0 high
00008390                          1349  
00008390                          1350  serExit:
00008390                          1351      * restore registers
00008390  4CDF 0107               1352      movem.l (sp)+,d0-d2/a0
00008394  4E73                    1353      rte
00008396                          1354  
00008396                          1355  *------------------------------------------------------------------------------
00008396                          1356  * Write a character to UART Port A, blocking if UART is not ready
00008396                          1357  *
00008396                          1358  * D0 = char to send
00008396                          1359  *------------------------------------------------------------------------------
00008396                          1360  putc:
00008396  0839 0002 00D00003      1361      btst.b  #2, SRA             * Check if transmitter ready bit is set
0000839E  67F6                    1362      beq     putc     
000083A0  13C0 00D00007           1363      move.b  d0, TBA             * Transmit Character
000083A6  4E75                    1364      rts
000083A8                          1365  
000083A8                          1366  *------------------------------------------------------------------------------
000083A8                          1367  * Read a character from the rx queue - blocking call so will wait for character
000083A8                          1368  *
000083A8                          1369  * D0 = recevied char
000083A8                          1370  *------------------------------------------------------------------------------
000083A8                          1371  getc:
000083A8  0C79 0000 001FF804      1372      cmpi.w  #0,ser0RxSize       * check number of chars in rx queue
000083B0  67F6                    1373      beq.s   getc                * keep checking till there is a char available
000083B2                          1374  
000083B2                          1375      * save registers we are about to trash
000083B2  48E7 4080               1376      movem.l d1/a0,-(sp)
000083B6                          1377      
000083B6                          1378      * get the character from the tail of the queue
000083B6  207C 001FF800           1379      movea.l #ser0RxQueue,a0     * A0 = ptr to rx queue parameters
000083BC  2210                    1380      move.l  (a0),d1             * D1.L MSW = head and LSW = tail
000083BE  1030 1006               1381      move.b  6(a0,d1.w),d0       * read the char from the queue tail
000083C2  5241                    1382      addq.w  #1,d1               * advance the tail index
000083C4  0241 00FF               1383      andi.w  #SERIAL_BUFFER_MASK,d1
000083C8  3141 0002               1384      move.w  d1,2(a0)            * save the updated tail index
000083CC  5379 001FF804           1385      subq.w  #1,ser0RxSize       * decrement number of chars in rx queue
000083D2                          1386  
000083D2                          1387      * check if rx queue is nearly empty
000083D2  0C79 0019 001FF804      1388      cmpi.w  #SERIAL_BUFFER_LOWER,ser0RxSize
000083DA  6C08                    1389      bge.s   getExit
000083DC                          1390  
000083DC                          1391      * no of chars in queue has reached the lower threshold
000083DC                          1392      * set CTS LOW to hopefully tell the host to start sending.
000083DC  13FC 0001 00D0001D      1393      move.b  #$01, SOPR          * set OP0 low
000083E4                          1394  
000083E4                          1395  getExit:
000083E4                          1396      * restore registers
000083E4  4CDF 0102               1397      movem.l (sp)+,d1/a0
000083E8  4E75                    1398      rts
000083EA                          1399  
000083EA                          1400  *******************************************************************************
000083EA                          1401  *
000083EA                          1402  *  #######    #     #####  #     #  #####   #####  #    #    ####### ######     #    ######   #####  
000083EA                          1403  *  #         # #   #     #  #   #  #     # #     # #   #        #    #     #   # #   #     # #     # 
000083EA                          1404  *  #        #   #  #         # #   #       #     # #  #         #    #     #  #   #  #     # #       
000083EA                          1405  *  #####   #     #  #####     #    ######   #####  ###          #    ######  #     # ######   #####  
000083EA                          1406  *  #       #######       #    #    #     # #     # #  #         #    #   #   ####### #             # 
000083EA                          1407  *  #       #     # #     #    #    #     # #     # #   #        #    #    #  #     # #       #     # 
000083EA                          1408  *  ####### #     #  #####     #     #####   #####  #    #       #    #     # #     # #        #####  
000083EA                          1409  *                                                                                                   
000083EA                          1410  *******************************************************************************
000083EA                          1411  
000083EA                          1412  *------------------------------------------------------------------------------
000083EA                          1413  * This is the jump table for the TRAP #15 tasks - not all tasks are supported!
000083EA                          1414  *------------------------------------------------------------------------------
000083EA                          1415  
000083EA                          1416  easy68kTaskTable:
000083EA  6000 008A               1417      bra.w   easyTask0 
000083EE  6000 009E               1418      bra.w   easyTask1 
000083F2  6000 005E               1419      bra.w   easyTask2 
000083F6  6000 005A               1420      bra.w   easyTask3 
000083FA  6000 0056               1421      bra.w   easyTask4 
000083FE  6000 00A2               1422      bra.w   easyTask5 
00008402  6000 00A6               1423      bra.w   easyTask6 
00008406  6000 00AA               1424      bra.w   easyTask7 
0000840A  6000 0046               1425      bra.w   easyTask8 
0000840E  6000 0042               1426      bra.w   easyTask9 
00008412  6000 003E               1427      bra.w   easyTask10
00008416  6000 003A               1428      bra.w   easyTask11
0000841A  6000 0036               1429      bra.w   easyTask12
0000841E  6000 009E               1430      bra.w   easyTask13
00008422  6000 00AA               1431      bra.w   easyTask14
00008426  6000 002A               1432      bra.w   easyTask15
0000842A  6000 0026               1433      bra.w   easyTask16
0000842E  6000 0022               1434      bra.w   easyTask17
00008432  6000 001E               1435      bra.w   easyTask18
00008436  6000 001A               1436      bra.w   easyTask19
0000843A  6000 0016               1437      bra.w   easyTask20
0000843E  6000 0012               1438      bra.w   easyTask21
00008442  6000 000E               1439      bra.w   easyTask22
00008446  6000 000A               1440      bra.w   easyTask23
0000844A  6000 0006               1441      bra.w   easyTask24
0000844E  6000 0002               1442      bra.w   easyTask25
00008452                          1443  
00008452                          1444  *------------------------------------------------------------------------------
00008452                          1445  * These are the EASy68K tasks that are not yet implemented
00008452                          1446  * Simply print out a message showing the task number and stop in an endless loop.
00008452                          1447  *------------------------------------------------------------------------------
00008452                          1448  
00008452                          1449  easyTask2: 
00008452                          1450  easyTask3:
00008452                          1451  easyTask4:
00008452                          1452  easyTask8: 
00008452                          1453  easyTask9: 
00008452                          1454  easyTask10:
00008452                          1455  easyTask11:
00008452                          1456  easyTask12:
00008452                          1457  easyTask15:
00008452                          1458  easyTask16:
00008452                          1459  easyTask17:
00008452                          1460  easyTask18:
00008452                          1461  easyTask19:
00008452                          1462  easyTask20:
00008452                          1463  easyTask21:
00008452                          1464  easyTask22:
00008452                          1465  easyTask23:
00008452                          1466  easyTask24:
00008452                          1467  easyTask25:
00008452                          1468  easyTaskUnsupported:
00008452  C141                    1469      exg     d0,d1               * put the task number into D1
00008454  41FA 032A               1470      lea     strEasyTask1(PC), a0
00008458  6100 00E4               1471      bsr.w   putString
0000845C  C141                    1472      exg     d0,d1               * put the task number back into D0
0000845E  80FC 000A               1473      divu    #10,d0              * divide task number by 10
00008462  6100 00BC               1474      bsr.w   writeNibble         * output the 10's digit
00008466  4840                    1475      swap    d0
00008468  6100 00B6               1476      bsr.w   writeNibble         * output the 1's digit
0000846C  41FA 0333               1477      lea     strEasyTask2(PC), a0
00008470  6100 00CC               1478      bsr.w   putString
00008474                          1479  .infloop:
00008474  60FE                    1480      bra.s   .infloop
00008476                          1481  
00008476                          1482  *------------------------------------------------------------------------------
00008476                          1483  * EASy68K TRAP #15 - Task 0
00008476                          1484  * Display n characters of string at (A1), n is D1.W (stops on NULL or max 255) with CR, LF.
00008476                          1485  *------------------------------------------------------------------------------
00008476                          1486  easyTask0:
00008476  0241 00FF               1487      andi.w  #$00FF,d1           * DBRA works on a WORD so make sure upper byte is zero
0000847A  5301                    1488      sub.b   #1,d1               * DBRA requires 1 less than actual number
0000847C                          1489  .loop:
0000847C  1019                    1490      move.b  (a1)+, d0           * Read in character
0000847E  6708                    1491      beq.s   .end                * Check for the null
00008480                          1492      
00008480  6100 FF14               1493      bsr.w   putc                * Otherwise write the character
00008484  51C9 FFF6               1494      dbra    d1,.loop            * And continue
00008488                          1495  .end:
00008488  6100 00B0               1496      bsr.w   putCRLF             * append CR & LF
0000848C  4E75                    1497      rts
0000848E                          1498  
0000848E                          1499  *------------------------------------------------------------------------------
0000848E                          1500  * EASy68K TRAP #15 - Task 1
0000848E                          1501  * Display n characters of string at (A1), n is D1.W (stops on NULL or max 255) without CR, LF.
0000848E                          1502  *------------------------------------------------------------------------------
0000848E                          1503  easyTask1:
0000848E  0241 00FF               1504      andi.w  #$00FF,d1           * DBRA works on a WORD so make sure upper byte is zero
00008492  5301                    1505      sub.b   #1,d1               * DBRA requires 1 less than actual number
00008494                          1506  .loop:
00008494  1019                    1507      move.b  (a1)+, d0           * Read in character
00008496  6708                    1508      beq.s   .end                * Check for the null
00008498                          1509      
00008498  6100 FEFC               1510      bsr.w   putc                * Otherwise write the character
0000849C  51C9 FFF6               1511      dbra    d1,.loop            * And continue
000084A0                          1512  .end:
000084A0  4E75                    1513      rts
000084A2                          1514  
000084A2                          1515  *------------------------------------------------------------------------------
000084A2                          1516  * EASy68K TRAP #15 - Task 5
000084A2                          1517  * Read single ASCII character from the keyboard into D1.B. 
000084A2                          1518  *------------------------------------------------------------------------------
000084A2                          1519  easyTask5:
000084A2  6100 FF04               1520      bsr.w   getc                * wait for char - returned in D0
000084A6  1200                    1521      move.b  d0,d1               * move the char into D1
000084A8  4E75                    1522      rts
000084AA                          1523      
000084AA                          1524  *------------------------------------------------------------------------------
000084AA                          1525  * EASy68K TRAP #15 - Task 6
000084AA                          1526  * Display single ASCII character in D1.B.   
000084AA                          1527  *------------------------------------------------------------------------------
000084AA                          1528  easyTask6:
000084AA  1001                    1529      move.b  d1,d0               * move the char into D0
000084AC  6100 FEE8               1530      bsr.w   putc                * output the char
000084B0  4E75                    1531      rts
000084B2                          1532  
000084B2                          1533  *------------------------------------------------------------------------------
000084B2                          1534  * EASy68K TRAP #15 - Task 7
000084B2                          1535  * Check for keyboard input. Set D1.B to 1 if keyboard input is pending,
000084B2                          1536  * otherwise set to 0.
000084B2                          1537  *------------------------------------------------------------------------------
000084B2                          1538  easyTask7:
000084B2  1239 00D00003           1539      move.b  SRA,d1              * get DUART status register
000084B8  0201 0001               1540      andi.b  #$01,d1             * mask all but the RxRDY bit
000084BC  4E75                    1541      rts
000084BE                          1542  
000084BE                          1543  *------------------------------------------------------------------------------
000084BE                          1544  * EASy68K TRAP #15 - Task 13
000084BE                          1545  * Display the NULL terminated string at (A1) with CR, LF.
000084BE                          1546  *------------------------------------------------------------------------------
000084BE                          1547  easyTask13:
000084BE                          1548  .loop:
000084BE  1019                    1549      move.b  (a1)+, d0           * Read in character
000084C0  6706                    1550      beq.s   .end                * Check for the null
000084C2                          1551      
000084C2  6100 FED2               1552      bsr.w   putc                * Otherwise write the character
000084C6  60F6                    1553      bra.s   .loop               * And continue
000084C8                          1554  .end:
000084C8  6100 0070               1555      bsr.w   putCRLF             * append CR & LF
000084CC  4E75                    1556      rts
000084CE                          1557  
000084CE                          1558  *------------------------------------------------------------------------------
000084CE                          1559  * EASy68K TRAP #15 - Task 14
000084CE                          1560  * Display the NULL terminated string pointed to by (A1).
000084CE                          1561  *------------------------------------------------------------------------------
000084CE                          1562  easyTask14:
000084CE                          1563  .loop:
000084CE  1019                    1564      move.b  (a1)+, d0           * Read in character
000084D0  6706                    1565      beq.s   .end                * Check for the null
000084D2                          1566      
000084D2  6100 FEC2               1567      bsr.w   putc                * Otherwise write the character
000084D6  60F6                    1568      bra.s   .loop               * And continue
000084D8                          1569  .end:
000084D8  4E75                    1570      rts
000084DA                          1571  
000084DA                          1572  *------------------------------------------------------------------------------
000084DA                          1573  * This is the entry point for the TRAP #15 handler that gets called when any
000084DA                          1574  * TRAP #15 services are required. Only a few tasks are implemented.
000084DA                          1575  * Unimplemented tasks will produce an error message.
000084DA                          1576  *------------------------------------------------------------------------------
000084DA                          1577  easy68kTrap15:
000084DA  48E7 10A0               1578      movem.l d3/a0/a2,-(sp)
000084DE  45FA FF0A               1579      lea     easy68kTaskTable(PC),a2
000084E2  B03C 0019               1580      cmp.b   #25,d0              * is task number greater than 25?
000084E6  6E00 FF6A               1581      bgt     easyTaskUnsupported
000084EA                          1582      
000084EA  4283                    1583      clr.l   d3
000084EC  1600                    1584      move.b  d0,d3               * task number into D3
000084EE  E58B                    1585      lsl.l   #2,d3               * convert task number into longword offset
000084F0  4EB2 3000               1586      jsr     (a2,d3)             * jump to the specific task handler
000084F4                          1587      
000084F4  4CDF 0508               1588      movem.l (sp)+,d3/a0/a2
000084F8  4E73                    1589      rte
000084FA                          1590  
000084FA                          1591  *******************************************************************************
000084FA                          1592  *
000084FA                          1593  *  ######  ######  ### #     # #######    ######  ####### #     # ####### ### #     # #######  #####  
000084FA                          1594  *  #     # #     #  #  ##    #    #       #     # #     # #     #    #     #  ##    # #       #     # 
000084FA                          1595  *  #     # #     #  #  # #   #    #       #     # #     # #     #    #     #  # #   # #       #       
000084FA                          1596  *  ######  ######   #  #  #  #    #       ######  #     # #     #    #     #  #  #  # #####    #####  
000084FA                          1597  *  #       #   #    #  #   # #    #       #   #   #     # #     #    #     #  #   # # #             # 
000084FA                          1598  *  #       #    #   #  #    ##    #       #    #  #     # #     #    #     #  #    ## #       #     # 
000084FA                          1599  *  #       #     # ### #     #    #       #     # #######  #####     #    ### #     # #######  #####    
000084FA                          1600  *
000084FA                          1601  *******************************************************************************
000084FA                          1602  * These are the various printing routines that handle displaying of bytes,
000084FA                          1603  * words, long words and 24-bit values as ASCII hexadecimal text. The routines
000084FA                          1604  * must be kept in this order as program flow is meant to fall out of one
000084FA                          1605  * routine and into the next, often without a return statement.
000084FA                          1606  *******************************************************************************
000084FA                          1607  
000084FA                          1608  *------------------------------------------------------------------------------
000084FA                          1609  * Output a 32-bit address as 8 ASCII hexadecimal digits
000084FA                          1610  * D0 holds the 32-bit address
000084FA                          1611  *------------------------------------------------------------------------------
000084FA                          1612  writeAddr32:
000084FA  2F00                    1613      move.l  d0,-(sp)            * save D0 first
000084FC  E098                    1614      ror.l   #8,d0
000084FE  E098                    1615      ror.l   #8,d0
00008500  610E                    1616      bsr.s   writeWord           * write bits 16..31
00008502  201F                    1617      move.l  (sp)+,d0            * restore D0
00008504  600A                    1618      bra.s   writeWord
00008506                          1619      
00008506                          1620  *------------------------------------------------------------------------------
00008506                          1621  * Output a 24-bit address as 6 ASCII hexadecimal digits
00008506                          1622  * D0 holds the address in bits 0..23
00008506                          1623  * NOTE: the writeWord function must be directly after this function
00008506                          1624  *------------------------------------------------------------------------------
00008506                          1625  writeAddr24:
00008506  2F00                    1626      move.l  d0,-(sp)            * save D0 first
00008508  E098                    1627      ror.l   #8,d0
0000850A  E098                    1628      ror.l   #8,d0
0000850C  610A                    1629      bsr.s   writeByte           * write bits 16..23
0000850E  201F                    1630      move.l  (sp)+,d0            * restore D0
00008510                          1631      
00008510                          1632  *------------------------------------------------------------------------------
00008510                          1633  * Output a word as 4 ASCII hexadecimal digits
00008510                          1634  * D0 holds the word in bits 0..15
00008510                          1635  * NOTE: the writeByte function must be directly after this function
00008510                          1636  *------------------------------------------------------------------------------
00008510                          1637  writeWord:
00008510  3F00                    1638      move.w  d0,-(sp)            * save D0 first
00008512  E058                    1639      ror.w   #8,d0               * get upper byte (0 => shift 8 times)
00008514  6102                    1640      bsr.s   writeByte
00008516  301F                    1641      move.w  (sp)+,d0            * restore D0
00008518                          1642  
00008518                          1643  *------------------------------------------------------------------------------
00008518                          1644  * Output a byte as 2 ASCII hexadecimal digits
00008518                          1645  * D0 holds the byte in bits 0..7
00008518                          1646  * NOTE: the writeNibble function must be directly after this function
00008518                          1647  *------------------------------------------------------------------------------
00008518                          1648  writeByte:
00008518  3F00                    1649      move.w  d0,-(sp)            * save D0 first
0000851A  E818                    1650      ror.b   #4,d0               * get upper nibble
0000851C  6102                    1651      bsr.s   writeNibble
0000851E  301F                    1652      move.w  (sp)+,d0            * restore D0
00008520                          1653      
00008520                          1654  *------------------------------------------------------------------------------
00008520                          1655  * Output 4 bits as an ASCII hexadecimal digit
00008520                          1656  * D0 holds the nibble in bits 0..3
00008520                          1657  *------------------------------------------------------------------------------
00008520                          1658  writeNibble:
00008520  3F00                    1659      move.w  d0,-(sp)            * save D0 first
00008522  0200 000F               1660      andi.b  #$0F,d0             * make sure we only have the lower 4 bits
00008526  0C00 000A               1661      cmpi.b  #10,d0              * compare D0 to 10
0000852A  6502                    1662      bcs.b   .wn1                * less than 10 so don't add 7
0000852C  5E00                    1663      addi.b  #07,d0              * add 7
0000852E                          1664  .wn1:
0000852E  0600 0030               1665      addi.b  #'0',d0             * add ASCII code for char zero
00008532  6100 FE62               1666      bsr.w   putc                * write the ASCII digit out
00008536  301F                    1667      move.w  (sp)+,d0            * restore D0
00008538  4E75                    1668      rts
0000853A                          1669  
0000853A                          1670  *------------------------------------------------------------------------------
0000853A                          1671  * Prints a newline (CR, LF)
0000853A                          1672  * NOTE: the putString function must follow this function
0000853A                          1673  *------------------------------------------------------------------------------
0000853A                          1674  putCRLF:
0000853A  41FA 020B               1675      lea     strNewline(PC), a0
0000853E                          1676  
0000853E                          1677  *------------------------------------------------------------------------------
0000853E                          1678  * Print a null terminated string
0000853E                          1679  * A0 holds the address of the first character of the null terminated string
0000853E                          1680  *------------------------------------------------------------------------------
0000853E                          1681  putString:
0000853E                          1682  .loop:
0000853E  1018                    1683      move.b  (a0)+, d0           * Read in character
00008540  6706                    1684      beq.s   .end                * Check for the null
00008542                          1685      
00008542  6100 FE52               1686      bsr.w   putc                * Otherwise write the character
00008546  60F6                    1687      bra.s   .loop               * And continue
00008548                          1688  .end:
00008548  4E75                    1689      rts
0000854A                          1690  
0000854A                          1691  *******************************************************************************
0000854A                          1692  *
0000854A                          1693  *   #####  ####### ######  ### #     #  #####   #####  
0000854A                          1694  *  #     #    #    #     #  #  ##    # #     # #     # 
0000854A                          1695  *  #          #    #     #  #  # #   # #       #       
0000854A                          1696  *   #####     #    ######   #  #  #  # #  ####  #####  
0000854A                          1697  *        #    #    #   #    #  #   # # #     #       # 
0000854A                          1698  *  #     #    #    #    #   #  #    ## #     # #     # 
0000854A                          1699  *   #####     #    #     # ### #     #  #####   #####  
0000854A                          1700  *
0000854A                          1701  *******************************************************************************
0000854A                          1702  strBanner1:
0000854A= 0A 0D                   1703      dc.b 10,13
0000854C= 53 69 6D 70 6C 65 ...   1704      dc.b 'Simple RCBus 68000 ROM Monitor v1.4',10,13
00008571= 52 4F 4D 3A 20 30 ...   1705      dc.b 'ROM: 0x000000 .. 0x01FFFF',10,13
0000858C= 52 41 4D 3A 20 30 ...   1706      dc.b 'RAM: 0x100000 .. 0x1FFFFF',10,13,0
000085A8                          1707  strCommands:
000085A8= 0A 0D 43 6F 6D 6D ...   1708      dc.b 10,13,'Commands: ',10,13
000085B6= 42 20 20 20 20 20 ...   1709      dc.b 'B     : Start EhBASIC v3.54',10,13
000085D3= 44 6E 6E 6E 6E 20 ...   1710      dc.b 'Dnnnn : Display 256 bytes of memory starting at address nnnn',10,13
00008611= 47 6E 6E 6E 6E 20 ...   1711      dc.b 'Gnnnn : Execute code starting at address nnnn',10,13
00008640= 49 61 61 20 20 20 ...   1712      dc.b 'Iaa   : Read a byte from address aa in I/O space',10,13
00008672= 4D 6E 6E 6E 6E 20 ...   1713      dc.b 'Mnnnn : Modify memory starting at address nnnn',10,13
000086A2= 4F 61 61 62 62 20 ...   1714      dc.b 'Oaabb : Write byte bb to address aa in I/O space',10,13
000086D4= 53 31 78 78 78 20 ...   1715      dc.b 'S1xxx : Download S1 Hex Record ',10,13          
000086F5= 53 32 78 78 78 20 ...   1716      dc.b 'S2xxx : Download S2 Hex Record ',10,13    
00008716= 3F 20 20 20 20 20 ...   1717      dc.b '?     : Display this help',10,13
00008731= 00                      1718      dc.b 0
00008732                          1719  strPrompt:
00008732= 3E 20 00                1720      dc.b '> ',0
00008735                          1721  strUnkCmd:
00008735= 55 6E 6B 6E 6F 77 ...   1722      dc.b 'Unknown Command: ',0
00008747                          1723  strNewline:
00008747= 0A 0D 00                1724      dc.b 10,13,0
0000874A                          1725  strColonSpace:
0000874A= 3A 20 00                1726      dc.b ': ',0
0000874D                          1727  strUninitInt:
0000874D= 55 6E 68 61 6E 64 ...   1728      dc.b 'Unhandled interrupt.',10,13,0
00008764                          1729  strUserReturn:
00008764= 0A 0D 55 73 65 72 ...   1730      dc.b 10,13,'User program completed.',10,13,0
00008780                          1731  strEasyTask1:
00008780= 0A 0D 53 54 4F 50 ...   1732      dc.b    10,13,'STOP: EASy68K TRAP #15 - Task ',0
000087A1                          1733  strEasyTask2:
000087A1= 20 6E 6F 74 20 79 ...   1734      dc.b    ' not yet implemented',10,13,0
000087B8                          1735  strBASICErr1:
000087B8= 0A 0D 43 61 6E 6E ...   1736      dc.b    10,13,'Cannot boot EhBASIC - EhBASIC missing from EEPROM',10,13,0
000087EE                          1737  strBASICReturn:
000087EE= 0A 0D 45 68 42 41 ...   1738      dc.b    10,13,'EhBASIC returned to Monitor. Press RESET to restart.',10,13,0
00008827                          1739  
00008827                          1740  *******************************************************************************
00008827                          1741  *
00008827                          1742  *  #     # ####### #     # ### ####### ####### ######     #     #    #    ######   #####  
00008827                          1743  *  ##   ## #     # ##    #  #     #    #     # #     #    #     #   # #   #     # #     # 
00008827                          1744  *  # # # # #     # # #   #  #     #    #     # #     #    #     #  #   #  #     # #       
00008827                          1745  *  #  #  # #     # #  #  #  #     #    #     # ######     #     # #     # ######   #####  
00008827                          1746  *  #     # #     # #   # #  #     #    #     # #   #       #   #  ####### #   #         # 
00008827                          1747  *  #     # #     # #    ##  #     #    #     # #    #       # #   #     # #    #  #     # 
00008827                          1748  *  #     # ####### #     # ###    #    ####### #     #       #    #     # #     #  #####  
00008827                          1749  *
00008827                          1750  *******************************************************************************
00008827                          1751  * Private monitor variables go here in a block of 2048 bytes (defined by MON_PRIV)
00008827                          1752  * and are located at the top of RAM (RAM_BASE+RAM_LEN).
00008827                          1753  *******************************************************************************
00008827                          1754  
001FF800                          1755      ORG     STACK_START
001FF800                          1756  
001FF800                          1757  * keep these serial rx queue variables in this order
001FF800                          1758  ser0RxQueue:
001FF800                          1759  ser0RxHead: ds.w    1
001FF802                          1760  ser0RxTail: ds.w    1
001FF804                          1761  ser0RxSize: ds.w    1
001FF806                          1762  ser0RxBuf:  ds.b    SERIAL_BUFFER_SIZE
001FF906                          1763  
001FF906                          1764  msgASCIIDump:
001FF906                          1765      ds.b 20
001FF91A                          1766  
001FF91A                          1767      
001FF91A                          1768      END    START                * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACR                 D00009
AEMSG1              76D2
AEMSG2              7716
AV1MSG              7748
AV2MSG              7784
AV3MSG              77C0
AV4MSG              77FC
AV5MSG              7838
AV6MSG              7874
AV7MSG              78B0
BAUD_1200           66
BAUD_2400           88
BAUD_38400          CC
BAUD_4800           99
BAUD_9600           BB
BAUD_RATE           CC
BCNT                D0001D
BEMSG1              78EC
BEMSG2              792B
BIOS_PRIV           1000
CCP_BSS_BASE        1FD800
CCP_PRIV            1000
CF_8BIT             1
CF_COMMAND          F8002F
CF_CYL_HI           F8002B
CF_CYL_LOW          F80029
CF_DATA             F80021
CF_ERROR            F80023
CF_FEATURES         F80023
CF_HEAD             F8002D
CF_LBA0007          F80027
CF_LBA0815          F80029
CF_LBA1623          F8002B
CF_LBA2427          F8002D
CF_LBAMODE          E0
CF_NOCACHE          82
CF_RD_SEC           20
CF_SECCOUNT         F80025
CF_SECTOR           F80027
CF_SET_FEAT         EF
CF_STATUS           F8002F
CF_WR_SEC           30
CHTOUPPER           8232
CHTOUPPER:DONE      8242
CIMSG               795D
CMDBOOTEHBASIC      7F90
CMDBOOTEHBASIC:BOOTEHBASIC  7FA6
CMDBOOTEHBASIC:FOREVER  7FB6
CMDDISPMEMORY       7FB8
CMDDOWNLOAD         80EC
CMDDOWNLOAD:CDL_1   815A
CMDDOWNLOAD:CDL_2   8170
CMDDOWNLOAD:CDL_EOL  8198
CMDDOWNLOAD:CDL_EOL89  81AA
CMDDOWNLOAD:CDL_S1  8110
CMDDOWNLOAD:CDL_S2  8134
CMDDOWNLOAD:CDL_X   818C
CMDHELP             81C0
CMDIOREAD           8002
CMDIOWRITE          80A2
CMDMODIFYMEMORY     8044
CMDMODIFYMEMORY:CMM_1  8066
CMDMODIFYMEMORY:CMM_2  809A
CMDRUN              7FDA
CPM_BASE            400
CR                  D
CRA                 D00005
CRB                 D00015
CSRA                D00003
CSRB                D00013
DUART1              D00000
DUMPRAM             81CC
DUMPRAM:DR_1        81DA
DUMPRAM:DR_2        81F2
EASY68KTASKTABLE    83EA
EASY68KTRAP15       84DA
EASYTASK0           8476
EASYTASK0:END       8488
EASYTASK0:LOOP      847C
EASYTASK1           848E
EASYTASK10          8452
EASYTASK11          8452
EASYTASK12          8452
EASYTASK13          84BE
EASYTASK13:END      84C8
EASYTASK13:LOOP     84BE
EASYTASK14          84CE
EASYTASK14:END      84D8
EASYTASK14:LOOP     84CE
EASYTASK15          8452
EASYTASK16          8452
EASYTASK17          8452
EASYTASK18          8452
EASYTASK19          8452
EASYTASK1:END       84A0
EASYTASK1:LOOP      8494
EASYTASK2           8452
EASYTASK20          8452
EASYTASK21          8452
EASYTASK22          8452
EASYTASK23          8452
EASYTASK24          8452
EASYTASK25          8452
EASYTASK3           8452
EASYTASK4           8452
EASYTASK5           84A2
EASYTASK6           84AA
EASYTASK7           84B2
EASYTASK8           8452
EASYTASK9           8452
EASYTASKUNSUPPORTED  8452
EASYTASKUNSUPPORTED:INFLOOP  8474
ECNT                D0001F
EHBASIC_BASE        9000
GETC                83A8
GETEXIT             83E4
HANDLEADDRERR       7590
HANDLEAV1           7600
HANDLEAV2           7608
HANDLEAV3           7610
HANDLEAV4           7618
HANDLEAV5           7620
HANDLEAV6           7628
HANDLEAV7           7630
HANDLEBUSERR        7578
HANDLECHKINST       75B8
HANDLECLEANUP       76C0
HANDLECLEANUP:INFLOOP  76D0
HANDLEILLINST       75A8
HANDLELINEA         75D8
HANDLELINEF         75E0
HANDLEPRIV          75C8
HANDLERES1          75E8
HANDLERES10         75E8
HANDLERES11         75E8
HANDLERES2          75E8
HANDLERES3          75E8
HANDLERES4          75E8
HANDLERES5          75E8
HANDLERES6          75E8
HANDLERES7          75E8
HANDLERES8          75E8
HANDLERES9          75E8
HANDLESPUR          75F8
HANDLETRACE         75D0
HANDLETRAP0         7638
HANDLETRAP1         7640
HANDLETRAP10        7688
HANDLETRAP11        7690
HANDLETRAP12        7698
HANDLETRAP13        76A0
HANDLETRAP14        76A8
HANDLETRAP15        76B0
HANDLETRAP2         7648
HANDLETRAP3         7650
HANDLETRAP4         7658
HANDLETRAP5         7660
HANDLETRAP6         7668
HANDLETRAP7         7670
HANDLETRAP8         7678
HANDLETRAP9         7680
HANDLETRAPV         75C0
HANDLEUNINIT        75F0
HANDLEUNUSED        76B8
HANDLEZERODIV       75B0
HEXTOINT            8256
HEXTOINT:H2I_1      8256
HEXTOINT:H2I_2      827E
HEXTOINT:H2I_ERR    828A
HEXTOINT:H2I_X      8286
HEXTOINTECHO        8290
HEXTOINTECHO:H2I_1  8290
HEXTOINTECHO:H2I_2  82BC
HEXTOINTECHO:H2I_ERR  82C8
HEXTOINTECHO:H2I_X  82C4
HI_SPEED            1
IIMSG               798A
IMR                 D0000B
IO_BASE             F80000
IPR                 D0001B
ISR                 D0000B
IVR                 D00019
JMPADDRERR          7008
JMPAV1              70B8
JMPAV2              70C0
JMPAV3              70C8
JMPAV4              70D0
JMPAV5              70D8
JMPAV6              70E0
JMPAV7              70E8
JMPBUSERR           7000
JMPCHKINST          7020
JMPILLINST          7010
JMPLINEA            7040
JMPLINEF            7048
JMPPRIV             7030
JMPRES1             7050
JMPRES10            70A0
JMPRES11            70A8
JMPRES2             7058
JMPRES3             7060
JMPRES4             7070
JMPRES5             7078
JMPRES6             7080
JMPRES7             7088
JMPRES8             7090
JMPRES9             7098
JMPSPUR             70B0
JMPTRACE            7038
JMPTRAP0            70F0
JMPTRAP1            70F8
JMPTRAP10           7140
JMPTRAP11           7148
JMPTRAP12           7150
JMPTRAP13           7158
JMPTRAP14           7160
JMPTRAP15           7168
JMPTRAP2            7100
JMPTRAP3            7108
JMPTRAP4            7110
JMPTRAP5            7118
JMPTRAP6            7120
JMPTRAP7            7128
JMPTRAP8            7130
JMPTRAP9            7138
JMPTRAPV            7028
JMPUNINIT           7068
JMPUNUSED           7170
JMPZERODIV          7018
LAMSG               79C5
LF                  A
LFMSG               79F5
MAKEPRINTABLE       8244
MAKEPRINTABLE:MP_1  8250
MAKEPRINTABLE:MP_X  8254
MEM_BASE            F00000
MONLOOP             7F1E
MONLOOP_CRLF        7F8A
MONLOOP_NP          7F26
MONSTART            7F0E
MON_BASE            7000
MON_PRIV            800
MRA                 D00001
MRB                 D00011
MSGASCIIDUMP        1FF906
OPCR                D0001B
PUTC                8396
PUTCRLF             853A
PUTSTRING           853E
PUTSTRING:END       8548
PUTSTRING:LOOP      853E
PVMSG               7A25
RAMIVT              7178
RAMVECJUMP          0
RAM_BASE            100000
RAM_LEN             100000
RBA                 D00007
RBB                 D00017
RIMSG               7A62
ROPR                D0001F
SC145               F80020
SC145ADDR           10
SER0RXBUF           1FF806
SER0RXHEAD          1FF800
SER0RXQUEUE         1FF800
SER0RXSIZE          1FF804
SER0RXTAIL          1FF802
SEREXIT             8390
SERIAL_BUFFER_LOWER  19
SERIAL_BUFFER_MASK  FF
SERIAL_BUFFER_SIZE  100
SERIAL_BUFFER_UPPER  C8
SERINIT             82CE
SERISR              8338
SERSAVE             836A
SIMSG               7A94
SOPR                D0001D
SRA                 D00003
SRB                 D00013
STACK_START         1FF800
START               7EE8
START:COPY          7F00
STRBANNER1          854A
STRBASICERR1        87B8
STRBASICRETURN      87EE
STRCOLONSPACE       874A
STRCOMMANDS         85A8
STREASYTASK1        8780
STREASYTASK2        87A1
STRNEWLINE          8747
STRPROMPT           8732
STRUNINITINT        874D
STRUNKCMD           8735
STRUSERRETURN       8764
TBA                 D00007
TBB                 D00017
TR0MSG              7AFF
TR10MSG             7CE9
TR11MSG             7D1B
TR12MSG             7D4D
TR13MSG             7D7F
TR14MSG             7DB1
TR15MSG             7DE3
TR1MSG              7B30
TR2MSG              7B61
TR3MSG              7B92
TR4MSG              7BC3
TR5MSG              7BF4
TR6MSG              7C25
TR7MSG              7C56
TR8MSG              7C87
TR9MSG              7CB8
TRMSG               7AD0
TVMSG               7E15
UIMSG               7E44
USERMSG             7E85
VEC_BASE            100000
VEC_SIZE            400
WRITEADDR24         8506
WRITEADDR32         84FA
WRITEBYTE           8518
WRITENIBBLE         8520
WRITENIBBLE:WN1     852E
WRITEWORD           8510
ZDMSG               7EB3
