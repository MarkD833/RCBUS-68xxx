00004EE8 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 15/01/2026 14:05:05

00000000                             1  *******************************************************************************
00000000                             2  *
00000000                             3  *  ######   #####  #     #                      #####   #####  #    # 
00000000                             4  *  #     # #     # ##   ##  ####  #    #       #     # #     # #   #  
00000000                             5  *  #     # #       # # # # #    # ##   #       #       #     # #  #   
00000000                             6  *  ######  #       #  #  # #    # # #  # ##### ######   #####  ###    
00000000                             7  *  #   #   #       #     # #    # #  # #       #     # #     # #  #   
00000000                             8  *  #    #  #     # #     # #    # #   ##       #     # #     # #   #  
00000000                             9  *  #     #  #####  #     #  ####  #    #        #####   #####  #    # v1.4
00000000                            10  *
00000000                            11  *******************************************************************************
00000000                            12  * This is my own simple monitor program for my RCBus 68000 board. It supports
00000000                            13  * simple S-Record loading as well as memory display & simple memory editing.
00000000                            14  * In addition it allows reading and writing bytes to the RCBus IO space.
00000000                            15  *
00000000                            16  * There's no breakpoints, single stepping or disassembly stuff.
00000000                            17  *******************************************************************************
00000000                            18  * Hardware assumptions:
00000000                            19  *
00000000                            20  * + My RCBus SIO board is used and an MC68681 (or equivalent) SIO chip is
00000000                            21  *   present at the address DUART1 (see devices.inc)
00000000                            22  * + ROM is present at address 0x000000 onwards
00000000                            23  * + RAM is present at address RAM_BASE (see memory.inc)
00000000                            24  *******************************************************************************
00000000                            25  * EEPROM programming:
00000000                            26  *
00000000                            27  * Use EASyBIN to split the S-Record into ODD and EVEN bytes.
00000000                            28  * + The *_0.BIN file goes in the U ROM socket - holding D08..D15
00000000                            29  * + The *_1.BIN file goes in the L ROM socket - holding D00..D07
00000000                            30  *******************************************************************************
00000000                            31  * Exception Handling:
00000000                            32  *
00000000                            33  * ROM starts at 0x000000 and holds the ROM exception vector table that points
00000000                            34  * to the exception handling routines in ROM. These ROM handlers fetch the
00000000                            35  * addresses of the actual exception handling routines from the start of RAM 
00000000                            36  * or wherever VEC_BASE is defined and re-directs execution to that address.
00000000                            37  * Initially the RAM addresses all point back to handlers in ROM but can be
00000000                            38  * overwritten to point to a user supplied handler in RAM. 
00000000                            39  *
00000000                            40  * Some Easy68k TRAP #15 text I/O routines are implemented as follows:
00000000                            41  * Currently only tasks 0,1,5,6,13 & 14 are supported.
00000000                            42  *******************************************************************************
00000000                            43  * EhBASIC Support:
00000000                            44  *
00000000                            45  * The EhBASIC s-record file can be programmed into the EEPROMs at the same
00000000                            46  * time as this monitor and should reside at address EHBASIC_BASE (see memory.inc).
00000000                            47  *******************************************************************************
00000000                            48  * Interrupts:
00000000                            49  *
00000000                            50  * An interrupt handler is setup to handle autovector level 2 interrupts from
00000000                            51  * the DUART. Make sure that the jumper is set on the SIO board for level 2
00000000                            52  * interrupts.
00000000                            53  *******************************************************************************
00000000                            54  
00000000                            55      INCLUDE "..\asm-inc\memory2.inc"
00000000                            56  
00000000  =00004000                 57  MON_BASE        EQU     $4000
00000000                            58  
00000000  =00000400                 59  EHBASIC_BASE    EQU     $0400
00000000                            60  
00000000  =00100000                 61  RAM_BASE        EQU     $100000
00000000  =00100000                 62  RAM_LEN         EQU     $100000
00000000                            63  
00000000  =00100000                 64  VEC_BASE        EQU     RAM_BASE
00000000  =00000400                 65  VEC_SIZE        EQU     $400         * table takes up 1024 bytes
00000000                            66  
00000000  =00F80000                 67  IO_BASE         EQU     $F80000     * I/O space base address = 00F8_0000
00000000                            68  
00000000  =00F00000                 69  MEM_BASE        EQU     $F00000     * Mem space base address = 00F0_0000
00000000                            70  
00000000  =00000800                 71  MON_PRIV        EQU     2048
00000000                            72  
00000000  =001FF800                 73  STACK_START     EQU     RAM_BASE+RAM_LEN-MON_PRIV
00000000                            74  
00000000                            75  -------------------- end include --------------------
00000000                            76      INCLUDE "..\asm-inc\devices.inc"
00000000                            77  
00000000  =00D00000                 78  DUART1      EQU     $D00000
00000000                            79  
00000000  =00000010                 80  SC145ADDR   EQU     $10           * SC145 base address is 0x10
00000000                            81  
00000000  =00F80020                 82  SC145       EQU     IO_BASE+(SC145ADDR<<1)
00000000                            83  
00000000                            84  
00000000  =00D00001                 85  MRA         EQU DUART1+1           * Mode Register A             (R/W)
00000000  =00D00003                 86  SRA         EQU DUART1+3           * Status Register A           (R)
00000000  =00D00003                 87  CSRA        EQU DUART1+3           * Clock Select Register A     (W)
00000000  =00D00005                 88  CRA         EQU DUART1+5           * Commands Register A         (W)
00000000  =00D00007                 89  RBA         EQU DUART1+7           * Receiver Buffer A           (R)
00000000  =00D00007                 90  TBA         EQU DUART1+7           * Transmitter Buffer A        (W)
00000000  =00D00009                 91  ACR         EQU DUART1+9           * Aux. Control Register       (R/W)
00000000  =00D0000B                 92  ISR         EQU DUART1+11          * Interrupt Status Register   (R)
00000000  =00D0000B                 93  IMR         EQU DUART1+11          * Interrupt Mask Register     (W)
00000000  =00D00011                 94  MRB         EQU DUART1+17          * Mode Register B             (R/W)
00000000  =00D00013                 95  SRB         EQU DUART1+19          * Status Register B           (R)
00000000  =00D00013                 96  CSRB        EQU DUART1+19          * Clock Select Register B     (W)
00000000  =00D00015                 97  CRB         EQU DUART1+21          * Commands Register B         (W)
00000000  =00D00017                 98  RBB         EQU DUART1+23          * Reciever Buffer B           (R)
00000000  =00D00017                 99  TBB         EQU DUART1+23          * Transmitter Buffer B        (W)
00000000  =00D00019                100  IVR         EQU DUART1+25          * Interrupt Vector Register   (R/W)
00000000  =00D0001B                101  IPR         EQU DUART1+27          * Input Port Register         (R)
00000000  =00D0001B                102  OPCR        EQU DUART1+27          * Output Port Config Register (W)
00000000  =00D0001D                103  BCNT        EQU DUART1+29          * Start Counter               (R)
00000000  =00D0001D                104  SOPR        EQU DUART1+29          * Set Output Port Register    (W)
00000000  =00D0001F                105  ECNT        EQU DUART1+31          * Stop Counter                (R)
00000000  =00D0001F                106  ROPR        EQU DUART1+31          * Reset Output Port Register  (W)
00000000                           107  
00000000  =00000066                108  BAUD_1200       EQU     $66         * 1200 baud
00000000  =00000088                109  BAUD_2400       EQU     $88         * 2400 baud
00000000  =00000099                110  BAUD_4800       EQU     $99         * 4800 baud
00000000  =000000BB                111  BAUD_9600       EQU     $BB         * 9600 baud
00000000  =000000CC                112  BAUD_38400      EQU     $CC         * 38400 baud
00000000                           113  
00000000  =000000CC                114  BAUD_RATE       EQU     BAUD_38400
00000000                           115  
00000000  =00F80021                116  CF_DATA     EQU SC145+1           * Data               (R/W)
00000000  =00F80023                117  CF_FEATURES EQU SC145+3           * Features           (W)
00000000  =00F80023                118  CF_ERROR    EQU SC145+3           * Error              (R)
00000000  =00F80025                119  CF_SECCOUNT EQU SC145+5           * Sector Count       (R/W)
00000000  =00F80027                120  CF_SECTOR   EQU SC145+7           * Sector Number      (R/W)
00000000  =00F80029                121  CF_CYL_LOW  EQU SC145+9           * Cylinder Low Byte  (R/W) 
00000000  =00F8002B                122  CF_CYL_HI   EQU SC145+11          * Cylinder High Byte (R/W)
00000000  =00F8002D                123  CF_HEAD     EQU SC145+13          * Drive / Head       (R/W)
00000000  =00F8002F                124  CF_STATUS   EQU SC145+15          * Status             (R)
00000000  =00F8002F                125  CF_COMMAND  EQU SC145+15          * Command            (W)
00000000                           126  
00000000  =00F80027                127  CF_LBA0007  EQU SC145+7           * LBA bits 07..00    (R/W)
00000000  =00F80029                128  CF_LBA0815  EQU SC145+9           * LBA bits 15..08    (R/W)
00000000  =00F8002B                129  CF_LBA1623  EQU SC145+11          * LBA bits 23..16    (R/W)
00000000  =00F8002D                130  CF_LBA2427  EQU SC145+13          * LBA bits 27..24    (R/W)
00000000                           131  
00000000  =00000001                132  CF_8BIT     EQU 1                 * Set 8-bit mode
00000000  =00000082                133  CF_NOCACHE  EQU $82               * Disable the cache
00000000                           134  
00000000  =00000020                135  CF_RD_SEC   EQU $20               * Read Sector Command
00000000  =00000030                136  CF_WR_SEC   EQU $30               * Write Sector Command
00000000  =000000EF                137  CF_SET_FEAT EQU $EF               * Set Feature Command
00000000  =000000E0                138  CF_LBAMODE  EQU $E0               * LBA mode
00000000  =000000E0                139  -------------------- end include --------------------
00000000                           140  
00000000                           141  *******************************************************************************
00000000                           142  * The serial port originally ran at 38400 baud for the MC68681 SIO chip.
00000000                           143  * Alternative compatibe chips were made by Philips (SCC68681,SCN68681 & SCC68692)
00000000                           144  * that supported higher baud rates using a special test mode.
00000000                           145  * Set HI_SPEED to 1 to enable 115200 baud or 0 for standard 38400 baud.  
00000000                           146  *******************************************************************************
00000000  =00000001                147  HI_SPEED    equ 1
00000000                           148  
00000000                           149  *******************************************************************************
00000000                           150  * ramVecJump : Macro to "jump" to exception handler in the RAM vector table
00000000                           151  * Parameter \1 is the vector number 
00000000                           152  * Put the handler address held in RAM onto the stack and RET to it
00000000                           153  *******************************************************************************
00000000                           154  ramVecJump  MACRO
00000000                           155      move.l  VEC_BASE+(\1<<2),-(SP)
00000000                           156      rts
00000000                           157      ENDM
00000000                           158  
00000000                           159  *------------------------------------------------------------------------------
00000000                           160  * ASCII control characters
00000000                           161  *------------------------------------------------------------------------------
00000000  =0000000A                162  LF    equ $0A
00000000  =0000000D                163  CR    equ $0D
00000000                           164  
00000000                           165  *------------------------------------------------------------------------------
00000000                           166  * Serial port receive buffer size - must be multiples of 2!
00000000                           167  * UPPER sets max chars in buffer before asking host PC to stop sending.
00000000                           168  * LOWER sets min chars in buffer before asking host PC to start sending again.
00000000                           169  *------------------------------------------------------------------------------
00000000  =00000100                170  SERIAL_BUFFER_SIZE  equ 256
00000000  =000000FF                171  SERIAL_BUFFER_MASK  equ SERIAL_BUFFER_SIZE-1
00000000  =000000C8                172  SERIAL_BUFFER_UPPER equ 200
00000000  =00000019                173  SERIAL_BUFFER_LOWER equ 25
00000000                           174  
00000000                           175  *******************************************************************************
00000000                           176  *
00000000                           177  *  ######  ####### #     #       #     # #######  #####  ####### ####### ######   #####  
00000000                           178  *  #     # #     # ##   ##       #     # #       #     #    #    #     # #     # #     # 
00000000                           179  *  #     # #     # # # # #       #     # #       #          #    #     # #     # #       
00000000                           180  *  ######  #     # #  #  #       #     # #####   #          #    #     # ######   #####  
00000000                           181  *  #   #   #     # #     #        #   #  #       #          #    #     # #   #         # 
00000000                           182  *  #    #  #     # #     #         # #   #       #     #    #    #     # #    #  #     # 
00000000                           183  *  #     # ####### #     #          #    #######  #####     #    ####### #     #  #####  
00000000                           184  *                                                                                       
00000000                           185  *******************************************************************************
00000000                           186  * 68000 ROM Exception Vector Table
00000000                           187  *
00000000                           188  * All exceptions eventually get the handler addresses from the RAM vector table. 
00000000                           189  *******************************************************************************
00000000                           190  
00000000                           191      ORG     $0000
00000000                           192  
00000000= 001FF800                 193      DC.l    STACK_START    * Supervisor stack pointer
00000004= 00004EE8                 194      DC.l    START          * Initial PC    
00000008                           195  
00000008= 00004000                 196      DC.L    jmpBusErr      *02 Bus Error
0000000C= 00004008                 197      DC.L    jmpAddrErr     *03 Address Error
00000010= 00004010                 198      DC.L    jmpIllInst     *04 Illegal Instruction
00000014= 00004018                 199      DC.L    jmpZeroDiv     *05 Zero Divide
00000018= 00004020                 200      DC.L    jmpChkInst     *06 CHK Instruction
0000001C= 00004028                 201      DC.L    jmpTrapV       *07 TRAPV Instruction
00000020= 00004030                 202      DC.L    jmpPriv        *08 Privilege Violation
00000024= 00004038                 203      DC.L    jmpTrace       *09 Trace
00000028= 00004040                 204      DC.L    jmpLineA       *0A Line 1010 Emulator
0000002C= 00004048                 205      DC.L    jmpLineF       *0B Line 1111 Emulator
00000030= 00004050                 206      DC.L    jmpRes1        *0C (Unassigned, Reserved)
00000034= 00004058                 207      DC.L    jmpRes2        *0D (Unassigned, Reserved)
00000038= 00004060                 208      DC.L    jmpRes3        *0E (Unassigned, Reserved)
0000003C= 00004068                 209      DC.L    jmpUnInit      *0F Uninitialized Interrupt Vector
00000040= 00004070                 210      DC.L    jmpRes4        *10 (Unassigned, Reserved)
00000044= 00004078                 211      DC.L    jmpRes5        *11 (Unassigned, Reserved)
00000048= 00004080                 212      DC.L    jmpRes6        *12 (Unassigned, Reserved)
0000004C= 00004088                 213      DC.L    jmpRes7        *13 (Unassigned, Reserved)
00000050= 00004090                 214      DC.L    jmpRes8        *14 (Unassigned, Reserved)
00000054= 00004098                 215      DC.L    jmpRes9        *15 (Unassigned, Reserved)
00000058= 000040A0                 216      DC.L    jmpRes10       *16 (Unassigned, Reserved)
0000005C= 000040A8                 217      DC.L    jmpRes11       *17 (Unassigned, Reserved)
00000060= 000040B0                 218      DC.L    jmpSpur        *18 Spurious Interrupt
00000064= 000040B8                 219      DC.L    jmpAV1         *19 Level 1 Interrupt Autovector
00000068= 000040C0                 220      DC.L    jmpAV2         *1A Level 2 Interrupt Autovector
0000006C= 000040C8                 221      DC.L    jmpAV3         *1B Level 3 Interrupt Autovector
00000070= 000040D0                 222      DC.L    jmpAV4         *1C Level 4 Interrupt Autovector
00000074= 000040D8                 223      DC.L    jmpAV5         *1D Level 5 Interrupt Autovector
00000078= 000040E0                 224      DC.L    jmpAV6         *1E Level 6 Interrupt Autovector
0000007C= 000040E8                 225      DC.L    jmpAV7         *1F Level 7 Interrupt Autovector
00000080= 000040F0                 226      DC.L    jmpTrap0       *20 TRAP #0  Instruction Vector
00000084= 000040F8                 227      DC.L    jmpTrap1       *21 TRAP #1  Instruction Vector
00000088= 00004100                 228      DC.L    jmpTrap2       *22 TRAP #2  Instruction Vector
0000008C= 00004108                 229      DC.L    jmpTrap3       *23 TRAP #3  Instruction Vector
00000090= 00004110                 230      DC.L    jmpTrap4       *24 TRAP #4  Instruction Vector
00000094= 00004118                 231      DC.L    jmpTrap5       *25 TRAP #5  Instruction Vector
00000098= 00004120                 232      DC.L    jmpTrap6       *26 TRAP #6  Instruction Vector
0000009C= 00004128                 233      DC.L    jmpTrap7       *27 TRAP #7  Instruction Vector
000000A0= 00004130                 234      DC.L    jmpTrap8       *28 TRAP #8  Instruction Vector
000000A4= 00004138                 235      DC.L    jmpTrap9       *29 TRAP #9  Instruction Vector
000000A8= 00004140                 236      DC.L    jmpTrap10      *2A TRAP #10 Instruction Vector
000000AC= 00004148                 237      DC.L    jmpTrap11      *2B TRAP #11 Instruction Vector
000000B0= 00004150                 238      DC.L    jmpTrap12      *2C TRAP #12 Instruction Vector
000000B4= 00004158                 239      DC.L    jmpTrap13      *2D TRAP #13 Instruction Vector
000000B8= 00004160                 240      DC.L    jmpTrap14      *2E TRAP #14 Instruction Vector
000000BC= 00004168                 241      DC.L    jmpTrap15      *2E TRAP #15 Instruction Vector
000000C0                           242          
000000C0                           243  *------------------------------------------------------------------------------
000000C0                           244  * Exception Vectors 30 to FF are not used on my system so just point them
000000C0                           245  * all to the default handler.
000000C0                           246  
000000C0= 00004170 00004170 ...    247      DCB.L   208,jmpUnused
00000400                           248  
00000400                           249  *******************************************************************************
00000400                           250  * Place the monitor program after the CP/M BIOS code.
00000400                           251  *******************************************************************************
00000400                           252  
00004000                           253      ORG     MON_BASE
00004000                           254  
00004000                           255  *******************************************************************************
00004000                           256  * The hard coded ROM exception vector table entries point to these individual
00004000                           257  * handlers that then jump to (actually RETurn to) the address specified in the
00004000                           258  * RAM exception vector table.
00004000                           259  *******************************************************************************
00004000                           260  
00004000                           261      ORG     (*+1)&-2    * make sure the table is word aligned
00004000                           262  
00004000                           263m jmpBusErr:  ramVecJump  $02
00004008                           264m jmpAddrErr: ramVecJump  $03
00004010                           265m jmpIllInst: ramVecJump  $04
00004018                           266m jmpZeroDiv: ramVecJump  $05
00004020                           267m jmpChkInst: ramVecJump  $06
00004028                           268m jmpTrapV:   ramVecJump  $07
00004030                           269m jmpPriv:    ramVecJump  $08
00004038                           270m jmpTrace:   ramVecJump  $09
00004040                           271m jmpLineA:   ramVecJump  $0A
00004048                           272m jmpLineF:   ramVecJump  $0B
00004050                           273m jmpRes1:    ramVecJump  $0C
00004058                           274m jmpRes2:    ramVecJump  $0D
00004060                           275m jmpRes3:    ramVecJump  $0E
00004068                           276m jmpUnInit:  ramVecJump  $0F
00004070                           277m jmpRes4:    ramVecJump  $10
00004078                           278m jmpRes5:    ramVecJump  $11
00004080                           279m jmpRes6:    ramVecJump  $12
00004088                           280m jmpRes7:    ramVecJump  $13
00004090                           281m jmpRes8:    ramVecJump  $14
00004098                           282m jmpRes9:    ramVecJump  $15
000040A0                           283m jmpRes10:   ramVecJump  $16
000040A8                           284m jmpRes11:   ramVecJump  $17
000040B0                           285m jmpSpur:    ramVecJump  $18
000040B8                           286m jmpAV1:     ramVecJump  $19
000040C0                           287m jmpAV2:     ramVecJump  $1A
000040C8                           288m jmpAV3:     ramVecJump  $1B
000040D0                           289m jmpAV4:     ramVecJump  $1C
000040D8                           290m jmpAV5:     ramVecJump  $1D
000040E0                           291m jmpAV6:     ramVecJump  $1E
000040E8                           292m jmpAV7:     ramVecJump  $1F
000040F0                           293m jmpTrap0:   ramVecJump  $20
000040F8                           294m jmpTrap1:   ramVecJump  $21
00004100                           295m jmpTrap2:   ramVecJump  $22
00004108                           296m jmpTrap3:   ramVecJump  $23
00004110                           297m jmpTrap4:   ramVecJump  $24
00004118                           298m jmpTrap5:   ramVecJump  $25
00004120                           299m jmpTrap6:   ramVecJump  $26
00004128                           300m jmpTrap7:   ramVecJump  $27
00004130                           301m jmpTrap8:   ramVecJump  $28
00004138                           302m jmpTrap9:   ramVecJump  $29
00004140                           303m jmpTrap10:  ramVecJump  $2A
00004148                           304m jmpTrap11:  ramVecJump  $2B
00004150                           305m jmpTrap12:  ramVecJump  $2C
00004158                           306m jmpTrap13:  ramVecJump  $2D
00004160                           307m jmpTrap14:  ramVecJump  $2E
00004168                           308m jmpTrap15:  ramVecJump  $2F
00004170                           309  
00004170                           310m jmpUnused:  ramVecJump  $30
00004178                           311  
00004178                           312  *******************************************************************************
00004178                           313  *
00004178                           314  *  ######     #    #     #       #     # #######  #####  ####### ####### ######   #####  
00004178                           315  *  #     #   # #   ##   ##       #     # #       #     #    #    #     # #     # #     # 
00004178                           316  *  #     #  #   #  # # # #       #     # #       #          #    #     # #     # #       
00004178                           317  *  ######  #     # #  #  #       #     # #####   #          #    #     # ######   #####  
00004178                           318  *  #   #   ####### #     #        #   #  #       #          #    #     # #   #         # 
00004178                           319  *  #    #  #     # #     #         # #   #       #     #    #    #     # #    #  #     # 
00004178                           320  *  #     # #     # #     #          #    #######  #####     #    ####### #     #  #####  
00004178                           321  *                                                                                       
00004178                           322  *******************************************************************************
00004178                           323  * 68000 RAM Exception Vector Table
00004178                           324  *
00004178                           325  * This is the initial exception vector table that gets copied into RAM.
00004178                           326  * It initially redirects back to the basic exception handlers in ROM until the
00004178                           327  * user program inserts their own exception handler address.
00004178                           328  *******************************************************************************
00004178                           329  
00004178                           330      ORG     (*+1)&-2       * make sure the table is word aligned
00004178                           331  
00004178                           332  ramIVT:
00004178= 001FF800                 333      DC.L    STACK_START    *00 Supervisor stack pointer
0000417C= 00004EE8                 334      DC.L    START          *01 Initial PC    
00004180                           335  
00004180= 00004578                 336      DC.L    handleBusErr   *02 Bus Error
00004184= 00004590                 337      DC.L    handleAddrErr  *03 Address Error
00004188= 000045A8                 338      DC.L    handleIllInst  *04 Illegal Instruction
0000418C= 000045B0                 339      DC.L    handleZeroDiv  *05 Zero Divide
00004190= 000045B8                 340      DC.L    handleChkInst  *06 CHK Instruction
00004194= 000045C0                 341      DC.L    handleTrapV    *07 TRAPV Instruction
00004198= 000045C8                 342      DC.L    handlePriv     *08 Privilege Violation
0000419C= 000045D0                 343      DC.L    handleTrace    *09 Trace
000041A0= 000045D8                 344      DC.L    handleLineA    *0A Line 1010 Emulator
000041A4= 000045E0                 345      DC.L    handleLineF    *0B Line 1111 Emulator
000041A8= 000045E8                 346      DC.L    handleRes1     *0C (Unassigned, Reserved)
000041AC= 000045E8                 347      DC.L    handleRes2     *0D (Unassigned, Reserved)
000041B0= 000045E8                 348      DC.L    handleRes3     *0E (Unassigned, Reserved)
000041B4= 000045F0                 349      DC.L    handleUnInit   *0F Uninitialized Interrupt Vector
000041B8= 000045E8                 350      DC.L    handleRes4     *10 (Unassigned, Reserved)
000041BC= 000045E8                 351      DC.L    handleRes5     *11 (Unassigned, Reserved)
000041C0= 000045E8                 352      DC.L    handleRes6     *12 (Unassigned, Reserved)
000041C4= 000045E8                 353      DC.L    handleRes7     *13 (Unassigned, Reserved)
000041C8= 000045E8                 354      DC.L    handleRes8     *14 (Unassigned, Reserved)
000041CC= 000045E8                 355      DC.L    handleRes9     *15 (Unassigned, Reserved)
000041D0= 000045E8                 356      DC.L    handleRes10    *16 (Unassigned, Reserved)
000041D4= 000045E8                 357      DC.L    handleRes11    *17 (Unassigned, Reserved)
000041D8= 000045F8                 358      DC.L    handleSpur     *18 Spurious Interrupt
000041DC= 00004600                 359      DC.L    handleAV1      *19 Level 1 Interrupt Autovector
000041E0= 00005336                 360      DC.L    serISR         *1A Level 2 Interrupt Autovector
000041E4= 00004610                 361      DC.L    handleAV3      *1B Level 3 Interrupt Autovector
000041E8= 00004618                 362      DC.L    handleAV4      *1C Level 4 Interrupt Autovector
000041EC= 00004620                 363      DC.L    handleAV5      *1D Level 5 Interrupt Autovector
000041F0= 00004628                 364      DC.L    handleAV6      *1E Level 6 Interrupt Autovector
000041F4= 00004630                 365      DC.L    handleAV7      *1F Level 7 Interrupt Autovector
000041F8= 00004638                 366      DC.L    handleTrap0    *20 TRAP #0  Instruction Vector
000041FC= 00004640                 367      DC.L    handleTrap1    *21 TRAP #1  Instruction Vector
00004200= 00004648                 368      DC.L    handleTrap2    *22 TRAP #2  Instruction Vector
00004204= 00004650                 369      DC.L    handleTrap3    *23 TRAP #3  Instruction Vector
00004208= 00004658                 370      DC.L    handleTrap4    *24 TRAP #4  Instruction Vector
0000420C= 00004660                 371      DC.L    handleTrap5    *25 TRAP #5  Instruction Vector
00004210= 00004668                 372      DC.L    handleTrap6    *26 TRAP #6  Instruction Vector
00004214= 00004670                 373      DC.L    handleTrap7    *27 TRAP #7  Instruction Vector
00004218= 00004678                 374      DC.L    handleTrap8    *28 TRAP #8  Instruction Vector
0000421C= 00004680                 375      DC.L    handleTrap9    *29 TRAP #9  Instruction Vector
00004220= 00004688                 376      DC.L    handleTrap10   *2A TRAP #10 Instruction Vector
00004224= 00004690                 377      DC.L    handleTrap11   *2B TRAP #11 Instruction Vector
00004228= 00004698                 378      DC.L    handleTrap12   *2C TRAP #12 Instruction Vector
0000422C= 000046A0                 379      DC.L    handleTrap13   *2D TRAP #13 Instruction Vector
00004230= 000046A8                 380      DC.L    handleTrap14   *2E TRAP #14 Instruction Vector
00004234= 000054E0                 381      DC.L    easy68kTrap15  *2F TRAP #15 Instruction Vector
00004238                           382  
00004238= 000046B8 000046B8 ...    383      DCB.L   208,handleUnused
00004578                           384  
00004578                           385  *******************************************************************************
00004578                           386  * Below are the actual exception handlers that the RAM based vector table
00004578                           387  * initially points to. The user can overwrite the RAM vector table addresses
00004578                           388  * with the address of their own exception handler. These basic handlers simply
00004578                           389  * write a message to the serial port and enter an endless loop.
00004578                           390  *******************************************************************************
00004578                           391  
00004578                           392  *------------------------------------------------------------------------------
00004578                           393  * BUS ERROR handler
00004578                           394  * Print a message showing the PC and address being accessed
00004578                           395  *------------------------------------------------------------------------------
00004578                           396  handleBusErr:
00004578  41FA 0372                397      lea     bemsg1(PC), a0      * A0 = first message address
0000457C  6100 0FC6                398      bsr.w   putString           * display it
00004580  202F 000A                399      move.l  10(a7),d0           * get the program counter 
00004584  6100 0F7A                400      bsr.w   writeAddr32         * display it
00004588                           401      
00004588  41FA 03A1                402      lea     bemsg2(PC), a0      * A0 = second message address
0000458C  6000 0132                403      bra.w   handleCleanUp
00004590                           404      
00004590                           405  *------------------------------------------------------------------------------
00004590                           406  * ADDRESS ERROR handler
00004590                           407  * Print a message showing the PC and address being accessed
00004590                           408  *------------------------------------------------------------------------------
00004590                           409  handleAddrErr:
00004590  41FA 0140                410      lea     aemsg1(PC), a0      * A0 = first message address
00004594  6100 0FAE                411      bsr.w   putString           * display it
00004598  202F 000A                412      move.l  10(a7),d0           * get the program counter 
0000459C  6100 0F62                413      bsr.w   writeAddr32         * display it
000045A0                           414      
000045A0  41FA 0174                415      lea     aemsg2(PC), a0      * A0 = second message address
000045A4  6000 011A                416      bra.w   handleCleanUp
000045A8                           417      
000045A8                           418  *------------------------------------------------------------------------------
000045A8                           419  * ILLEGAL INSTRUCTION handler
000045A8                           420  *------------------------------------------------------------------------------
000045A8                           421  handleIllInst:
000045A8  41FA 03E0                422      lea     iimsg(PC), a0       * A0 = address of message to display
000045AC  6000 0112                423      bra.w   handleCleanUp
000045B0                           424      
000045B0                           425  *------------------------------------------------------------------------------
000045B0                           426  * DIVISION BY ZERO handler
000045B0                           427  *------------------------------------------------------------------------------
000045B0                           428  handleZeroDiv:
000045B0  41FA 0901                429      lea     zdmsg(PC), a0       * A0 = address of message to display
000045B4  6000 010A                430      bra.w   handleCleanUp
000045B8                           431      
000045B8                           432  *------------------------------------------------------------------------------
000045B8                           433  * CHK handler
000045B8                           434  *------------------------------------------------------------------------------
000045B8                           435  handleChkInst:
000045B8  41FA 03A3                436      lea     cimsg(PC), a0       * A0 = address of message to display
000045BC  6000 0102                437      bra.w   handleCleanUp
000045C0                           438      
000045C0                           439  *------------------------------------------------------------------------------
000045C0                           440  * TRAPV handler
000045C0                           441  *------------------------------------------------------------------------------
000045C0                           442  handleTrapV:
000045C0  41FA 0853                443      lea     tvmsg(PC), a0       * A0 = address of message to display
000045C4  6000 00FA                444      bra.w   handleCleanUp
000045C8                           445      
000045C8                           446  *------------------------------------------------------------------------------
000045C8                           447  * PRIVILEGE VIOLATION handler
000045C8                           448  *------------------------------------------------------------------------------
000045C8                           449  handlePriv:
000045C8  41FA 045B                450      lea     pvmsg(PC), a0       * A0 = address of message to display
000045CC  6000 00F2                451      bra.w   handleCleanUp
000045D0                           452      
000045D0                           453  *------------------------------------------------------------------------------
000045D0                           454  * TRACE handler
000045D0                           455  *------------------------------------------------------------------------------
000045D0                           456  handleTrace:
000045D0  41FA 04FE                457      lea     trmsg(PC), a0       * A0 = address of message to display
000045D4  6000 00EA                458      bra.w   handleCleanUp
000045D8                           459      
000045D8                           460  *------------------------------------------------------------------------------
000045D8                           461  * Unimplementd Instruction - Line A handler
000045D8                           462  *------------------------------------------------------------------------------
000045D8                           463  handleLineA:
000045D8  41FA 03EB                464      lea     lamsg(PC), a0       * A0 = address of message to display
000045DC  6000 00E2                465      bra.w   handleCleanUp
000045E0                           466      
000045E0                           467  *------------------------------------------------------------------------------
000045E0                           468  * Unimplementd Instruction - Line F handler
000045E0                           469  *------------------------------------------------------------------------------
000045E0                           470  handleLineF:
000045E0  41FA 0413                471      lea     lfmsg(PC), a0       * A0 = address of message to display
000045E4  6000 00DA                472      bra.w   handleCleanUp
000045E8                           473      
000045E8                           474  *------------------------------------------------------------------------------
000045E8                           475  * Reserved Instruction handler
000045E8                           476  *------------------------------------------------------------------------------
000045E8                           477  handleRes1:
000045E8                           478  handleRes2:
000045E8                           479  handleRes3:
000045E8                           480  handleRes4:
000045E8                           481  handleRes5:
000045E8                           482  handleRes6:
000045E8                           483  handleRes7:
000045E8                           484  handleRes8:
000045E8                           485  handleRes9:
000045E8                           486  handleRes10:
000045E8                           487  handleRes11:
000045E8  41FA 0478                488      lea     rimsg(PC), a0       * A0 = address of message to display
000045EC  6000 00D2                489      bra.w   handleCleanUp
000045F0                           490      
000045F0                           491  *------------------------------------------------------------------------------
000045F0                           492  * Uninitialised Interrupt handler
000045F0                           493  *------------------------------------------------------------------------------
000045F0                           494  handleUnInit:
000045F0  41FA 0852                495      lea     uimsg(PC), a0       * A0 = address of message to display
000045F4  6000 00CA                496      bra.w   handleCleanUp
000045F8                           497      
000045F8                           498  *------------------------------------------------------------------------------
000045F8                           499  * Spurious Interrupt handler
000045F8                           500  *------------------------------------------------------------------------------
000045F8                           501  handleSpur:
000045F8  41FA 049A                502      lea     simsg(PC), a0       * A0 = address of message to display
000045FC  6000 00C2                503      bra.w   handleCleanUp
00004600                           504      
00004600                           505  *------------------------------------------------------------------------------
00004600                           506  * Autovector Level 1 Exception handler
00004600                           507  *------------------------------------------------------------------------------
00004600                           508  handleAV1:
00004600  41FA 0146                509      lea     av1msg(PC), a0      * A0 = address of message to display
00004604  6000 00BA                510      bra.w   handleCleanUp
00004608                           511  
00004608                           512  *------------------------------------------------------------------------------
00004608                           513  * Autovector Level 2 Exception handler
00004608                           514  *------------------------------------------------------------------------------
00004608                           515  handleAV2:
00004608  41FA 017A                516      lea     av2msg(PC), a0      * A0 = address of message to display
0000460C  6000 00B2                517      bra.w   handleCleanUp
00004610                           518  
00004610                           519  *------------------------------------------------------------------------------
00004610                           520  * Autovector Level 3 Exception handler
00004610                           521  *------------------------------------------------------------------------------
00004610                           522  handleAV3:
00004610  41FA 01AE                523      lea     av3msg(PC), a0      * A0 = address of message to display
00004614  6000 00AA                524      bra.w   handleCleanUp
00004618                           525  
00004618                           526  *------------------------------------------------------------------------------
00004618                           527  * Autovector Level 4 Exception handler
00004618                           528  *------------------------------------------------------------------------------
00004618                           529  handleAV4:
00004618  41FA 01E2                530      lea     av4msg(PC), a0      * A0 = address of message to display
0000461C  6000 00A2                531      bra.w   handleCleanUp
00004620                           532  
00004620                           533  *------------------------------------------------------------------------------
00004620                           534  * Autovector Level 5 Exception handler
00004620                           535  *------------------------------------------------------------------------------
00004620                           536  handleAV5:
00004620  41FA 0216                537      lea     av5msg(PC), a0      * A0 = address of message to display
00004624  6000 009A                538      bra.w   handleCleanUp
00004628                           539  
00004628                           540  *------------------------------------------------------------------------------
00004628                           541  * Autovector Level 6 Exception handler
00004628                           542  *------------------------------------------------------------------------------
00004628                           543  handleAV6:
00004628  41FA 024A                544      lea     av6msg(PC), a0      * A0 = address of message to display
0000462C  6000 0092                545      bra.w   handleCleanUp
00004630                           546  
00004630                           547  *------------------------------------------------------------------------------
00004630                           548  * Autovector Level 7 Exception handler
00004630                           549  *------------------------------------------------------------------------------
00004630                           550  handleAV7:
00004630  41FA 027E                551      lea     av7msg(PC), a0      * A0 = address of message to display
00004634  6000 008A                552      bra.w   handleCleanUp
00004638                           553      
00004638                           554  *------------------------------------------------------------------------------
00004638                           555  * TRAP #0 Exception handler
00004638                           556  *------------------------------------------------------------------------------
00004638                           557  handleTrap0:
00004638  41FA 04C5                558      lea     tr0msg(PC), a0      * A0 = address of message to display
0000463C  6000 0082                559      bra.w   handleCleanUp
00004640                           560  
00004640                           561  *------------------------------------------------------------------------------
00004640                           562  * TRAP #1 Exception handler
00004640                           563  *------------------------------------------------------------------------------
00004640                           564  handleTrap1:
00004640  41FA 04EE                565      lea     tr1msg(PC), a0      * A0 = address of message to display
00004644  6000 007A                566      bra.w   handleCleanUp
00004648                           567  
00004648                           568  *------------------------------------------------------------------------------
00004648                           569  * TRAP #2 Exception handler
00004648                           570  *------------------------------------------------------------------------------
00004648                           571  handleTrap2:
00004648  41FA 0517                572      lea     tr2msg(PC), a0      * A0 = address of message to display
0000464C  6000 0072                573      bra.w   handleCleanUp
00004650                           574  
00004650                           575  *------------------------------------------------------------------------------
00004650                           576  * TRAP #3 Exception handler
00004650                           577  *------------------------------------------------------------------------------
00004650                           578  handleTrap3:
00004650  41FA 0540                579      lea     tr3msg(PC), a0      * A0 = address of message to display
00004654  6000 006A                580      bra.w   handleCleanUp
00004658                           581  
00004658                           582  *------------------------------------------------------------------------------
00004658                           583  * TRAP #4 Exception handler
00004658                           584  *------------------------------------------------------------------------------
00004658                           585  handleTrap4:
00004658  41FA 0569                586      lea     tr4msg(PC), a0      * A0 = address of message to display
0000465C  6000 0062                587      bra.w   handleCleanUp
00004660                           588  
00004660                           589  *------------------------------------------------------------------------------
00004660                           590  * TRAP #5 Exception handler
00004660                           591  *------------------------------------------------------------------------------
00004660                           592  handleTrap5:
00004660  41FA 0592                593      lea     tr5msg(PC), a0      * A0 = address of message to display
00004664  6000 005A                594      bra.w   handleCleanUp
00004668                           595  
00004668                           596  *------------------------------------------------------------------------------
00004668                           597  * TRAP #6 Exception handler
00004668                           598  *------------------------------------------------------------------------------
00004668                           599  handleTrap6:
00004668  41FA 05BB                600      lea     tr6msg(PC), a0      * A0 = address of message to display
0000466C  6000 0052                601      bra.w   handleCleanUp
00004670                           602  
00004670                           603  *------------------------------------------------------------------------------
00004670                           604  * TRAP #7 Exception handler
00004670                           605  *------------------------------------------------------------------------------
00004670                           606  handleTrap7:
00004670  41FA 05E4                607      lea     tr7msg(PC), a0      * A0 = address of message to display
00004674  6000 004A                608      bra.w   handleCleanUp
00004678                           609  
00004678                           610  *------------------------------------------------------------------------------
00004678                           611  * TRAP #8 Exception handler
00004678                           612  *------------------------------------------------------------------------------
00004678                           613  handleTrap8:
00004678  41FA 060D                614      lea     tr8msg(PC), a0      * A0 = address of message to display
0000467C  6000 0042                615      bra.w   handleCleanUp
00004680                           616  
00004680                           617  *------------------------------------------------------------------------------
00004680                           618  * TRAP #9 Exception handler
00004680                           619  *------------------------------------------------------------------------------
00004680                           620  handleTrap9:
00004680  41FA 0636                621      lea     tr9msg(PC), a0      * A0 = address of message to display
00004684  6000 003A                622      bra.w   handleCleanUp
00004688                           623  
00004688                           624  *------------------------------------------------------------------------------
00004688                           625  * TRAP #10 Exception handler
00004688                           626  *------------------------------------------------------------------------------
00004688                           627  handleTrap10:
00004688  41FA 065F                628      lea     tr10msg(PC), a0     * A0 = address of message to display
0000468C  6000 0032                629      bra.w   handleCleanUp
00004690                           630  
00004690                           631  *------------------------------------------------------------------------------
00004690                           632  * TRAP #11 Exception handler
00004690                           633  *------------------------------------------------------------------------------
00004690                           634  handleTrap11:
00004690  41FA 0689                635      lea     tr11msg(PC), a0     * A0 = address of message to display
00004694  6000 002A                636      bra.w   handleCleanUp
00004698                           637  
00004698                           638  *------------------------------------------------------------------------------
00004698                           639  * TRAP #12 Exception handler
00004698                           640  *------------------------------------------------------------------------------
00004698                           641  handleTrap12:
00004698  41FA 06B3                642      lea     tr12msg(PC), a0     * A0 = address of message to display
0000469C  6000 0022                643      bra.w   handleCleanUp
000046A0                           644      
000046A0                           645  *------------------------------------------------------------------------------
000046A0                           646  * TRAP #13 Exception handler
000046A0                           647  *------------------------------------------------------------------------------
000046A0                           648  handleTrap13:
000046A0  41FA 06DD                649      lea     tr13msg(PC), a0     * A0 = address of message to display
000046A4  6000 001A                650      bra.w   handleCleanUp
000046A8                           651      
000046A8                           652  *------------------------------------------------------------------------------
000046A8                           653  * TRAP #14 Exception handler
000046A8                           654  *------------------------------------------------------------------------------
000046A8                           655  handleTrap14:
000046A8  41FA 0707                656      lea     tr14msg(PC), a0     * A0 = address of message to display
000046AC  6000 0012                657      bra.w   handleCleanUp
000046B0                           658      
000046B0                           659  *------------------------------------------------------------------------------
000046B0                           660  * TRAP #15 Exception handler
000046B0                           661  *------------------------------------------------------------------------------
000046B0                           662  handleTrap15:
000046B0  41FA 0731                663      lea     tr15msg(PC), a0     * A0 = address of message to display
000046B4  6000 000A                664      bra.w   handleCleanUp
000046B8                           665      
000046B8                           666  *------------------------------------------------------------------------------
000046B8                           667  * User Exception handler - all remaining exception handlers land here
000046B8                           668  *------------------------------------------------------------------------------
000046B8                           669  handleUnused:
000046B8  41FA 07CB                670      lea     usermsg(PC), a0     * A0 = address of message to display
000046BC  6000 0002                671      bra.w   handleCleanUp
000046C0                           672      
000046C0                           673  *------------------------------------------------------------------------------
000046C0                           674  * All exception handlers jump here to output the PC of the next instruction
000046C0                           675  * after the exception occured.
000046C0                           676  * A0 holds the address of a null terminated message to be displayed first.
000046C0                           677  *------------------------------------------------------------------------------
000046C0                           678  handleCleanUp:
000046C0  6100 0E82                679      bsr.w   putString           * print out the relevant message
000046C4  202F 0002                680      move.l  2(a7),d0            * get the saved PC address
000046C8  6100 0E36                681      bsr.w   writeAddr32         * and display it
000046CC  6100 0E72                682      bsr.w   putCRLF
000046D0                           683  .infloop:
000046D0  60FE                     684      bra.s   .infloop            * and stay here forever ...
000046D2                           685  
000046D2                           686  *******************************************************************************
000046D2                           687  * Exception handler messages
000046D2                           688  *******************************************************************************
000046D2= 0A 0D 53 54 4F 50 ...    689  aemsg1:  dc.b   10,13,'STOP: An Address Error occured whilst executing code at address $',0
00004716= 0A 0D 53 54 4F 50 ...    690  aemsg2:  dc.b   10,13,'STOP: The address location being accessed was $',0
00004748= 0A 0D 53 54 4F 50 ...    691  av1msg:  dc.b   10,13,'STOP: Autovector Level 1 exception occured near address $',0
00004784= 0A 0D 53 54 4F 50 ...    692  av2msg:  dc.b   10,13,'STOP: Autovector Level 2 exception occured near address $',0
000047C0= 0A 0D 53 54 4F 50 ...    693  av3msg:  dc.b   10,13,'STOP: Autovector Level 3 exception occured near address $',0
000047FC= 0A 0D 53 54 4F 50 ...    694  av4msg:  dc.b   10,13,'STOP: Autovector Level 4 exception occured near address $',0
00004838= 0A 0D 53 54 4F 50 ...    695  av5msg:  dc.b   10,13,'STOP: Autovector Level 5 exception occured near address $',0
00004874= 0A 0D 53 54 4F 50 ...    696  av6msg:  dc.b   10,13,'STOP: Autovector Level 6 exception occured near address $',0
000048B0= 0A 0D 53 54 4F 50 ...    697  av7msg:  dc.b   10,13,'STOP: Autovector Level 7 exception occured near address $',0
000048EC= 0A 0D 53 54 4F 50 ...    698  bemsg1:  dc.b   10,13,'STOP: A Bus Error occured whilst executing code at address $',0
0000492B= 0A 0D 20 20 20 20 ...    699  bemsg2:  dc.b   10,13,'    : The address location being accessed was $',0
0000495D= 0A 0D 53 54 4F 50 ...    700  cimsg:   dc.b   10,13,'STOP: CHK exception occured near address $',0
0000498A= 0A 0D 53 54 4F 50 ...    701  iimsg:   dc.b   10,13,'STOP: Illegal Instruction was encountered near address $',0
000049C5= 0A 0D 53 54 4F 50 ...    702  lamsg:   dc.b   10,13,'STOP: LINE A exception occured near address $',0
000049F5= 0A 0D 53 54 4F 50 ...    703  lfmsg:   dc.b   10,13,'STOP: LINE F exception occured near address $',0
00004A25= 0A 0D 53 54 4F 50 ...    704  pvmsg:   dc.b   10,13,'STOP: Privilege Viloation exception occured near address $',0
00004A62= 0A 0D 53 54 4F 50 ...    705  rimsg:   dc.b   10,13,'STOP: Reserved exception occured near address $',0
00004A94= 0A 0D 53 54 4F 50 ...    706  simsg:   dc.b   10,13,'STOP: Spurious Interrupt exception occured near address $',0
00004AD0= 0A 0D 53 54 4F 50 ...    707  trmsg:   dc.b   10,13,'STOP: TRACE exception occured near address $',0
00004AFF= 0A 0D 53 54 4F 50 ...    708  tr0msg:  dc.b   10,13,'STOP: TRAP #0 exception occured near address $',0
00004B30= 0A 0D 53 54 4F 50 ...    709  tr1msg:  dc.b   10,13,'STOP: TRAP #1 exception occured near address $',0
00004B61= 0A 0D 53 54 4F 50 ...    710  tr2msg:  dc.b   10,13,'STOP: TRAP #2 exception occured near address $',0
00004B92= 0A 0D 53 54 4F 50 ...    711  tr3msg:  dc.b   10,13,'STOP: TRAP #3 exception occured near address $',0
00004BC3= 0A 0D 53 54 4F 50 ...    712  tr4msg:  dc.b   10,13,'STOP: TRAP #4 exception occured near address $',0
00004BF4= 0A 0D 53 54 4F 50 ...    713  tr5msg:  dc.b   10,13,'STOP: TRAP #5 exception occured near address $',0
00004C25= 0A 0D 53 54 4F 50 ...    714  tr6msg:  dc.b   10,13,'STOP: TRAP #6 exception occured near address $',0
00004C56= 0A 0D 53 54 4F 50 ...    715  tr7msg:  dc.b   10,13,'STOP: TRAP #7 exception occured near address $',0
00004C87= 0A 0D 53 54 4F 50 ...    716  tr8msg:  dc.b   10,13,'STOP: TRAP #8 exception occured near address $',0
00004CB8= 0A 0D 53 54 4F 50 ...    717  tr9msg:  dc.b   10,13,'STOP: TRAP #9 exception occured near address $',0
00004CE9= 0A 0D 53 54 4F 50 ...    718  tr10msg: dc.b   10,13,'STOP: TRAP #10 exception occured near address $',0
00004D1B= 0A 0D 53 54 4F 50 ...    719  tr11msg: dc.b   10,13,'STOP: TRAP #11 exception occured near address $',0
00004D4D= 0A 0D 53 54 4F 50 ...    720  tr12msg: dc.b   10,13,'STOP: TRAP #12 exception occured near address $',0
00004D7F= 0A 0D 53 54 4F 50 ...    721  tr13msg: dc.b   10,13,'STOP: TRAP #13 exception occured near address $',0
00004DB1= 0A 0D 53 54 4F 50 ...    722  tr14msg: dc.b   10,13,'STOP: TRAP #14 exception occured near address $',0
00004DE3= 0A 0D 53 54 4F 50 ...    723  tr15msg: dc.b   10,13,'STOP: TRAP #15 exception occured near address $',0
00004E15= 0A 0D 53 54 4F 50 ...    724  tvmsg:   dc.b   10,13,'STOP: TRAPV exception occured near address $',0
00004E44= 0A 0D 53 54 4F 50 ...    725  uimsg:   dc.b   10,13,'STOP: Uninitialised Interrupt exception occured near address $',0
00004E85= 0A 0D 53 54 4F 50 ...    726  usermsg: dc.b   10,13,'STOP: User exception occured near address $',0
00004EB3= 0A 0D 53 54 4F 50 ...    727  zdmsg:   dc.b   10,13,'STOP: Divide By Zero error occured near address $',0
00004EE7                           728  
00004EE7                           729  *******************************************************************************
00004EE7                           730  *
00004EE7                           731  *   #####  ####### #       ######         #####  #######    #    ######  ####### 
00004EE7                           732  *  #     # #     # #       #     #       #     #    #      # #   #     #    #    
00004EE7                           733  *  #       #     # #       #     #       #          #     #   #  #     #    #    
00004EE7                           734  *  #       #     # #       #     #        #####     #    #     # ######     #    
00004EE7                           735  *  #       #     # #       #     #             #    #    ####### #   #      #    
00004EE7                           736  *  #     # #     # #       #     #       #     #    #    #     # #    #     #    
00004EE7                           737  *   #####  ####### ####### ######         #####     #    #     # #     #    #    
00004EE7                           738  *                                                                               
00004EE7                           739  *******************************************************************************
00004EE7                           740  * Monitor execution starts here after power-on or a reset.
00004EE7                           741  *******************************************************************************
00004EE7                           742  
00004EE8                           743      ORG     (*+1)&-2    * make sure we start on a word aligned address
00004EE8                           744  START:
00004EE8  4FF9 001FF800            745      lea     STACK_START, sp     * Set the stack pointer just in case
00004EEE                           746  
00004EEE                           747      * copy the RAM exception vector table into RAM
00004EEE  207C 00004178            748      move.l  #ramIVT,a0          * start of RAM exception table in ROM
00004EF4  227C 00100000            749      move.l  #VEC_BASE,a1        * location in RAM to copy table to
00004EFA  203C 000000FF            750      move.l  #255,d0             * 256 entries to copy
00004F00                           751  .copy:
00004F00  22D8                     752      move.l  (a0)+,(a1)+         * copy the byte from ROM to RAM
00004F02  51C8 FFFC                753      dbra    d0,.copy
00004F06                           754  
00004F06  6100 03C4                755      bsr.w   serInit             * initialise serial port
00004F0A  46FC 2000                756      move.w  #$2000,sr           * enable interrupts
00004F0E                           757  
00004F0E                           758  *------------------------------------------------------------------------------
00004F0E                           759  * Warm Restart entry point
00004F0E                           760  *------------------------------------------------------------------------------
00004F0E                           761  monStart:
00004F0E  41FA 0640                762      lea     strBanner1(PC), a0  * Show the monitor details
00004F12  6100 0630                763      bsr.w   putString
00004F16                           764  
00004F16  41FA 0696                765      lea     strCommands(PC), a0 * And the command help message
00004F1A  6100 0628                766      bsr.w   putString
00004F1E                           767  
00004F1E                           768  monLoop:
00004F1E  41FA 0818                769      lea     strPrompt(PC), a0   * Prompt
00004F22  6100 0620                770      bsr.w   putString
00004F26                           771  
00004F26                           772  monLoop_NP:
00004F26  6100 047E                773      bsr.w   getc                * get a character into D0
00004F2A  6100 0304                774      bsr.w   chToUpper           * convert character to upper case
00004F2E                           775      
00004F2E  0C00 000A                776      cmpi.b  #LF,d0              * ignore Line-Feed
00004F32  67EA                     777      beq.s   monLoop
00004F34                           778      
00004F34  B03C 0042                779      cmp.b   #'B', d0            * Boot EhBASIC v3.54
00004F38  6700 0056                780      beq.w   cmdBootEHBASIC
00004F3C                           781  
00004F3C  B03C 0044                782      cmp.b   #'D', d0            * Dump memory command
00004F40  6700 0074                783      beq.w   cmdDispMemory
00004F44                           784  
00004F44  B03C 0049                785      cmp.b   #'I', d0            * Read from I/O space address
00004F48  6700 00B6                786      beq.w   cmdIORead
00004F4C                           787  
00004F4C  B03C 004D                788      cmp.b   #'M', d0            * Modify memory command
00004F50  6700 00F0                789      beq.w   cmdModifyMemory
00004F54                           790  
00004F54  B03C 004F                791      cmp.b   #'O', d0            * Write to I/O space address
00004F58  6700 0146                792      beq.w   cmdIOWrite
00004F5C                           793  
00004F5C  B03C 0053                794      cmp.b   #'S', d0            * S record download
00004F60  6700 0188                795      beq.w   cmdDownload
00004F64                           796  
00004F64  B03C 0047                797      cmp.b   #'G', d0            * Go command
00004F68  6700 006E                798      beq.w   cmdRun
00004F6C                           799  
00004F6C  B03C 003F                800      cmp.b   #'?', d0            * Help command
00004F70  6700 024C                801      beq.w   cmdHelp
00004F74                           802  
00004F74  B03C 0020                803      cmp.b   #' ', d0            * Ignore spaces
00004F78  6FAC                     804      ble.s   monLoop_NP          * go back without printing prompt    
00004F7A                           805  
00004F7A  1200                     806      move.b  d0,d1               * save the unknown char
00004F7C  41FA 07BD                807      lea     strUnkCmd(PC), a0   * unknown command
00004F80  6100 05C2                808      bsr.w   putString
00004F84  1001                     809      move.b  d1,d0               * get unnknown char back
00004F86  6100 0596                810      bsr.w   writeByte           * print it
00004F8A                           811      
00004F8A                           812  monLoop_CRLF:
00004F8A  6100 05B4                813      bsr.w   putCRLF
00004F8E  608E                     814      bra.s   monLoop
00004F90                           815      
00004F90                           816  *------------------------------------------------------------------------------
00004F90                           817  * (B) Boot EhBASIC v3.54
00004F90                           818  *------------------------------------------------------------------------------
00004F90                           819  cmdBootEHBASIC:
00004F90                           820      * Perform a simple check to see if EhBASIC has been programmed into the
00004F90                           821      * EEPROM by reading the first address of EhBASIC in the EEPROM. If it
00004F90                           822      * contains 0xFFFF, then EhBASIC hasn't been programmed in!
00004F90  0C78 FFFF 0400           823      cmpi.w  #$FFFF,EHBASIC_BASE
00004F96  660C                     824      bne.s   .bootEHBASIC
00004F98  41FA 0824                825      lea     strBASICErr1(PC), a0
00004F9C  6100 05A6                826      bsr.w   putString
00004FA0  6000 FF7C                827      bra.w   monLoop
00004FA4                           828  
00004FA4                           829  .bootEHBASIC:
00004FA4  207C 00000400            830      move.l  #EHBASIC_BASE,a0
00004FAA  4E90                     831      jsr     (a0)                * jump to EhBASIC 
00004FAC                           832  
00004FAC                           833      * I don't think EhBASIC can return back to the monitor but just in case it can
00004FAC                           834      * print out a message and wait for a reset.
00004FAC  41FA 0846                835      lea     strBASICReturn(PC), a0
00004FB0  6100 0592                836      bsr.w   putString
00004FB4                           837  .forever:
00004FB4  60FE                     838      bra.s   .forever
00004FB6                           839  
00004FB6                           840  *------------------------------------------------------------------------------
00004FB6                           841  * (D)ump memory
00004FB6                           842  * Display 256 bytes of memory as ASCII-HEX characters
00004FB6                           843  *------------------------------------------------------------------------------
00004FB6                           844  cmdDispMemory:
00004FB6  6100 03DC                845      bsr.w   putc                * echo back the command character in D0
00004FBA  103C 0020                846      move.b  #' ',d0
00004FBE  6100 03D4                847      bsr.w   putc
00004FC2                           848      
00004FC2  4282                     849      clr.l   d2                  * pre-set D2 to 0
00004FC4  7208                     850      move.l  #8,d1               * read up to 8 digits
00004FC6  6100 02C6                851      bsr.w   hexToIntEcho        * from the serial port into D0
00004FCA  6500 FF52                852      bcs.w   monLoop             * back to prompt if there's an error
00004FCE                           853      
00004FCE  2040                     854      move.l  d0,a0               * A0 holds the start address
00004FD0  6100 01F8                855      bsr.w   dumpRAM
00004FD4                           856  
00004FD4  6000 FF48                857      bra.w   monLoop
00004FD8                           858  
00004FD8                           859  *------------------------------------------------------------------------------
00004FD8                           860  * (G)o - execute code in memory starting at the specified address
00004FD8                           861  *------------------------------------------------------------------------------
00004FD8                           862  cmdRun:
00004FD8  6100 03BA                863      bsr.w   putc                * echo back the command character in D0
00004FDC  103C 0020                864      move.b  #' ',d0
00004FE0  6100 03B2                865      bsr.w   putc
00004FE4                           866  
00004FE4  4282                     867      clr.l   d2                  * pre-set D2 to 0
00004FE6  7208                     868      move.l  #8,d1               * read up to 8 digits
00004FE8  6100 02A4                869      bsr.w   hexToIntEcho        * from the serial port
00004FEC  6500 FF30                870      bcs.w   monLoop             * back to prompt if there's an error
00004FF0                           871  
00004FF0  2040                     872      move.l  d0, a0              * copy start address into A0
00004FF2  4E90                     873      jsr     (a0)                * jump to user code
00004FF4                           874      
00004FF4  41FA 0774                875      lea     strUserReturn(PC),a0
00004FF8  6100 054A                876      bsr.w   putString
00004FFC                           877      
00004FFC  6000 FF20                878      bra.w   monLoop
00005000                           879  
00005000                           880  *------------------------------------------------------------------------------
00005000                           881  * (I)nput a byte from I/O space address
00005000                           882  *------------------------------------------------------------------------------
00005000                           883  cmdIORead:
00005000  6100 0392                884      bsr.w   putc                * echo back the command character in D0
00005004  103C 0020                885      move.b  #' ',d0
00005008  6100 038A                886      bsr.w   putc
0000500C                           887  
0000500C  4282                     888      clr.l   d2                  * pre-set D2 to 0
0000500E  7202                     889      move.l  #2,d1               * read up to 2 digit address
00005010  6100 027C                890      bsr.w   hexToIntEcho        * from the serial port
00005014  6500 FF08                891      bcs.w   monLoop             * back to prompt if there's an error
00005018  1600                     892      move.b  d0,d3               * save the typed in 8-bit address
0000501A  103C 003D                893      move.b  #'=',d0
0000501E  6100 0374                894      bsr.w   putc                * send an EQUALS
00005022                           895  
00005022                           896      ; D3 = 8-bit address
00005022  207C 00F80000            897      movea.l #IO_BASE,a0
00005028  0283 000000FF            898      andi.l  #$FF,d3             * clear all the unused bits
0000502E  E383                     899      asl.l   #1,d3               * make it a word offset
00005030  5283                     900      addi.l  #1,d3               * make it an odd address to read from D0..D7
00005032  1030 3000                901      move.b  (0,a0,d3),d0        * and read the new value in
00005036  6100 04E6                902      bsr.w   writeByte           * display the value
0000503A  6100 0504                903      bsr.w   putCRLF
0000503E  6000 FEDE                904      bra.w   monLoop
00005042                           905  
00005042                           906  *------------------------------------------------------------------------------
00005042                           907  * (M)odify memory
00005042                           908  * Change memory contents 1 byte at a time
00005042                           909  *------------------------------------------------------------------------------
00005042                           910  cmdModifyMemory:
00005042  6100 0350                911      bsr.w   putc                * echo back the command character in D0
00005046  103C 0020                912      move.b  #' ',d0
0000504A  6100 0348                913      bsr.w   putc
0000504E                           914  
0000504E  4282                     915      clr.l   d2                  * pre-set D2 to 0
00005050  7208                     916      move.l  #8,d1               * read up to 8 digits
00005052  6100 023A                917      bsr.w   hexToIntEcho        * from the serial port
00005056  6500 FEC6                918      bcs.w   monLoop             * back to prompt if there's an error
0000505A  1200                     919      move.b  d0,d1               * save the typed in address
0000505C  6100 04E2                920      bsr.w   putCRLF
00005060  1001                     921      move.b  d1,d0               * restore the typed in address
00005062                           922      
00005062  2040                     923      move.l  d0,a0               * copy address into A0
00005064                           924  .cMM_1:
00005064  6100 049A                925      bsr.w   writeAddr32         * display the memory location address
00005068  103C 0020                926      move.b  #' ',d0
0000506C  6100 0326                927      bsr.w   putc
00005070  1010                     928      move.b  (a0),d0             * get the current memory contents
00005072  1400                     929      move.b  d0,d2               * pre-set D2 to the existing memory value
00005074  6100 04A8                930      bsr.w   writeByte           * display the byte
00005078  103C 0020                931      move.b  #' ',d0
0000507C  6100 0316                932      bsr.w   putc
00005080  7202                     933      move.l  #2,d1               * read up to 2 digits
00005082  6100 020A                934      bsr.w   hexToIntEcho        * from the serial port
00005086  6500 0010                935      bcs.w   .cMM_2              * back to prompt if there's an error
0000508A                           936  
0000508A  10C0                     937      move.b  d0,(a0)+            * write out the new byte and move on
0000508C  2F08                     938      move.l  a0,-(SP)            * save our address
0000508E  6100 04B0                939      bsr.w   putCRLF
00005092  205F                     940      move.l  (SP)+,a0            * restore our address
00005094  2008                     941      move.l  a0,d0               * copy address back into D0 for printing
00005096  60CC                     942      bra.s   .cMM_1
00005098                           943  
00005098                           944  .cMM_2:
00005098  6100 04A6                945      bsr.w   putCRLF
0000509C  6000 FE80                946      bra.w   monLoop
000050A0                           947      
000050A0                           948  *------------------------------------------------------------------------------
000050A0                           949  * (O)utput a byte to I/O space address
000050A0                           950  *------------------------------------------------------------------------------
000050A0                           951  cmdIOWrite:
000050A0  6100 02F2                952      bsr.w   putc                * echo back the command character in D0
000050A4  103C 0020                953      move.b  #' ',d0
000050A8  6100 02EA                954      bsr.w   putc
000050AC                           955  
000050AC  4282                     956      clr.l   d2                  * pre-set D2 to 0
000050AE  7202                     957      move.l  #2,d1               * read up to 2 digit address
000050B0  6100 01DC                958      bsr.w   hexToIntEcho        * from the serial port
000050B4  6500 FE68                959      bcs.w   monLoop             * back to prompt if there's an error
000050B8  1600                     960      move.b  d0,d3               * save the typed in 8-bit address
000050BA  103C 003D                961      move.b  #'=',d0
000050BE  6100 02D4                962      bsr.w   putc                * send an EQUALS
000050C2                           963  
000050C2  4282                     964      clr.l   d2                  * pre-set D2 to 0
000050C4  7202                     965      move.l  #2,d1               * read up to 2 digit value
000050C6  6100 01C6                966      bsr.w   hexToIntEcho        * from the serial port
000050CA  6500 FE52                967      bcs.w   monLoop             * back to prompt if there's an error
000050CE                           968  
000050CE                           969      ; D0 = value and D3 = 8-bit address
000050CE  207C 00F80000            970      movea.l #IO_BASE,a0
000050D4  0283 000000FF            971      andi.l  #$FF,d3             * clear all the unused bits
000050DA  E383                     972      asl.l   #1,d3               * make it a word offset
000050DC  5283                     973      addi.l  #1,d3               * make it an odd address to write to D0..D7
000050DE  1180 3000                974      move.b  d0,(0,a0,d3)        * and write the new value out
000050E2                           975  
000050E2  6100 045C                976      bsr.w   putCRLF
000050E6  6000 FE36                977      bra.w   monLoop
000050EA                           978  
000050EA                           979  *------------------------------------------------------------------------------
000050EA                           980  * (S) - download a single line of a Motorola S-Record
000050EA                           981  *------------------------------------------------------------------------------
000050EA                           982  cmdDownload:
000050EA  6100 02BA                983      bsr.w   getc                * get the S-Record type
000050EE  B03C 0031                984      cmp.b   #'1', d0
000050F2  671A                     985      beq.s   .cdl_S1             * read in an S1 record
000050F4  B03C 0032                986      cmp.b   #'2', d0
000050F8  6738                     987      beq.s   .cdl_S2             * read in an S2 record
000050FA  B03C 0038                988      cmp.b   #'8', d0
000050FE  6700 00A8                989      beq.w   .cdl_EOL89          * handle S8 SRec terminator
00005102  B03C 0039                990      cmp.b   #'9', d0
00005106  6700 00A0                991      beq.w   .cdl_EOL89          * handle S9 SRec terminator
0000510A                           992  
0000510A  6600 008A                993      bne     .cdl_EOL            * not S1 or S2 so ignore to end of line
0000510E                           994              
0000510E                           995  .cdl_S1:        
0000510E  4282                     996      clr.l   d2
00005110  123C 0002                997      move.b  #2, d1              * 2 characters to read
00005114  6100 013E                998      bsr     hexToInt            * convert to byte count
00005118  2C00                     999      move.l  d0, d6              * D6 = byte count
0000511A  2E00                    1000      move.l  d0, d7              * D7 = byte count (running checksum)
0000511C                          1001  
0000511C  4282                    1002      clr.l   d2
0000511E  123C 0004               1003      move.b  #4, d1              * 4 characters to read
00005122  6100 0130               1004      bsr     hexToInt            * convert to address
00005126  2640                    1005      movea.l d0, a3              * A3 = destination address
00005128  DE00                    1006      add.b   d0, d7              * update checksum with bits 00..07
0000512A  E088                    1007      lsr.l   #8, d0
0000512C  DE00                    1008      add.b   d0, d7              * update checksum with bits 08..15
0000512E                          1009  
0000512E  5746                    1010      subq.w  #3, D6              * take off the 3 bytes we just read in
00005130                          1011  
00005130  6026                    1012      bra.s   .cdl_1              
00005132                          1013                  
00005132                          1014  .cdl_S2:            
00005132  4282                    1015      clr.l   d2
00005134  123C 0002               1016      move.b  #2, d1              * 2 characters to read
00005138  6100 011A               1017      bsr     hexToInt            * convert to byte count
0000513C  2C00                    1018      move.l  d0, d6              * D6 = byte count
0000513E  2E00                    1019      move.l  d0, d7              * D7 = byte count (running checksum)
00005140                          1020  
00005140  4282                    1021      clr.l   d2
00005142  123C 0006               1022      move.b  #6, d1              * 6 characters to read
00005146  6100 010C               1023      bsr     hexToInt            * convert to address
0000514A  2640                    1024      movea.l d0, a3              * A3 = destination address
0000514C  DE00                    1025      add.b   d0, d7              * update checksum with bits 00..07
0000514E  E088                    1026      lsr.l   #8, d0
00005150  DE00                    1027      add.b   d0, d7              * update checksum with bits 08..15
00005152  E088                    1028      lsr.l   #8, d0
00005154  DE00                    1029      add.b   d0, d7              * update checksum with bits 16..23
00005156                          1030  
00005156  5946                    1031      subq.w  #4, d6              * take off the 4 bytes we just read in
00005158                          1032  
00005158                          1033  .cdl_1:
00005158  4A46                    1034      tst.w   d6                  * read all the bytes yet?
0000515A  6712                    1035      beq.s   .cdl_2
0000515C                          1036  
0000515C  4282                    1037      clr.l   d2
0000515E  323C 0002               1038      move.w  #2, d1              * 2 characters to read
00005162  6100 00F0               1039      bsr     hexToInt            * convert to data byte
00005166  16C0                    1040      move.b  d0, (a3)+           * write the byte to memory
00005168  DE00                    1041      add.b   d0, d7              * update checksum
0000516A  5346                    1042      subq.w  #1, d6              * decrement byte count
0000516C  60EA                    1043      bra.s   .cdl_1
0000516E                          1044  
0000516E                          1045  .cdl_2:
0000516E  4282                    1046      clr.l   d2
00005170  323C 0002               1047      move.w  #2, d1              * 2 characters to read
00005174  6100 00DE               1048      bsr     hexToInt            * convert to checksum byte
00005178  DE00                    1049      add.b   d0, d7              * D7 = calc checksum + srec checksum
0000517A  5207                    1050      addq.b  #1, d7              * checksum + 1 should = 0 if OK
0000517C  670C                    1051      beq.s   .cdl_X
0000517E                          1052  
0000517E  103C 0058               1053      move.b  #'X', d0            * checksum fail - print an X
00005182  6100 0210               1054      bsr     putc
00005186  6000 FD9E               1055      bra.w   monLoop_NP          * return to main loop without prompt
0000518A                          1056  
0000518A                          1057  .cdl_X
0000518A  103C 002E               1058      move.b  #'.', d0            * checksum good - print a dot
0000518E  6100 0204               1059      bsr     putc
00005192  6000 FD92               1060      bra.w   monLoop_NP          * return to main loop without prompt
00005196                          1061  
00005196                          1062  .cdl_EOL
00005196  6100 020E               1063      bsr.w   getc                * discard chars until CR or LF
0000519A  0C00 000D               1064      cmpi.b  #CR,d0
0000519E  67EA                    1065      beq.s   .cdl_X
000051A0  0C00 000A               1066      cmpi.b  #LF,d0
000051A4  67E4                    1067      beq.s   .cdl_X
000051A6  60EE                    1068      bra.s   .cdl_EOL
000051A8                          1069  
000051A8                          1070  .cdl_EOL89
000051A8  6100 01FC               1071      bsr.w   getc                * discard chars until CR or LF
000051AC  0C00 000D               1072      cmpi.b  #CR,d0
000051B0  6700 FDD8               1073      beq.w   monLoop_CRLF        * return to main loop with prompt
000051B4  0C00 000A               1074      cmpi.b  #LF,d0
000051B8  6700 FDD0               1075      beq.w   monLoop_CRLF        * return to main loop with prompt
000051BC  60EA                    1076      bra.s   .cdl_EOL89
000051BE                          1077      
000051BE                          1078  *------------------------------------------------------------------------------
000051BE                          1079  * Display the supported commands
000051BE                          1080  *------------------------------------------------------------------------------
000051BE                          1081  cmdHelp:
000051BE  41FA 03EE               1082      lea     strCommands(PC), a0
000051C2  6100 0380               1083      bsr.w   putString
000051C6  6000 FD56               1084      bra.w   monLoop
000051CA                          1085  
000051CA                          1086  *------------------------------------------------------------------------------
000051CA                          1087  * Dumps a 256 section of RAM to the screen
000051CA                          1088  * Displays both hex values and ASCII characters
000051CA                          1089  * a0 - Start Address
000051CA                          1090  *------------------------------------------------------------------------------
000051CA                          1091  dumpRAM:
000051CA  48E7 E040               1092      movem.l d0-d2/a1, -(SP)     * Save registers
000051CE  2248                    1093      move.l  a0,a1               * move the start address to A1
000051D0                          1094  
000051D0  6100 036E               1095      bsr.w   putCRLF             * new line - trashes D0 & A0
000051D4                          1096      
000051D4  323C 000F               1097      move.w  #15,d1              * 16 rows of data (DBRA needs 1 less!)
000051D8                          1098  .dr_1:
000051D8  343C 000F               1099      move.w  #15,d2              * 16 bytes of data per row (DBRA needs 1 less!)
000051DC  2009                    1100      move.l  a1, d0              * copy the start address of the line into D0          
000051DE  6100 0320               1101      bsr.w   writeAddr32         * Display as a 32-bit hex value
000051E2  41FA 056C               1102      lea     strColonSpace(PC), a0
000051E6  6100 035C               1103      bsr.w   putString
000051EA  41F9 001FF906           1104      lea     msgASCIIDump, a0
000051F0                          1105  .dr_2:
000051F0  1019                    1106      move.b  (a1)+, d0           * Read a byte from RAM
000051F2  6100 032A               1107      bsr.w   writeByte           * display byte as 2 hex digits  
000051F6  6100 004A               1108      bsr.w   makePrintable       * convert to printable character
000051FA  10C0                    1109      move.b  d0,(a0)+            * save the printable char in output string
000051FC  103C 0020               1110      move.b  #' ', d0
00005200  6100 0192               1111      bsr.w   putc                * insert a space
00005204  51CA FFEA               1112      dbra    d2,.dr_2
00005208                          1113  
00005208  103C 0020               1114      move.b  #' ', d0
0000520C  6100 0186               1115      bsr.w   putc                * insert a space
00005210                          1116  
00005210  10FC 000D               1117      move.b  #CR,(a0)+
00005214  10FC 000A               1118      move.b  #LF,(a0)+
00005218  10FC 0000               1119      move.b  #0,(a0)+
0000521C  41F9 001FF906           1120      lea     msgASCIIDump, a0
00005222  6100 0320               1121      bsr.w   putString           * print out the printable bytes
00005226  51C9 FFB0               1122      dbra    d1,.dr_1
0000522A                          1123  
0000522A  4CDF 0207               1124      movem.l (SP)+, d0-d2/a1     * Restore registers
0000522E  4E75                    1125      rts
00005230                          1126              
00005230                          1127  *------------------------------------------------------------------------------
00005230                          1128  * Convert character in D0 to upper case
00005230                          1129  * Only changes D0 if char is between 'a'..'z'
00005230                          1130  *------------------------------------------------------------------------------
00005230                          1131  chToUpper:
00005230  B03C 0061               1132      cmp.b   #'a', d0         
00005234  6D0A                    1133      blt.s   .done               * less than lower-case 'a' so leave alone
00005236  B03C 007A               1134      cmp.b   #'z', d0
0000523A  6E04                    1135      bgt.s   .done               * greater than lower-case 'z' so leave alone
0000523C  0400 0020               1136      sub.b   #$20, d0            * convert to upper case
00005240                          1137  .done:
00005240  4E75                    1138      rts
00005242                          1139      
00005242                          1140  *------------------------------------------------------------------------------
00005242                          1141  * Convert a byte into a print safe character
00005242                          1142  * Substitute a '.' for any byte <32 or >126
00005242                          1143  * D0 holds the byte
00005242                          1144  *------------------------------------------------------------------------------
00005242                          1145  makePrintable:
00005242  B03C 0020               1146      cmp.b   #' ', d0         
00005246  6D06                    1147      blt.s   .mp_1               * less than a SPACE (char 32)
00005248                          1148  
00005248  B03C 007E               1149      cmp.b   #'~', d0         
0000524C  6F04                    1150      ble.s   .mp_x               * less than a DEL (char 127)
0000524E                          1151  
0000524E                          1152  .mp_1:
0000524E  103C 002E               1153      move.b  #'.',d0             * substitute a DOT (char 46)
00005252                          1154  .mp_x:
00005252  4E75                    1155      rts
00005254                          1156      
00005254                          1157  *--------------------------------------------------------------------------
00005254                          1158  * Read in an ASCII-HEX number - no echo back
00005254                          1159  *
00005254                          1160  * D2 = Value to return if no digits read in
00005254                          1161  * D1 = Max no of ASCII digits to read in
00005254                          1162  * D0 = Result
00005254                          1163  * Carry flag set if an error occurs / not ASCII-HEX digit
00005254                          1164  *--------------------------------------------------------------------------
00005254                          1165  hexToInt:
00005254                          1166  *   move.l  d2,-(SP)            * save D2
00005254                          1167  *   clr.l   d2                  * D2 used to accumulate the final value
00005254                          1168  .h2i_1:
00005254  6100 0150               1169      bsr.w   getc                * get a character
00005258  61D6                    1170      bsr.s   chToUpper           * convert to upper case if needed
0000525A                          1171  
0000525A  0C00 000A               1172      cmpi.b  #10,d0              * finish if it's CR or LF
0000525E  6724                    1173      beq.s   .h2i_x
00005260  0C00 000D               1174      cmpi.b  #13,d0
00005264  671E                    1175      beq.s   .h2i_x
00005266                          1176      
00005266  0400 0030               1177      subi.b  #'0',d0
0000526A  6B1C                    1178      bmi.s   .h2i_err            * quit if char is less than '0'
0000526C                          1179  
0000526C  0C00 0009               1180      cmpi.b  #9,d0
00005270  6F0A                    1181      ble.s   .h2i_2              * is it <= 9
00005272                          1182      
00005272  5F00                    1183      subi.b  #7,d0
00005274  6B12                    1184      bmi.s   .h2i_err            * quit if char is >'9' and <'A'
00005276                          1185  
00005276  0C00 000F               1186      cmpi.b  #15,d0
0000527A  6E0C                    1187      bgt.s   .h2i_err            * quit if char is >'F'
0000527C                          1188  
0000527C                          1189  .h2i_2:
0000527C  E98A                    1190      lsl.l   #4, d2
0000527E  8400                    1191      or.b    d0, d2              * insert the new digit
00005280                          1192  
00005280  5301                    1193      subq.b  #1, d1              * decrement the digit count
00005282  66D0                    1194      bne.s   .h2i_1              * go back for another digit?
00005284                          1195  
00005284                          1196  .h2i_x:
00005284  2002                    1197      move.l  d2,d0               * put the answer back into D0
00005286                          1198  *   move.l  (SP)+,d2            * restore D2
00005286  4E75                    1199      rts
00005288                          1200  
00005288                          1201  .h2i_err:
00005288                          1202  *   move.l  (SP)+,d2            * restore D2
00005288  003C 0001               1203      ori.b   #1,CCR              * set the CARRY flag to signal an error
0000528C  4E75                    1204      rts
0000528E                          1205  
0000528E                          1206  *--------------------------------------------------------------------------
0000528E                          1207  * Read in an ASCII-HEX number with echo back
0000528E                          1208  *
0000528E                          1209  * D2 = Value to return if no digits read in
0000528E                          1210  * D1 = Max no of ASCII digits to read in
0000528E                          1211  * D0 = Result
0000528E                          1212  * Carry flag set if an error occurs / not ASCII-HEX digit
0000528E                          1213  *--------------------------------------------------------------------------
0000528E                          1214  hexToIntEcho:
0000528E                          1215  *   move.l  d2,-(SP)            * save D2
0000528E                          1216  *   clr.l   d2                  * D2 used to accumulate the final value
0000528E                          1217  .h2i_1:
0000528E  6100 0116               1218      bsr.w   getc                * get a character
00005292  6100 0100               1219      bsr.w   putc                * echo it back
00005296  6198                    1220      bsr.s   chToUpper           * convert to upper case if needed
00005298                          1221  
00005298  0C00 000A               1222      cmpi.b  #10,d0              * finish if it's CR or LF
0000529C  6724                    1223      beq.s   .h2i_x
0000529E  0C00 000D               1224      cmpi.b  #13,d0
000052A2  671E                    1225      beq.s   .h2i_x
000052A4                          1226      
000052A4  0400 0030               1227      subi.b  #'0',d0
000052A8  6B1C                    1228      bmi.s   .h2i_err            * quit if char is less than '0'
000052AA                          1229  
000052AA  0C00 0009               1230      cmpi.b  #9,d0
000052AE  6F0A                    1231      ble.s   .h2i_2              * is it <= 9
000052B0                          1232      
000052B0  5F00                    1233      subi.b  #7,d0
000052B2  6B12                    1234      bmi.s   .h2i_err            * quit if char is >'9' and <'A'
000052B4                          1235  
000052B4  0C00 000F               1236      cmpi.b  #15,d0
000052B8  6E0C                    1237      bgt.s   .h2i_err            * quit if char is >'F'
000052BA                          1238  
000052BA                          1239  .h2i_2:
000052BA  E98A                    1240      lsl.l   #4, d2
000052BC  8400                    1241      or.b    d0, d2              * insert the new digit
000052BE                          1242  
000052BE  5301                    1243      subq.b  #1, d1              * decrement the digit count
000052C0  66CC                    1244      bne.s   .h2i_1              * go back for another digit?
000052C2                          1245  
000052C2                          1246  .h2i_x:
000052C2  2002                    1247      move.l  d2,d0               * put the answer back into D0
000052C4                          1248  *   move.l  (SP)+,d2            * restore D2
000052C4  4E75                    1249      rts
000052C6                          1250  
000052C6                          1251  .h2i_err:
000052C6                          1252  *   move.l  (SP)+,d2            * restore D2
000052C6  003C 0001               1253      ori.b   #1,CCR              * set the CARRY flag to signal an error
000052CA  4E75                    1254      rts
000052CC                          1255  
000052CC                          1256  *******************************************************************************
000052CC                          1257  *
000052CC                          1258  *   #####  ####### ######  ###    #    #          ######  ####### ######  ####### 
000052CC                          1259  *  #     # #       #     #  #    # #   #          #     # #     # #     #    #    
000052CC                          1260  *  #       #       #     #  #   #   #  #          #     # #     # #     #    #    
000052CC                          1261  *   #####  #####   ######   #  #     # #          ######  #     # ######     #    
000052CC                          1262  *        # #       #   #    #  ####### #          #       #     # #   #      #    
000052CC                          1263  *  #     # #       #    #   #  #     # #          #       #     # #    #     #    
000052CC                          1264  *   #####  ####### #     # ### #     # #######    #       ####### #     #    #    
000052CC                          1265  *                                                                                                   
000052CC                          1266  *******************************************************************************
000052CC                          1267  
000052CC                          1268  *------------------------------------------------------------------------------
000052CC                          1269  * Initialise the serial port
000052CC                          1270  *
000052CC                          1271  * Assumes that there is a 68681 DUART at the address defined by DUART1 in
000052CC                          1272  * devices.inc and initialises port A and enables the rx interrupt.
000052CC                          1273  *------------------------------------------------------------------------------
000052CC                          1274  serInit:
000052CC  13FC 0030 00D00005      1275      move.b  #$30, CRA           * Reset Transmitter
000052D4  13FC 0020 00D00005      1276      move.b  #$20, CRA           * Reset Receiver
000052DC  13FC 0010 00D00005      1277      move.b  #$10, CRA           * Reset Mode Register Pointer
000052E4                          1278      
000052E4  23FC 00000000 001FF800  1279      move.l  #0,ser0RxHead       * Set queue head and tail ptrs to 0
000052EE  33FC 0000 001FF804      1280      move.w  #0,ser0RxSize       * No chars in receive queue
000052F6                          1281  
000052F6  13FC 0000 00D00009      1282      move.b  #$00, ACR           * Baud Rate Set #1
000052FE  13FC 0013 00D00001      1283      move.b  #$13, MRA           * No Parity & 8-bit
00005306  13FC 0007 00D00001      1284      move.b  #$07, MRA           * Normal Mode, No CTS/RTS & 1 stop bit
0000530E                          1285  
0000530E                          1286      * if HI_SPEED = 0 then set 38400 baud
0000530E                 FALSE    1287      ifeq HI_SPEED
0000530E                          1288      endc
0000530E                          1289  
0000530E                          1290      * if HI_SPEED > 0 then set 115200 baud
0000530E                 TRUE     1291      ifgt HI_SPEED
0000530E  1039 00D00005           1292      move.b  CRA,d0              * Read CRA - sets BRG test mode
00005314  13FC 0066 00D00003      1293      move.b  #BAUD_1200, CSRA    * Set Tx and Rx baud rates to 115200 (old 1200)
0000531C                          1294      endc
0000531C                          1295      
0000531C  13FC 0002 00D0000B      1296      move.b  #$02, IMR           * Rx interrupt enabled
00005324  13FC 0005 00D00005      1297      move.b  #$05, CRA           * Enable Transmit/Recieve
0000532C  13FC 0001 00D0001D      1298      move.b  #$01, SOPR          * set OP0 low - i.e. CTS low
00005334  4E75                    1299      rts
00005336                          1300  
00005336                          1301  *------------------------------------------------------------------------------
00005336                          1302  * Serial port interrupt handler
00005336                          1303  *
00005336                          1304  * Should only be called when a char has been received.
00005336                          1305  *
00005336                          1306  *------------------------------------------------------------------------------
00005336                          1307  serISR:
00005336                          1308      * save registers we are about to trash
00005336  48E7 E080               1309      movem.l d0-d2/a0,-(sp)
0000533A                          1310  
0000533A  0839 0001 00D0000B      1311      btst.b  #1,ISR              * check the RXRDYA bit
00005342  6700 004A               1312      beq.w   serExit
00005346                          1313  
00005346                          1314      * a char has been received so save it in the rx queue
00005346  1039 00D00007           1315      move.b  RBA,d0              * get the character
0000534C  207C 001FF800           1316      movea.l #ser0RxQueue,a0     * A0 = ptr to rx queue parameters
00005352  2210                    1317      move.l  (a0),d1             * D1.L MSW = head and LSW = tail
00005354  4841                    1318      swap    d1                  * D1.L MSW = tail and LSW = head
00005356  3401                    1319      move.w  d1,d2               * D2.W holds the queue head index
00005358  4841                    1320      swap    d1                  * D1.L MSW = head and LSW = tail
0000535A                          1321  
0000535A                          1322  
0000535A  5242                    1323      addq.w  #1,d2               * advance the head index
0000535C  0242 00FF               1324      andi.w  #SERIAL_BUFFER_MASK,d2
00005360  B441                    1325      cmp.w   d1,d2               * if head = tail then buffer full
00005362  6604                    1326      bne.s   serSave             * if head <> tail then add char to buffer
00005364                          1327  
00005364                          1328      * the serial buffer is full - what now?
00005364  6000 0028               1329      bra.w   serExit
00005368                          1330  
00005368                          1331  serSave:
00005368  4841                    1332      swap    d1                  * D1.L MSW = tail and LSW = head
0000536A  0281 0000FFFF           1333      andi.l  #$0000FFFF,d1       * D1 holds just the old head index
00005370  1180 1006               1334      move.b  d0,6(a0,d1)         * save the char to the rx queue
00005374  3082                    1335      move.w  d2,(a0)             * save the updated head index
00005376  5279 001FF804           1336      addq.w  #1,ser0RxSize       * increment number of chars in rx queue
0000537C                          1337  
0000537C                          1338      * check if rx queue is nearly full
0000537C  0C79 00C8 001FF804      1339      cmpi.w  #SERIAL_BUFFER_UPPER,ser0RxSize
00005384  6F08                    1340      ble.s   serExit
00005386                          1341  
00005386                          1342      * no of chars in queue has reached the upper threshold
00005386                          1343      * set CTS HIGH to hopefully tell the host to stop sending.
00005386  13FC 0001 00D0001F      1344      move.b  #$01, ROPR          * set OP0 high
0000538E                          1345  
0000538E                          1346  serExit:
0000538E                          1347      * restore registers
0000538E  4CDF 0107               1348      movem.l (sp)+,d0-d2/a0
00005392  4E73                    1349      rte
00005394                          1350  
00005394                          1351  *------------------------------------------------------------------------------
00005394                          1352  * Write a character to UART Port A, blocking if UART is not ready
00005394                          1353  *
00005394                          1354  * D0 = char to send
00005394                          1355  *------------------------------------------------------------------------------
00005394                          1356  putc:
00005394  0839 0002 00D00003      1357      btst.b  #2, SRA             * Check if transmitter ready bit is set
0000539C  67F6                    1358      beq     putc     
0000539E  13C0 00D00007           1359      move.b  d0, TBA             * Transmit Character
000053A4  4E75                    1360      rts
000053A6                          1361  
000053A6                          1362  *------------------------------------------------------------------------------
000053A6                          1363  * Read a character from the rx queue - blocking call so will wait for character
000053A6                          1364  *
000053A6                          1365  * D0 = recevied char
000053A6                          1366  *------------------------------------------------------------------------------
000053A6                          1367  getc:
000053A6  0C79 0000 001FF804      1368      cmpi.w  #0,ser0RxSize       * check number of chars in rx queue
000053AE  67F6                    1369      beq.s   getc                * keep checking till there is a char available
000053B0                          1370  
000053B0                          1371      * save registers we are about to trash
000053B0  48E7 4080               1372      movem.l d1/a0,-(sp)
000053B4                          1373      
000053B4                          1374      * get the character from the tail of the queue
000053B4  207C 001FF800           1375      movea.l #ser0RxQueue,a0     * A0 = ptr to rx queue parameters
000053BA  2210                    1376      move.l  (a0),d1             * D1.L MSW = head and LSW = tail
000053BC  1030 1006               1377      move.b  6(a0,d1.w),d0       * read the char from the queue tail
000053C0  5241                    1378      addq.w  #1,d1               * advance the tail index
000053C2  0241 00FF               1379      andi.w  #SERIAL_BUFFER_MASK,d1
000053C6  3141 0002               1380      move.w  d1,2(a0)            * save the updated tail index
000053CA  5379 001FF804           1381      subq.w  #1,ser0RxSize       * decrement number of chars in rx queue
000053D0                          1382  
000053D0                          1383      * check if rx queue is nearly empty
000053D0  0C79 0019 001FF804      1384      cmpi.w  #SERIAL_BUFFER_LOWER,ser0RxSize
000053D8  6C08                    1385      bge.s   getExit
000053DA                          1386  
000053DA                          1387      * no of chars in queue has reached the lower threshold
000053DA                          1388      * set CTS LOW to hopefully tell the host to start sending.
000053DA  13FC 0001 00D0001D      1389      move.b  #$01, SOPR          * set OP0 low
000053E2                          1390  
000053E2                          1391  getExit:
000053E2                          1392      * restore registers
000053E2  4CDF 0102               1393      movem.l (sp)+,d1/a0
000053E6  4E75                    1394      rts
000053E8                          1395  
000053E8                          1396  *******************************************************************************
000053E8                          1397  *
000053E8                          1398  *  #######    #     #####  #     #  #####   #####  #    #    ####### ######     #    ######   #####  
000053E8                          1399  *  #         # #   #     #  #   #  #     # #     # #   #        #    #     #   # #   #     # #     # 
000053E8                          1400  *  #        #   #  #         # #   #       #     # #  #         #    #     #  #   #  #     # #       
000053E8                          1401  *  #####   #     #  #####     #    ######   #####  ###          #    ######  #     # ######   #####  
000053E8                          1402  *  #       #######       #    #    #     # #     # #  #         #    #   #   ####### #             # 
000053E8                          1403  *  #       #     # #     #    #    #     # #     # #   #        #    #    #  #     # #       #     # 
000053E8                          1404  *  ####### #     #  #####     #     #####   #####  #    #       #    #     # #     # #        #####  
000053E8                          1405  *                                                                                                   
000053E8                          1406  *******************************************************************************
000053E8                          1407  
000053E8                          1408  *------------------------------------------------------------------------------
000053E8                          1409  * This is the jump table for the TRAP #15 tasks - not all tasks are supported!
000053E8                          1410  *------------------------------------------------------------------------------
000053E8                          1411  
000053E8                          1412  easy68kTaskTable:
000053E8  6000 008A               1413      bra.w   easyTask0 
000053EC  6000 009E               1414      bra.w   easyTask1 
000053F0  6000 005E               1415      bra.w   easyTask2 
000053F4  6000 005A               1416      bra.w   easyTask3 
000053F8  6000 0056               1417      bra.w   easyTask4 
000053FC  6000 00A2               1418      bra.w   easyTask5 
00005400  6000 00A6               1419      bra.w   easyTask6 
00005404  6000 00AA               1420      bra.w   easyTask7 
00005408  6000 0046               1421      bra.w   easyTask8 
0000540C  6000 0042               1422      bra.w   easyTask9 
00005410  6000 003E               1423      bra.w   easyTask10
00005414  6000 003A               1424      bra.w   easyTask11
00005418  6000 0036               1425      bra.w   easyTask12
0000541C  6000 00A6               1426      bra.w   easyTask13
00005420  6000 00B2               1427      bra.w   easyTask14
00005424  6000 002A               1428      bra.w   easyTask15
00005428  6000 0026               1429      bra.w   easyTask16
0000542C  6000 0022               1430      bra.w   easyTask17
00005430  6000 001E               1431      bra.w   easyTask18
00005434  6000 001A               1432      bra.w   easyTask19
00005438  6000 0016               1433      bra.w   easyTask20
0000543C  6000 0012               1434      bra.w   easyTask21
00005440  6000 000E               1435      bra.w   easyTask22
00005444  6000 000A               1436      bra.w   easyTask23
00005448  6000 0006               1437      bra.w   easyTask24
0000544C  6000 0002               1438      bra.w   easyTask25
00005450                          1439  
00005450                          1440  *------------------------------------------------------------------------------
00005450                          1441  * These are the EASy68K tasks that are not yet implemented
00005450                          1442  * Simply print out a message showing the task number and stop in an endless loop.
00005450                          1443  *------------------------------------------------------------------------------
00005450                          1444  
00005450                          1445  easyTask2: 
00005450                          1446  easyTask3:
00005450                          1447  easyTask4:
00005450                          1448  easyTask8: 
00005450                          1449  easyTask9: 
00005450                          1450  easyTask10:
00005450                          1451  easyTask11:
00005450                          1452  easyTask12:
00005450                          1453  easyTask15:
00005450                          1454  easyTask16:
00005450                          1455  easyTask17:
00005450                          1456  easyTask18:
00005450                          1457  easyTask19:
00005450                          1458  easyTask20:
00005450                          1459  easyTask21:
00005450                          1460  easyTask22:
00005450                          1461  easyTask23:
00005450                          1462  easyTask24:
00005450                          1463  easyTask25:
00005450                          1464  easyTaskUnsupported:
00005450  C141                    1465      exg     d0,d1               * put the task number into D1
00005452  41FA 0332               1466      lea     strEasyTask1(PC), a0
00005456  6100 00EC               1467      bsr.w   putString
0000545A  C141                    1468      exg     d0,d1               * put the task number back into D0
0000545C  80FC 000A               1469      divu    #10,d0              * divide task number by 10
00005460  6100 00C4               1470      bsr.w   writeNibble         * output the 10's digit
00005464  4840                    1471      swap    d0
00005466  6100 00BE               1472      bsr.w   writeNibble         * output the 1's digit
0000546A  41FA 033B               1473      lea     strEasyTask2(PC), a0
0000546E  6100 00D4               1474      bsr.w   putString
00005472                          1475  .infloop:
00005472  60FE                    1476      bra.s   .infloop
00005474                          1477  
00005474                          1478  *------------------------------------------------------------------------------
00005474                          1479  * EASy68K TRAP #15 - Task 0
00005474                          1480  * Display n characters of string at (A1), n is D1.W (stops on NULL or max 255) with CR, LF.
00005474                          1481  *------------------------------------------------------------------------------
00005474                          1482  easyTask0:
00005474  0241 00FF               1483      andi.w  #$00FF,d1           * DBRA works on a WORD so make sure upper byte is zero
00005478  5301                    1484      sub.b   #1,d1               * DBRA requires 1 less than actual number
0000547A                          1485  .loop:
0000547A  1019                    1486      move.b  (a1)+, d0           * Read in character
0000547C  6708                    1487      beq.s   .end                * Check for the null
0000547E                          1488      
0000547E  6100 FF14               1489      bsr.w   putc                * Otherwise write the character
00005482  51C9 FFF6               1490      dbra    d1,.loop            * And continue
00005486                          1491  .end:
00005486  6100 00B8               1492      bsr.w   putCRLF             * append CR & LF
0000548A  4E75                    1493      rts
0000548C                          1494  
0000548C                          1495  *------------------------------------------------------------------------------
0000548C                          1496  * EASy68K TRAP #15 - Task 1
0000548C                          1497  * Display n characters of string at (A1), n is D1.W (stops on NULL or max 255) without CR, LF.
0000548C                          1498  *------------------------------------------------------------------------------
0000548C                          1499  easyTask1:
0000548C  0241 00FF               1500      andi.w  #$00FF,d1           * DBRA works on a WORD so make sure upper byte is zero
00005490  5301                    1501      sub.b   #1,d1               * DBRA requires 1 less than actual number
00005492                          1502  .loop:
00005492  1019                    1503      move.b  (a1)+, d0           * Read in character
00005494  6708                    1504      beq.s   .end                * Check for the null
00005496                          1505      
00005496  6100 FEFC               1506      bsr.w   putc                * Otherwise write the character
0000549A  51C9 FFF6               1507      dbra    d1,.loop            * And continue
0000549E                          1508  .end:
0000549E  4E75                    1509      rts
000054A0                          1510  
000054A0                          1511  *------------------------------------------------------------------------------
000054A0                          1512  * EASy68K TRAP #15 - Task 5
000054A0                          1513  * Read single ASCII character from the keyboard into D1.B. 
000054A0                          1514  *------------------------------------------------------------------------------
000054A0                          1515  easyTask5:
000054A0  6100 FF04               1516      bsr.w   getc                * wait for char - returned in D0
000054A4  1200                    1517      move.b  d0,d1               * move the char into D1
000054A6  4E75                    1518      rts
000054A8                          1519      
000054A8                          1520  *------------------------------------------------------------------------------
000054A8                          1521  * EASy68K TRAP #15 - Task 6
000054A8                          1522  * Display single ASCII character in D1.B.   
000054A8                          1523  *------------------------------------------------------------------------------
000054A8                          1524  easyTask6:
000054A8  1001                    1525      move.b  d1,d0               * move the char into D0
000054AA  6100 FEE8               1526      bsr.w   putc                * output the char
000054AE  4E75                    1527      rts
000054B0                          1528  
000054B0                          1529  *------------------------------------------------------------------------------
000054B0                          1530  * EASy68K TRAP #15 - Task 7
000054B0                          1531  * Check for keyboard input. Set D1.B to 1 if keyboard input is pending,
000054B0                          1532  * otherwise set to 0.
000054B0                          1533  *------------------------------------------------------------------------------
000054B0                          1534  easyTask7:
000054B0  123C 0000               1535      move.b  #0,d1               * assume no char available
000054B4  0C79 0000 001FF804      1536      cmpi.w  #0,ser0RxSize       * check number of chars in rx queue
000054BC  6704                    1537      beq.s   .end
000054BE  123C 0001               1538      move.b  #1,d1               * there is at least 1 char available
000054C2                          1539  .end
000054C2  4E75                    1540      rts
000054C4                          1541  
000054C4                          1542  *------------------------------------------------------------------------------
000054C4                          1543  * EASy68K TRAP #15 - Task 13
000054C4                          1544  * Display the NULL terminated string at (A1) with CR, LF.
000054C4                          1545  *------------------------------------------------------------------------------
000054C4                          1546  easyTask13:
000054C4                          1547  .loop:
000054C4  1019                    1548      move.b  (a1)+, d0           * Read in character
000054C6  6706                    1549      beq.s   .end                * Check for the null
000054C8                          1550      
000054C8  6100 FECA               1551      bsr.w   putc                * Otherwise write the character
000054CC  60F6                    1552      bra.s   .loop               * And continue
000054CE                          1553  .end:
000054CE  6100 0070               1554      bsr.w   putCRLF             * append CR & LF
000054D2  4E75                    1555      rts
000054D4                          1556  
000054D4                          1557  *------------------------------------------------------------------------------
000054D4                          1558  * EASy68K TRAP #15 - Task 14
000054D4                          1559  * Display the NULL terminated string pointed to by (A1).
000054D4                          1560  *------------------------------------------------------------------------------
000054D4                          1561  easyTask14:
000054D4                          1562  .loop:
000054D4  1019                    1563      move.b  (a1)+, d0           * Read in character
000054D6  6706                    1564      beq.s   .end                * Check for the null
000054D8                          1565      
000054D8  6100 FEBA               1566      bsr.w   putc                * Otherwise write the character
000054DC  60F6                    1567      bra.s   .loop               * And continue
000054DE                          1568  .end:
000054DE  4E75                    1569      rts
000054E0                          1570  
000054E0                          1571  *------------------------------------------------------------------------------
000054E0                          1572  * This is the entry point for the TRAP #15 handler that gets called when any
000054E0                          1573  * TRAP #15 services are required. Only a few tasks are implemented.
000054E0                          1574  * Unimplemented tasks will produce an error message.
000054E0                          1575  *------------------------------------------------------------------------------
000054E0                          1576  easy68kTrap15:
000054E0  48E7 10A0               1577      movem.l d3/a0/a2,-(sp)
000054E4  45FA FF02               1578      lea     easy68kTaskTable(PC),a2
000054E8  B03C 0019               1579      cmp.b   #25,d0              * is task number greater than 25?
000054EC  6E00 FF62               1580      bgt     easyTaskUnsupported
000054F0                          1581      
000054F0  4283                    1582      clr.l   d3
000054F2  1600                    1583      move.b  d0,d3               * task number into D3
000054F4  E58B                    1584      lsl.l   #2,d3               * convert task number into longword offset
000054F6  4EB2 3000               1585      jsr     (a2,d3)             * jump to the specific task handler
000054FA                          1586      
000054FA  4CDF 0508               1587      movem.l (sp)+,d3/a0/a2
000054FE  4E73                    1588      rte
00005500                          1589  
00005500                          1590  *******************************************************************************
00005500                          1591  *
00005500                          1592  *  ######  ######  ### #     # #######    ######  ####### #     # ####### ### #     # #######  #####  
00005500                          1593  *  #     # #     #  #  ##    #    #       #     # #     # #     #    #     #  ##    # #       #     # 
00005500                          1594  *  #     # #     #  #  # #   #    #       #     # #     # #     #    #     #  # #   # #       #       
00005500                          1595  *  ######  ######   #  #  #  #    #       ######  #     # #     #    #     #  #  #  # #####    #####  
00005500                          1596  *  #       #   #    #  #   # #    #       #   #   #     # #     #    #     #  #   # # #             # 
00005500                          1597  *  #       #    #   #  #    ##    #       #    #  #     # #     #    #     #  #    ## #       #     # 
00005500                          1598  *  #       #     # ### #     #    #       #     # #######  #####     #    ### #     # #######  #####    
00005500                          1599  *
00005500                          1600  *******************************************************************************
00005500                          1601  * These are the various printing routines that handle displaying of bytes,
00005500                          1602  * words, long words and 24-bit values as ASCII hexadecimal text. The routines
00005500                          1603  * must be kept in this order as program flow is meant to fall out of one
00005500                          1604  * routine and into the next, often without a return statement.
00005500                          1605  *******************************************************************************
00005500                          1606  
00005500                          1607  *------------------------------------------------------------------------------
00005500                          1608  * Output a 32-bit address as 8 ASCII hexadecimal digits
00005500                          1609  * D0 holds the 32-bit address
00005500                          1610  *------------------------------------------------------------------------------
00005500                          1611  writeAddr32:
00005500  2F00                    1612      move.l  d0,-(sp)            * save D0 first
00005502  E098                    1613      ror.l   #8,d0
00005504  E098                    1614      ror.l   #8,d0
00005506  610E                    1615      bsr.s   writeWord           * write bits 16..31
00005508  201F                    1616      move.l  (sp)+,d0            * restore D0
0000550A  600A                    1617      bra.s   writeWord
0000550C                          1618      
0000550C                          1619  *------------------------------------------------------------------------------
0000550C                          1620  * Output a 24-bit address as 6 ASCII hexadecimal digits
0000550C                          1621  * D0 holds the address in bits 0..23
0000550C                          1622  * NOTE: the writeWord function must be directly after this function
0000550C                          1623  *------------------------------------------------------------------------------
0000550C                          1624  writeAddr24:
0000550C  2F00                    1625      move.l  d0,-(sp)            * save D0 first
0000550E  E098                    1626      ror.l   #8,d0
00005510  E098                    1627      ror.l   #8,d0
00005512  610A                    1628      bsr.s   writeByte           * write bits 16..23
00005514  201F                    1629      move.l  (sp)+,d0            * restore D0
00005516                          1630      
00005516                          1631  *------------------------------------------------------------------------------
00005516                          1632  * Output a word as 4 ASCII hexadecimal digits
00005516                          1633  * D0 holds the word in bits 0..15
00005516                          1634  * NOTE: the writeByte function must be directly after this function
00005516                          1635  *------------------------------------------------------------------------------
00005516                          1636  writeWord:
00005516  3F00                    1637      move.w  d0,-(sp)            * save D0 first
00005518  E058                    1638      ror.w   #8,d0               * get upper byte (0 => shift 8 times)
0000551A  6102                    1639      bsr.s   writeByte
0000551C  301F                    1640      move.w  (sp)+,d0            * restore D0
0000551E                          1641  
0000551E                          1642  *------------------------------------------------------------------------------
0000551E                          1643  * Output a byte as 2 ASCII hexadecimal digits
0000551E                          1644  * D0 holds the byte in bits 0..7
0000551E                          1645  * NOTE: the writeNibble function must be directly after this function
0000551E                          1646  *------------------------------------------------------------------------------
0000551E                          1647  writeByte:
0000551E  3F00                    1648      move.w  d0,-(sp)            * save D0 first
00005520  E818                    1649      ror.b   #4,d0               * get upper nibble
00005522  6102                    1650      bsr.s   writeNibble
00005524  301F                    1651      move.w  (sp)+,d0            * restore D0
00005526                          1652      
00005526                          1653  *------------------------------------------------------------------------------
00005526                          1654  * Output 4 bits as an ASCII hexadecimal digit
00005526                          1655  * D0 holds the nibble in bits 0..3
00005526                          1656  *------------------------------------------------------------------------------
00005526                          1657  writeNibble:
00005526  3F00                    1658      move.w  d0,-(sp)            * save D0 first
00005528  0200 000F               1659      andi.b  #$0F,d0             * make sure we only have the lower 4 bits
0000552C  0C00 000A               1660      cmpi.b  #10,d0              * compare D0 to 10
00005530  6502                    1661      bcs.b   .wn1                * less than 10 so don't add 7
00005532  5E00                    1662      addi.b  #07,d0              * add 7
00005534                          1663  .wn1:
00005534  0600 0030               1664      addi.b  #'0',d0             * add ASCII code for char zero
00005538  6100 FE5A               1665      bsr.w   putc                * write the ASCII digit out
0000553C  301F                    1666      move.w  (sp)+,d0            * restore D0
0000553E  4E75                    1667      rts
00005540                          1668  
00005540                          1669  *------------------------------------------------------------------------------
00005540                          1670  * Prints a newline (CR, LF)
00005540                          1671  * NOTE: the putString function must follow this function
00005540                          1672  *------------------------------------------------------------------------------
00005540                          1673  putCRLF:
00005540  41FA 020B               1674      lea     strNewline(PC), a0
00005544                          1675  
00005544                          1676  *------------------------------------------------------------------------------
00005544                          1677  * Print a null terminated string
00005544                          1678  * A0 holds the address of the first character of the null terminated string
00005544                          1679  *------------------------------------------------------------------------------
00005544                          1680  putString:
00005544                          1681  .loop:
00005544  1018                    1682      move.b  (a0)+, d0           * Read in character
00005546  6706                    1683      beq.s   .end                * Check for the null
00005548                          1684      
00005548  6100 FE4A               1685      bsr.w   putc                * Otherwise write the character
0000554C  60F6                    1686      bra.s   .loop               * And continue
0000554E                          1687  .end:
0000554E  4E75                    1688      rts
00005550                          1689  
00005550                          1690  *******************************************************************************
00005550                          1691  *
00005550                          1692  *   #####  ####### ######  ### #     #  #####   #####  
00005550                          1693  *  #     #    #    #     #  #  ##    # #     # #     # 
00005550                          1694  *  #          #    #     #  #  # #   # #       #       
00005550                          1695  *   #####     #    ######   #  #  #  # #  ####  #####  
00005550                          1696  *        #    #    #   #    #  #   # # #     #       # 
00005550                          1697  *  #     #    #    #    #   #  #    ## #     # #     # 
00005550                          1698  *   #####     #    #     # ### #     #  #####   #####  
00005550                          1699  *
00005550                          1700  *******************************************************************************
00005550                          1701  strBanner1:
00005550= 0A 0D                   1702      dc.b 10,13
00005552= 53 69 6D 70 6C 65 ...   1703      dc.b 'Simple RCBus 68000 ROM Monitor v1.4',10,13
00005577= 52 4F 4D 3A 20 30 ...   1704      dc.b 'ROM: 0x000000 .. 0x01FFFF',10,13
00005592= 52 41 4D 3A 20 30 ...   1705      dc.b 'RAM: 0x100000 .. 0x1FFFFF',10,13,0
000055AE                          1706  strCommands:
000055AE= 0A 0D 43 6F 6D 6D ...   1707      dc.b 10,13,'Commands: ',10,13
000055BC= 42 20 20 20 20 20 ...   1708      dc.b 'B     : Start EhBASIC v3.54',10,13
000055D9= 44 6E 6E 6E 6E 20 ...   1709      dc.b 'Dnnnn : Display 256 bytes of memory starting at address nnnn',10,13
00005617= 47 6E 6E 6E 6E 20 ...   1710      dc.b 'Gnnnn : Execute code starting at address nnnn',10,13
00005646= 49 61 61 20 20 20 ...   1711      dc.b 'Iaa   : Read a byte from address aa in I/O space',10,13
00005678= 4D 6E 6E 6E 6E 20 ...   1712      dc.b 'Mnnnn : Modify memory starting at address nnnn',10,13
000056A8= 4F 61 61 62 62 20 ...   1713      dc.b 'Oaabb : Write byte bb to address aa in I/O space',10,13
000056DA= 53 31 78 78 78 20 ...   1714      dc.b 'S1xxx : Download S1 Hex Record ',10,13          
000056FB= 53 32 78 78 78 20 ...   1715      dc.b 'S2xxx : Download S2 Hex Record ',10,13    
0000571C= 3F 20 20 20 20 20 ...   1716      dc.b '?     : Display this help',10,13
00005737= 00                      1717      dc.b 0
00005738                          1718  strPrompt:
00005738= 3E 20 00                1719      dc.b '> ',0
0000573B                          1720  strUnkCmd:
0000573B= 55 6E 6B 6E 6F 77 ...   1721      dc.b 'Unknown Command: ',0
0000574D                          1722  strNewline:
0000574D= 0A 0D 00                1723      dc.b 10,13,0
00005750                          1724  strColonSpace:
00005750= 3A 20 00                1725      dc.b ': ',0
00005753                          1726  strUninitInt:
00005753= 55 6E 68 61 6E 64 ...   1727      dc.b 'Unhandled interrupt.',10,13,0
0000576A                          1728  strUserReturn:
0000576A= 0A 0D 55 73 65 72 ...   1729      dc.b 10,13,'User program completed.',10,13,0
00005786                          1730  strEasyTask1:
00005786= 0A 0D 53 54 4F 50 ...   1731      dc.b    10,13,'STOP: EASy68K TRAP #15 - Task ',0
000057A7                          1732  strEasyTask2:
000057A7= 20 6E 6F 74 20 79 ...   1733      dc.b    ' not yet implemented',10,13,0
000057BE                          1734  strBASICErr1:
000057BE= 0A 0D 43 61 6E 6E ...   1735      dc.b    10,13,'Cannot boot EhBASIC - EhBASIC missing from EEPROM',10,13,0
000057F4                          1736  strBASICReturn:
000057F4= 0A 0D 45 68 42 41 ...   1737      dc.b    10,13,'EhBASIC returned to Monitor. Press RESET to restart.',10,13,0
0000582D                          1738  
0000582D                          1739  *******************************************************************************
0000582D                          1740  *
0000582D                          1741  *  #     # ####### #     # ### ####### ####### ######     #     #    #    ######   #####  
0000582D                          1742  *  ##   ## #     # ##    #  #     #    #     # #     #    #     #   # #   #     # #     # 
0000582D                          1743  *  # # # # #     # # #   #  #     #    #     # #     #    #     #  #   #  #     # #       
0000582D                          1744  *  #  #  # #     # #  #  #  #     #    #     # ######     #     # #     # ######   #####  
0000582D                          1745  *  #     # #     # #   # #  #     #    #     # #   #       #   #  ####### #   #         # 
0000582D                          1746  *  #     # #     # #    ##  #     #    #     # #    #       # #   #     # #    #  #     # 
0000582D                          1747  *  #     # ####### #     # ###    #    ####### #     #       #    #     # #     #  #####  
0000582D                          1748  *
0000582D                          1749  *******************************************************************************
0000582D                          1750  * Private monitor variables go here in a block of 2048 bytes (defined by MON_PRIV)
0000582D                          1751  * and are located at the top of RAM (RAM_BASE+RAM_LEN).
0000582D                          1752  *******************************************************************************
0000582D                          1753  
001FF800                          1754      ORG     STACK_START
001FF800                          1755  
001FF800                          1756  * keep these serial rx queue variables in this order
001FF800                          1757  ser0RxQueue:
001FF800                          1758  ser0RxHead: ds.w    1
001FF802                          1759  ser0RxTail: ds.w    1
001FF804                          1760  ser0RxSize: ds.w    1
001FF806                          1761  ser0RxBuf:  ds.b    SERIAL_BUFFER_SIZE
001FF906                          1762  
001FF906                          1763  msgASCIIDump:
001FF906                          1764      ds.b 20
001FF91A                          1765  
001FF91A                          1766      
001FF91A                          1767      END    START                * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACR                 D00009
AEMSG1              46D2
AEMSG2              4716
AV1MSG              4748
AV2MSG              4784
AV3MSG              47C0
AV4MSG              47FC
AV5MSG              4838
AV6MSG              4874
AV7MSG              48B0
BAUD_1200           66
BAUD_2400           88
BAUD_38400          CC
BAUD_4800           99
BAUD_9600           BB
BAUD_RATE           CC
BCNT                D0001D
BEMSG1              48EC
BEMSG2              492B
CF_8BIT             1
CF_COMMAND          F8002F
CF_CYL_HI           F8002B
CF_CYL_LOW          F80029
CF_DATA             F80021
CF_ERROR            F80023
CF_FEATURES         F80023
CF_HEAD             F8002D
CF_LBA0007          F80027
CF_LBA0815          F80029
CF_LBA1623          F8002B
CF_LBA2427          F8002D
CF_LBAMODE          E0
CF_NOCACHE          82
CF_RD_SEC           20
CF_SECCOUNT         F80025
CF_SECTOR           F80027
CF_SET_FEAT         EF
CF_STATUS           F8002F
CF_WR_SEC           30
CHTOUPPER           5230
CHTOUPPER:DONE      5240
CIMSG               495D
CMDBOOTEHBASIC      4F90
CMDBOOTEHBASIC:BOOTEHBASIC  4FA4
CMDBOOTEHBASIC:FOREVER  4FB4
CMDDISPMEMORY       4FB6
CMDDOWNLOAD         50EA
CMDDOWNLOAD:CDL_1   5158
CMDDOWNLOAD:CDL_2   516E
CMDDOWNLOAD:CDL_EOL  5196
CMDDOWNLOAD:CDL_EOL89  51A8
CMDDOWNLOAD:CDL_S1  510E
CMDDOWNLOAD:CDL_S2  5132
CMDDOWNLOAD:CDL_X   518A
CMDHELP             51BE
CMDIOREAD           5000
CMDIOWRITE          50A0
CMDMODIFYMEMORY     5042
CMDMODIFYMEMORY:CMM_1  5064
CMDMODIFYMEMORY:CMM_2  5098
CMDRUN              4FD8
CR                  D
CRA                 D00005
CRB                 D00015
CSRA                D00003
CSRB                D00013
DUART1              D00000
DUMPRAM             51CA
DUMPRAM:DR_1        51D8
DUMPRAM:DR_2        51F0
EASY68KTASKTABLE    53E8
EASY68KTRAP15       54E0
EASYTASK0           5474
EASYTASK0:END       5486
EASYTASK0:LOOP      547A
EASYTASK1           548C
EASYTASK10          5450
EASYTASK11          5450
EASYTASK12          5450
EASYTASK13          54C4
EASYTASK13:END      54CE
EASYTASK13:LOOP     54C4
EASYTASK14          54D4
EASYTASK14:END      54DE
EASYTASK14:LOOP     54D4
EASYTASK15          5450
EASYTASK16          5450
EASYTASK17          5450
EASYTASK18          5450
EASYTASK19          5450
EASYTASK1:END       549E
EASYTASK1:LOOP      5492
EASYTASK2           5450
EASYTASK20          5450
EASYTASK21          5450
EASYTASK22          5450
EASYTASK23          5450
EASYTASK24          5450
EASYTASK25          5450
EASYTASK3           5450
EASYTASK4           5450
EASYTASK5           54A0
EASYTASK6           54A8
EASYTASK7           54B0
EASYTASK7:END       54C2
EASYTASK8           5450
EASYTASK9           5450
EASYTASKUNSUPPORTED  5450
EASYTASKUNSUPPORTED:INFLOOP  5472
ECNT                D0001F
EHBASIC_BASE        400
GETC                53A6
GETEXIT             53E2
HANDLEADDRERR       4590
HANDLEAV1           4600
HANDLEAV2           4608
HANDLEAV3           4610
HANDLEAV4           4618
HANDLEAV5           4620
HANDLEAV6           4628
HANDLEAV7           4630
HANDLEBUSERR        4578
HANDLECHKINST       45B8
HANDLECLEANUP       46C0
HANDLECLEANUP:INFLOOP  46D0
HANDLEILLINST       45A8
HANDLELINEA         45D8
HANDLELINEF         45E0
HANDLEPRIV          45C8
HANDLERES1          45E8
HANDLERES10         45E8
HANDLERES11         45E8
HANDLERES2          45E8
HANDLERES3          45E8
HANDLERES4          45E8
HANDLERES5          45E8
HANDLERES6          45E8
HANDLERES7          45E8
HANDLERES8          45E8
HANDLERES9          45E8
HANDLESPUR          45F8
HANDLETRACE         45D0
HANDLETRAP0         4638
HANDLETRAP1         4640
HANDLETRAP10        4688
HANDLETRAP11        4690
HANDLETRAP12        4698
HANDLETRAP13        46A0
HANDLETRAP14        46A8
HANDLETRAP15        46B0
HANDLETRAP2         4648
HANDLETRAP3         4650
HANDLETRAP4         4658
HANDLETRAP5         4660
HANDLETRAP6         4668
HANDLETRAP7         4670
HANDLETRAP8         4678
HANDLETRAP9         4680
HANDLETRAPV         45C0
HANDLEUNINIT        45F0
HANDLEUNUSED        46B8
HANDLEZERODIV       45B0
HEXTOINT            5254
HEXTOINT:H2I_1      5254
HEXTOINT:H2I_2      527C
HEXTOINT:H2I_ERR    5288
HEXTOINT:H2I_X      5284
HEXTOINTECHO        528E
HEXTOINTECHO:H2I_1  528E
HEXTOINTECHO:H2I_2  52BA
HEXTOINTECHO:H2I_ERR  52C6
HEXTOINTECHO:H2I_X  52C2
HI_SPEED            1
IIMSG               498A
IMR                 D0000B
IO_BASE             F80000
IPR                 D0001B
ISR                 D0000B
IVR                 D00019
JMPADDRERR          4008
JMPAV1              40B8
JMPAV2              40C0
JMPAV3              40C8
JMPAV4              40D0
JMPAV5              40D8
JMPAV6              40E0
JMPAV7              40E8
JMPBUSERR           4000
JMPCHKINST          4020
JMPILLINST          4010
JMPLINEA            4040
JMPLINEF            4048
JMPPRIV             4030
JMPRES1             4050
JMPRES10            40A0
JMPRES11            40A8
JMPRES2             4058
JMPRES3             4060
JMPRES4             4070
JMPRES5             4078
JMPRES6             4080
JMPRES7             4088
JMPRES8             4090
JMPRES9             4098
JMPSPUR             40B0
JMPTRACE            4038
JMPTRAP0            40F0
JMPTRAP1            40F8
JMPTRAP10           4140
JMPTRAP11           4148
JMPTRAP12           4150
JMPTRAP13           4158
JMPTRAP14           4160
JMPTRAP15           4168
JMPTRAP2            4100
JMPTRAP3            4108
JMPTRAP4            4110
JMPTRAP5            4118
JMPTRAP6            4120
JMPTRAP7            4128
JMPTRAP8            4130
JMPTRAP9            4138
JMPTRAPV            4028
JMPUNINIT           4068
JMPUNUSED           4170
JMPZERODIV          4018
LAMSG               49C5
LF                  A
LFMSG               49F5
MAKEPRINTABLE       5242
MAKEPRINTABLE:MP_1  524E
MAKEPRINTABLE:MP_X  5252
MEM_BASE            F00000
MONLOOP             4F1E
MONLOOP_CRLF        4F8A
MONLOOP_NP          4F26
MONSTART            4F0E
MON_BASE            4000
MON_PRIV            800
MRA                 D00001
MRB                 D00011
MSGASCIIDUMP        1FF906
OPCR                D0001B
PUTC                5394
PUTCRLF             5540
PUTSTRING           5544
PUTSTRING:END       554E
PUTSTRING:LOOP      5544
PVMSG               4A25
RAMIVT              4178
RAMVECJUMP          0
RAM_BASE            100000
RAM_LEN             100000
RBA                 D00007
RBB                 D00017
RIMSG               4A62
ROPR                D0001F
SC145               F80020
SC145ADDR           10
SER0RXBUF           1FF806
SER0RXHEAD          1FF800
SER0RXQUEUE         1FF800
SER0RXSIZE          1FF804
SER0RXTAIL          1FF802
SEREXIT             538E
SERIAL_BUFFER_LOWER  19
SERIAL_BUFFER_MASK  FF
SERIAL_BUFFER_SIZE  100
SERIAL_BUFFER_UPPER  C8
SERINIT             52CC
SERISR              5336
SERSAVE             5368
SIMSG               4A94
SOPR                D0001D
SRA                 D00003
SRB                 D00013
STACK_START         1FF800
START               4EE8
START:COPY          4F00
STRBANNER1          5550
STRBASICERR1        57BE
STRBASICRETURN      57F4
STRCOLONSPACE       5750
STRCOMMANDS         55AE
STREASYTASK1        5786
STREASYTASK2        57A7
STRNEWLINE          574D
STRPROMPT           5738
STRUNINITINT        5753
STRUNKCMD           573B
STRUSERRETURN       576A
TBA                 D00007
TBB                 D00017
TR0MSG              4AFF
TR10MSG             4CE9
TR11MSG             4D1B
TR12MSG             4D4D
TR13MSG             4D7F
TR14MSG             4DB1
TR15MSG             4DE3
TR1MSG              4B30
TR2MSG              4B61
TR3MSG              4B92
TR4MSG              4BC3
TR5MSG              4BF4
TR6MSG              4C25
TR7MSG              4C56
TR8MSG              4C87
TR9MSG              4CB8
TRMSG               4AD0
TVMSG               4E15
UIMSG               4E44
USERMSG             4E85
VEC_BASE            100000
VEC_SIZE            400
WRITEADDR24         550C
WRITEADDR32         5500
WRITEBYTE           551E
WRITENIBBLE         5526
WRITENIBBLE:WN1     5534
WRITEWORD           5516
ZDMSG               4EB3
